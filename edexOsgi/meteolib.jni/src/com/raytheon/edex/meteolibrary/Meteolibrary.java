/* !---- DO NOT EDIT: This file autogenerated by com/sun/gluegen/JavaEmitter.java on Thu Jul 28 14:50:38 CDT 2011 ----! */

package com.raytheon.edex.meteolibrary;

import com.sun.gluegen.runtime.*;

public class Meteolibrary 
{


  /** Interface to C language function: <br> <code> void add_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  public static void add_aray(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.IntBuffer mode)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (mode != null && _direct != BufferFactory.isDirect(mode))
      throw new RuntimeException("Argument \"mode\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        add_aray0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), mode, BufferFactory.getDirectBufferByteOffset(mode));
    } else {
      add_aray1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(mode), BufferFactory.getIndirectBufferByteOffset(mode));
    }
  }

  /** Entry point to C language function: <br> <code> void add_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  private static native void add_aray0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object mode, int mode_byte_offset);

  /** Entry point to C language function: <br> <code> void add_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  private static native void add_aray1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object mode, int mode_byte_offset);

  /** Interface to C language function: <br> <code> void add_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  public static void add_aray(float[] a, int a_offset, float[] b, int b_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, int[] mode, int mode_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(mode != null && mode.length <= mode_offset)
      throw new RuntimeException("array offset argument \"mode_offset\" (" + mode_offset + ") equals or exceeds array length (" + mode.length + ")");
        add_aray1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, mode, BufferFactory.SIZEOF_INT * mode_offset);

  }

  /** Interface to C language function: <br> <code> void add_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void add_by_cnst(java.nio.FloatBuffer a, java.nio.FloatBuffer cnst, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (cnst != null && _direct != BufferFactory.isDirect(cnst))
      throw new RuntimeException("Argument \"cnst\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        add_by_cnst0(a, BufferFactory.getDirectBufferByteOffset(a), cnst, BufferFactory.getDirectBufferByteOffset(cnst), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      add_by_cnst1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(cnst), BufferFactory.getIndirectBufferByteOffset(cnst), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void add_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void add_by_cnst0(Object a, int a_byte_offset, Object cnst, int cnst_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void add_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void add_by_cnst1(Object a, int a_byte_offset, Object cnst, int cnst_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void add_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void add_by_cnst(float[] a, int a_offset, float[] cnst, int cnst_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(cnst != null && cnst.length <= cnst_offset)
      throw new RuntimeException("array offset argument \"cnst_offset\" (" + cnst_offset + ") equals or exceeds array length (" + cnst.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        add_by_cnst1(a, BufferFactory.SIZEOF_FLOAT * a_offset, cnst, BufferFactory.SIZEOF_FLOAT * cnst_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> float adiabatic_te(const float *  temp, const float *  press); </code>    */
  public static float adiabatic_te(java.nio.FloatBuffer temp, java.nio.FloatBuffer press)
  {
    boolean _direct = BufferFactory.isDirect(temp);
    if (press != null && _direct != BufferFactory.isDirect(press))
      throw new RuntimeException("Argument \"press\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return adiabatic_te0(temp, BufferFactory.getDirectBufferByteOffset(temp), press, BufferFactory.getDirectBufferByteOffset(press));
    } else {
      return adiabatic_te1(BufferFactory.getArray(temp), BufferFactory.getIndirectBufferByteOffset(temp), BufferFactory.getArray(press), BufferFactory.getIndirectBufferByteOffset(press));
    }
  }

  /** Entry point to C language function: <br> <code> float adiabatic_te(const float *  temp, const float *  press); </code>    */
  private static native float adiabatic_te0(Object temp, int temp_byte_offset, Object press, int press_byte_offset);

  /** Entry point to C language function: <br> <code> float adiabatic_te(const float *  temp, const float *  press); </code>    */
  private static native float adiabatic_te1(Object temp, int temp_byte_offset, Object press, int press_byte_offset);

  /** Interface to C language function: <br> <code> float adiabatic_te(const float *  temp, const float *  press); </code>    */
  public static float adiabatic_te(float[] temp, int temp_offset, float[] press, int press_offset)
  {
    if(temp != null && temp.length <= temp_offset)
      throw new RuntimeException("array offset argument \"temp_offset\" (" + temp_offset + ") equals or exceeds array length (" + temp.length + ")");
    if(press != null && press.length <= press_offset)
      throw new RuntimeException("array offset argument \"press_offset\" (" + press_offset + ") equals or exceeds array length (" + press.length + ")");
        return adiabatic_te1(temp, BufferFactory.SIZEOF_FLOAT * temp_offset, press, BufferFactory.SIZEOF_FLOAT * press_offset);

  }

  /** Interface to C language function: <br> <code> void alt2press(float *  alt, float *  z, int *  mni, int *  ni, int *  nj, float *  p); </code>    */
  public static void alt2press(java.nio.FloatBuffer alt, java.nio.FloatBuffer z, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer p)
  {
    boolean _direct = BufferFactory.isDirect(alt);
    if (z != null && _direct != BufferFactory.isDirect(z))
      throw new RuntimeException("Argument \"z\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        alt2press0(alt, BufferFactory.getDirectBufferByteOffset(alt), z, BufferFactory.getDirectBufferByteOffset(z), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), p, BufferFactory.getDirectBufferByteOffset(p));
    } else {
      alt2press1(BufferFactory.getArray(alt), BufferFactory.getIndirectBufferByteOffset(alt), BufferFactory.getArray(z), BufferFactory.getIndirectBufferByteOffset(z), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p));
    }
  }

  /** Entry point to C language function: <br> <code> void alt2press(float *  alt, float *  z, int *  mni, int *  ni, int *  nj, float *  p); </code>    */
  private static native void alt2press0(Object alt, int alt_byte_offset, Object z, int z_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object p, int p_byte_offset);

  /** Entry point to C language function: <br> <code> void alt2press(float *  alt, float *  z, int *  mni, int *  ni, int *  nj, float *  p); </code>    */
  private static native void alt2press1(Object alt, int alt_byte_offset, Object z, int z_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object p, int p_byte_offset);

  /** Interface to C language function: <br> <code> void alt2press(float *  alt, float *  z, int *  mni, int *  ni, int *  nj, float *  p); </code>    */
  public static void alt2press(float[] alt, int alt_offset, float[] z, int z_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] p, int p_offset)
  {
    if(alt != null && alt.length <= alt_offset)
      throw new RuntimeException("array offset argument \"alt_offset\" (" + alt_offset + ") equals or exceeds array length (" + alt.length + ")");
    if(z != null && z.length <= z_offset)
      throw new RuntimeException("array offset argument \"z_offset\" (" + z_offset + ") equals or exceeds array length (" + z.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
        alt2press1(alt, BufferFactory.SIZEOF_FLOAT * alt_offset, z, BufferFactory.SIZEOF_FLOAT * z_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset);

  }

  /** Interface to C language function: <br> <code> void avwind(float *  ELEV, float *  TOP, float *  BOT, float *  HW, float *  PW, float *  TW, float *  UW, float *  VW, int *  NW, float *  UAVG, float *  VAVG, float *  AVDIR, float *  AVSPD); </code>    */
  public static void avwind(java.nio.FloatBuffer ELEV, java.nio.FloatBuffer TOP, java.nio.FloatBuffer BOT, java.nio.FloatBuffer HW, java.nio.FloatBuffer PW, java.nio.FloatBuffer TW, java.nio.FloatBuffer UW, java.nio.FloatBuffer VW, java.nio.IntBuffer NW, java.nio.FloatBuffer UAVG, java.nio.FloatBuffer VAVG, java.nio.FloatBuffer AVDIR, java.nio.FloatBuffer AVSPD)
  {
    boolean _direct = BufferFactory.isDirect(ELEV);
    if (TOP != null && _direct != BufferFactory.isDirect(TOP))
      throw new RuntimeException("Argument \"TOP\" : Buffers passed to this method must all be either direct or indirect");
    if (BOT != null && _direct != BufferFactory.isDirect(BOT))
      throw new RuntimeException("Argument \"BOT\" : Buffers passed to this method must all be either direct or indirect");
    if (HW != null && _direct != BufferFactory.isDirect(HW))
      throw new RuntimeException("Argument \"HW\" : Buffers passed to this method must all be either direct or indirect");
    if (PW != null && _direct != BufferFactory.isDirect(PW))
      throw new RuntimeException("Argument \"PW\" : Buffers passed to this method must all be either direct or indirect");
    if (TW != null && _direct != BufferFactory.isDirect(TW))
      throw new RuntimeException("Argument \"TW\" : Buffers passed to this method must all be either direct or indirect");
    if (UW != null && _direct != BufferFactory.isDirect(UW))
      throw new RuntimeException("Argument \"UW\" : Buffers passed to this method must all be either direct or indirect");
    if (VW != null && _direct != BufferFactory.isDirect(VW))
      throw new RuntimeException("Argument \"VW\" : Buffers passed to this method must all be either direct or indirect");
    if (NW != null && _direct != BufferFactory.isDirect(NW))
      throw new RuntimeException("Argument \"NW\" : Buffers passed to this method must all be either direct or indirect");
    if (UAVG != null && _direct != BufferFactory.isDirect(UAVG))
      throw new RuntimeException("Argument \"UAVG\" : Buffers passed to this method must all be either direct or indirect");
    if (VAVG != null && _direct != BufferFactory.isDirect(VAVG))
      throw new RuntimeException("Argument \"VAVG\" : Buffers passed to this method must all be either direct or indirect");
    if (AVDIR != null && _direct != BufferFactory.isDirect(AVDIR))
      throw new RuntimeException("Argument \"AVDIR\" : Buffers passed to this method must all be either direct or indirect");
    if (AVSPD != null && _direct != BufferFactory.isDirect(AVSPD))
      throw new RuntimeException("Argument \"AVSPD\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        avwind0(ELEV, BufferFactory.getDirectBufferByteOffset(ELEV), TOP, BufferFactory.getDirectBufferByteOffset(TOP), BOT, BufferFactory.getDirectBufferByteOffset(BOT), HW, BufferFactory.getDirectBufferByteOffset(HW), PW, BufferFactory.getDirectBufferByteOffset(PW), TW, BufferFactory.getDirectBufferByteOffset(TW), UW, BufferFactory.getDirectBufferByteOffset(UW), VW, BufferFactory.getDirectBufferByteOffset(VW), NW, BufferFactory.getDirectBufferByteOffset(NW), UAVG, BufferFactory.getDirectBufferByteOffset(UAVG), VAVG, BufferFactory.getDirectBufferByteOffset(VAVG), AVDIR, BufferFactory.getDirectBufferByteOffset(AVDIR), AVSPD, BufferFactory.getDirectBufferByteOffset(AVSPD));
    } else {
      avwind1(BufferFactory.getArray(ELEV), BufferFactory.getIndirectBufferByteOffset(ELEV), BufferFactory.getArray(TOP), BufferFactory.getIndirectBufferByteOffset(TOP), BufferFactory.getArray(BOT), BufferFactory.getIndirectBufferByteOffset(BOT), BufferFactory.getArray(HW), BufferFactory.getIndirectBufferByteOffset(HW), BufferFactory.getArray(PW), BufferFactory.getIndirectBufferByteOffset(PW), BufferFactory.getArray(TW), BufferFactory.getIndirectBufferByteOffset(TW), BufferFactory.getArray(UW), BufferFactory.getIndirectBufferByteOffset(UW), BufferFactory.getArray(VW), BufferFactory.getIndirectBufferByteOffset(VW), BufferFactory.getArray(NW), BufferFactory.getIndirectBufferByteOffset(NW), BufferFactory.getArray(UAVG), BufferFactory.getIndirectBufferByteOffset(UAVG), BufferFactory.getArray(VAVG), BufferFactory.getIndirectBufferByteOffset(VAVG), BufferFactory.getArray(AVDIR), BufferFactory.getIndirectBufferByteOffset(AVDIR), BufferFactory.getArray(AVSPD), BufferFactory.getIndirectBufferByteOffset(AVSPD));
    }
  }

  /** Entry point to C language function: <br> <code> void avwind(float *  ELEV, float *  TOP, float *  BOT, float *  HW, float *  PW, float *  TW, float *  UW, float *  VW, int *  NW, float *  UAVG, float *  VAVG, float *  AVDIR, float *  AVSPD); </code>    */
  private static native void avwind0(Object ELEV, int ELEV_byte_offset, Object TOP, int TOP_byte_offset, Object BOT, int BOT_byte_offset, Object HW, int HW_byte_offset, Object PW, int PW_byte_offset, Object TW, int TW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object NW, int NW_byte_offset, Object UAVG, int UAVG_byte_offset, Object VAVG, int VAVG_byte_offset, Object AVDIR, int AVDIR_byte_offset, Object AVSPD, int AVSPD_byte_offset);

  /** Entry point to C language function: <br> <code> void avwind(float *  ELEV, float *  TOP, float *  BOT, float *  HW, float *  PW, float *  TW, float *  UW, float *  VW, int *  NW, float *  UAVG, float *  VAVG, float *  AVDIR, float *  AVSPD); </code>    */
  private static native void avwind1(Object ELEV, int ELEV_byte_offset, Object TOP, int TOP_byte_offset, Object BOT, int BOT_byte_offset, Object HW, int HW_byte_offset, Object PW, int PW_byte_offset, Object TW, int TW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object NW, int NW_byte_offset, Object UAVG, int UAVG_byte_offset, Object VAVG, int VAVG_byte_offset, Object AVDIR, int AVDIR_byte_offset, Object AVSPD, int AVSPD_byte_offset);

  /** Interface to C language function: <br> <code> void avwind(float *  ELEV, float *  TOP, float *  BOT, float *  HW, float *  PW, float *  TW, float *  UW, float *  VW, int *  NW, float *  UAVG, float *  VAVG, float *  AVDIR, float *  AVSPD); </code>    */
  public static void avwind(float[] ELEV, int ELEV_offset, float[] TOP, int TOP_offset, float[] BOT, int BOT_offset, float[] HW, int HW_offset, float[] PW, int PW_offset, float[] TW, int TW_offset, float[] UW, int UW_offset, float[] VW, int VW_offset, int[] NW, int NW_offset, float[] UAVG, int UAVG_offset, float[] VAVG, int VAVG_offset, float[] AVDIR, int AVDIR_offset, float[] AVSPD, int AVSPD_offset)
  {
    if(ELEV != null && ELEV.length <= ELEV_offset)
      throw new RuntimeException("array offset argument \"ELEV_offset\" (" + ELEV_offset + ") equals or exceeds array length (" + ELEV.length + ")");
    if(TOP != null && TOP.length <= TOP_offset)
      throw new RuntimeException("array offset argument \"TOP_offset\" (" + TOP_offset + ") equals or exceeds array length (" + TOP.length + ")");
    if(BOT != null && BOT.length <= BOT_offset)
      throw new RuntimeException("array offset argument \"BOT_offset\" (" + BOT_offset + ") equals or exceeds array length (" + BOT.length + ")");
    if(HW != null && HW.length <= HW_offset)
      throw new RuntimeException("array offset argument \"HW_offset\" (" + HW_offset + ") equals or exceeds array length (" + HW.length + ")");
    if(PW != null && PW.length <= PW_offset)
      throw new RuntimeException("array offset argument \"PW_offset\" (" + PW_offset + ") equals or exceeds array length (" + PW.length + ")");
    if(TW != null && TW.length <= TW_offset)
      throw new RuntimeException("array offset argument \"TW_offset\" (" + TW_offset + ") equals or exceeds array length (" + TW.length + ")");
    if(UW != null && UW.length <= UW_offset)
      throw new RuntimeException("array offset argument \"UW_offset\" (" + UW_offset + ") equals or exceeds array length (" + UW.length + ")");
    if(VW != null && VW.length <= VW_offset)
      throw new RuntimeException("array offset argument \"VW_offset\" (" + VW_offset + ") equals or exceeds array length (" + VW.length + ")");
    if(NW != null && NW.length <= NW_offset)
      throw new RuntimeException("array offset argument \"NW_offset\" (" + NW_offset + ") equals or exceeds array length (" + NW.length + ")");
    if(UAVG != null && UAVG.length <= UAVG_offset)
      throw new RuntimeException("array offset argument \"UAVG_offset\" (" + UAVG_offset + ") equals or exceeds array length (" + UAVG.length + ")");
    if(VAVG != null && VAVG.length <= VAVG_offset)
      throw new RuntimeException("array offset argument \"VAVG_offset\" (" + VAVG_offset + ") equals or exceeds array length (" + VAVG.length + ")");
    if(AVDIR != null && AVDIR.length <= AVDIR_offset)
      throw new RuntimeException("array offset argument \"AVDIR_offset\" (" + AVDIR_offset + ") equals or exceeds array length (" + AVDIR.length + ")");
    if(AVSPD != null && AVSPD.length <= AVSPD_offset)
      throw new RuntimeException("array offset argument \"AVSPD_offset\" (" + AVSPD_offset + ") equals or exceeds array length (" + AVSPD.length + ")");
        avwind1(ELEV, BufferFactory.SIZEOF_FLOAT * ELEV_offset, TOP, BufferFactory.SIZEOF_FLOAT * TOP_offset, BOT, BufferFactory.SIZEOF_FLOAT * BOT_offset, HW, BufferFactory.SIZEOF_FLOAT * HW_offset, PW, BufferFactory.SIZEOF_FLOAT * PW_offset, TW, BufferFactory.SIZEOF_FLOAT * TW_offset, UW, BufferFactory.SIZEOF_FLOAT * UW_offset, VW, BufferFactory.SIZEOF_FLOAT * VW_offset, NW, BufferFactory.SIZEOF_INT * NW_offset, UAVG, BufferFactory.SIZEOF_FLOAT * UAVG_offset, VAVG, BufferFactory.SIZEOF_FLOAT * VAVG_offset, AVDIR, BufferFactory.SIZEOF_FLOAT * AVDIR_offset, AVSPD, BufferFactory.SIZEOF_FLOAT * AVSPD_offset);

  }

  /** Interface to C language function: <br> <code> float calcHeatIndex(float temp, float dewPoint); </code>    */
  public static native float calcHeatIndex(float temp, float dewPoint);

  /** Interface to C language function: <br> <code> float calcWindChill(float temp, float windSpd); </code>    */
  public static native float calcWindChill(float temp, float windSpd);

  /** Interface to C language function: <br> <code> void calccondpr(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calccondpr(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calccondpr0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      calccondpr1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void calccondpr(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calccondpr0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void calccondpr(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calccondpr1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void calccondpr(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calccondpr(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        calccondpr1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void calccondprdef(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calccondprdef(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calccondprdef0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      calccondprdef1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void calccondprdef(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calccondprdef0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void calccondprdef(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calccondprdef1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void calccondprdef(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calccondprdef(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        calccondprdef1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void calcdpd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  dpd); </code>    */
  public static void calcdpd(java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer dpd)
  {
    boolean _direct = BufferFactory.isDirect(t);
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (dpd != null && _direct != BufferFactory.isDirect(dpd))
      throw new RuntimeException("Argument \"dpd\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcdpd0(t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), dpd, BufferFactory.getDirectBufferByteOffset(dpd));
    } else {
      calcdpd1(BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(dpd), BufferFactory.getIndirectBufferByteOffset(dpd));
    }
  }

  /** Entry point to C language function: <br> <code> void calcdpd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  dpd); </code>    */
  private static native void calcdpd0(Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dpd, int dpd_byte_offset);

  /** Entry point to C language function: <br> <code> void calcdpd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  dpd); </code>    */
  private static native void calcdpd1(Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dpd, int dpd_byte_offset);

  /** Interface to C language function: <br> <code> void calcdpd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  dpd); </code>    */
  public static void calcdpd(float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] dpd, int dpd_offset)
  {
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(dpd != null && dpd.length <= dpd_offset)
      throw new RuntimeException("array offset argument \"dpd_offset\" (" + dpd_offset + ") equals or exceeds array length (" + dpd.length + ")");
        calcdpd1(t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, dpd, BufferFactory.SIZEOF_FLOAT * dpd_offset);

  }

  /** Interface to C language function: <br> <code> void calchelicity(float *  HW, float *  PW, float *  UW, float *  VW, int *  NW, float *  elev, float *  ztop, float *  ghx, float *  ghy, float *  diravg, float *  spdavg, float *  stmdir, float *  stmspd, float *  helicity, float *  SRHel); </code>    */
  public static void calchelicity(java.nio.FloatBuffer HW, java.nio.FloatBuffer PW, java.nio.FloatBuffer UW, java.nio.FloatBuffer VW, java.nio.IntBuffer NW, java.nio.FloatBuffer elev, java.nio.FloatBuffer ztop, java.nio.FloatBuffer ghx, java.nio.FloatBuffer ghy, java.nio.FloatBuffer diravg, java.nio.FloatBuffer spdavg, java.nio.FloatBuffer stmdir, java.nio.FloatBuffer stmspd, java.nio.FloatBuffer helicity, java.nio.FloatBuffer SRHel)
  {
    boolean _direct = BufferFactory.isDirect(HW);
    if (PW != null && _direct != BufferFactory.isDirect(PW))
      throw new RuntimeException("Argument \"PW\" : Buffers passed to this method must all be either direct or indirect");
    if (UW != null && _direct != BufferFactory.isDirect(UW))
      throw new RuntimeException("Argument \"UW\" : Buffers passed to this method must all be either direct or indirect");
    if (VW != null && _direct != BufferFactory.isDirect(VW))
      throw new RuntimeException("Argument \"VW\" : Buffers passed to this method must all be either direct or indirect");
    if (NW != null && _direct != BufferFactory.isDirect(NW))
      throw new RuntimeException("Argument \"NW\" : Buffers passed to this method must all be either direct or indirect");
    if (elev != null && _direct != BufferFactory.isDirect(elev))
      throw new RuntimeException("Argument \"elev\" : Buffers passed to this method must all be either direct or indirect");
    if (ztop != null && _direct != BufferFactory.isDirect(ztop))
      throw new RuntimeException("Argument \"ztop\" : Buffers passed to this method must all be either direct or indirect");
    if (ghx != null && _direct != BufferFactory.isDirect(ghx))
      throw new RuntimeException("Argument \"ghx\" : Buffers passed to this method must all be either direct or indirect");
    if (ghy != null && _direct != BufferFactory.isDirect(ghy))
      throw new RuntimeException("Argument \"ghy\" : Buffers passed to this method must all be either direct or indirect");
    if (diravg != null && _direct != BufferFactory.isDirect(diravg))
      throw new RuntimeException("Argument \"diravg\" : Buffers passed to this method must all be either direct or indirect");
    if (spdavg != null && _direct != BufferFactory.isDirect(spdavg))
      throw new RuntimeException("Argument \"spdavg\" : Buffers passed to this method must all be either direct or indirect");
    if (stmdir != null && _direct != BufferFactory.isDirect(stmdir))
      throw new RuntimeException("Argument \"stmdir\" : Buffers passed to this method must all be either direct or indirect");
    if (stmspd != null && _direct != BufferFactory.isDirect(stmspd))
      throw new RuntimeException("Argument \"stmspd\" : Buffers passed to this method must all be either direct or indirect");
    if (helicity != null && _direct != BufferFactory.isDirect(helicity))
      throw new RuntimeException("Argument \"helicity\" : Buffers passed to this method must all be either direct or indirect");
    if (SRHel != null && _direct != BufferFactory.isDirect(SRHel))
      throw new RuntimeException("Argument \"SRHel\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calchelicity0(HW, BufferFactory.getDirectBufferByteOffset(HW), PW, BufferFactory.getDirectBufferByteOffset(PW), UW, BufferFactory.getDirectBufferByteOffset(UW), VW, BufferFactory.getDirectBufferByteOffset(VW), NW, BufferFactory.getDirectBufferByteOffset(NW), elev, BufferFactory.getDirectBufferByteOffset(elev), ztop, BufferFactory.getDirectBufferByteOffset(ztop), ghx, BufferFactory.getDirectBufferByteOffset(ghx), ghy, BufferFactory.getDirectBufferByteOffset(ghy), diravg, BufferFactory.getDirectBufferByteOffset(diravg), spdavg, BufferFactory.getDirectBufferByteOffset(spdavg), stmdir, BufferFactory.getDirectBufferByteOffset(stmdir), stmspd, BufferFactory.getDirectBufferByteOffset(stmspd), helicity, BufferFactory.getDirectBufferByteOffset(helicity), SRHel, BufferFactory.getDirectBufferByteOffset(SRHel));
    } else {
      calchelicity1(BufferFactory.getArray(HW), BufferFactory.getIndirectBufferByteOffset(HW), BufferFactory.getArray(PW), BufferFactory.getIndirectBufferByteOffset(PW), BufferFactory.getArray(UW), BufferFactory.getIndirectBufferByteOffset(UW), BufferFactory.getArray(VW), BufferFactory.getIndirectBufferByteOffset(VW), BufferFactory.getArray(NW), BufferFactory.getIndirectBufferByteOffset(NW), BufferFactory.getArray(elev), BufferFactory.getIndirectBufferByteOffset(elev), BufferFactory.getArray(ztop), BufferFactory.getIndirectBufferByteOffset(ztop), BufferFactory.getArray(ghx), BufferFactory.getIndirectBufferByteOffset(ghx), BufferFactory.getArray(ghy), BufferFactory.getIndirectBufferByteOffset(ghy), BufferFactory.getArray(diravg), BufferFactory.getIndirectBufferByteOffset(diravg), BufferFactory.getArray(spdavg), BufferFactory.getIndirectBufferByteOffset(spdavg), BufferFactory.getArray(stmdir), BufferFactory.getIndirectBufferByteOffset(stmdir), BufferFactory.getArray(stmspd), BufferFactory.getIndirectBufferByteOffset(stmspd), BufferFactory.getArray(helicity), BufferFactory.getIndirectBufferByteOffset(helicity), BufferFactory.getArray(SRHel), BufferFactory.getIndirectBufferByteOffset(SRHel));
    }
  }

  /** Entry point to C language function: <br> <code> void calchelicity(float *  HW, float *  PW, float *  UW, float *  VW, int *  NW, float *  elev, float *  ztop, float *  ghx, float *  ghy, float *  diravg, float *  spdavg, float *  stmdir, float *  stmspd, float *  helicity, float *  SRHel); </code>    */
  private static native void calchelicity0(Object HW, int HW_byte_offset, Object PW, int PW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object NW, int NW_byte_offset, Object elev, int elev_byte_offset, Object ztop, int ztop_byte_offset, Object ghx, int ghx_byte_offset, Object ghy, int ghy_byte_offset, Object diravg, int diravg_byte_offset, Object spdavg, int spdavg_byte_offset, Object stmdir, int stmdir_byte_offset, Object stmspd, int stmspd_byte_offset, Object helicity, int helicity_byte_offset, Object SRHel, int SRHel_byte_offset);

  /** Entry point to C language function: <br> <code> void calchelicity(float *  HW, float *  PW, float *  UW, float *  VW, int *  NW, float *  elev, float *  ztop, float *  ghx, float *  ghy, float *  diravg, float *  spdavg, float *  stmdir, float *  stmspd, float *  helicity, float *  SRHel); </code>    */
  private static native void calchelicity1(Object HW, int HW_byte_offset, Object PW, int PW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object NW, int NW_byte_offset, Object elev, int elev_byte_offset, Object ztop, int ztop_byte_offset, Object ghx, int ghx_byte_offset, Object ghy, int ghy_byte_offset, Object diravg, int diravg_byte_offset, Object spdavg, int spdavg_byte_offset, Object stmdir, int stmdir_byte_offset, Object stmspd, int stmspd_byte_offset, Object helicity, int helicity_byte_offset, Object SRHel, int SRHel_byte_offset);

  /** Interface to C language function: <br> <code> void calchelicity(float *  HW, float *  PW, float *  UW, float *  VW, int *  NW, float *  elev, float *  ztop, float *  ghx, float *  ghy, float *  diravg, float *  spdavg, float *  stmdir, float *  stmspd, float *  helicity, float *  SRHel); </code>    */
  public static void calchelicity(float[] HW, int HW_offset, float[] PW, int PW_offset, float[] UW, int UW_offset, float[] VW, int VW_offset, int[] NW, int NW_offset, float[] elev, int elev_offset, float[] ztop, int ztop_offset, float[] ghx, int ghx_offset, float[] ghy, int ghy_offset, float[] diravg, int diravg_offset, float[] spdavg, int spdavg_offset, float[] stmdir, int stmdir_offset, float[] stmspd, int stmspd_offset, float[] helicity, int helicity_offset, float[] SRHel, int SRHel_offset)
  {
    if(HW != null && HW.length <= HW_offset)
      throw new RuntimeException("array offset argument \"HW_offset\" (" + HW_offset + ") equals or exceeds array length (" + HW.length + ")");
    if(PW != null && PW.length <= PW_offset)
      throw new RuntimeException("array offset argument \"PW_offset\" (" + PW_offset + ") equals or exceeds array length (" + PW.length + ")");
    if(UW != null && UW.length <= UW_offset)
      throw new RuntimeException("array offset argument \"UW_offset\" (" + UW_offset + ") equals or exceeds array length (" + UW.length + ")");
    if(VW != null && VW.length <= VW_offset)
      throw new RuntimeException("array offset argument \"VW_offset\" (" + VW_offset + ") equals or exceeds array length (" + VW.length + ")");
    if(NW != null && NW.length <= NW_offset)
      throw new RuntimeException("array offset argument \"NW_offset\" (" + NW_offset + ") equals or exceeds array length (" + NW.length + ")");
    if(elev != null && elev.length <= elev_offset)
      throw new RuntimeException("array offset argument \"elev_offset\" (" + elev_offset + ") equals or exceeds array length (" + elev.length + ")");
    if(ztop != null && ztop.length <= ztop_offset)
      throw new RuntimeException("array offset argument \"ztop_offset\" (" + ztop_offset + ") equals or exceeds array length (" + ztop.length + ")");
    if(ghx != null && ghx.length <= ghx_offset)
      throw new RuntimeException("array offset argument \"ghx_offset\" (" + ghx_offset + ") equals or exceeds array length (" + ghx.length + ")");
    if(ghy != null && ghy.length <= ghy_offset)
      throw new RuntimeException("array offset argument \"ghy_offset\" (" + ghy_offset + ") equals or exceeds array length (" + ghy.length + ")");
    if(diravg != null && diravg.length <= diravg_offset)
      throw new RuntimeException("array offset argument \"diravg_offset\" (" + diravg_offset + ") equals or exceeds array length (" + diravg.length + ")");
    if(spdavg != null && spdavg.length <= spdavg_offset)
      throw new RuntimeException("array offset argument \"spdavg_offset\" (" + spdavg_offset + ") equals or exceeds array length (" + spdavg.length + ")");
    if(stmdir != null && stmdir.length <= stmdir_offset)
      throw new RuntimeException("array offset argument \"stmdir_offset\" (" + stmdir_offset + ") equals or exceeds array length (" + stmdir.length + ")");
    if(stmspd != null && stmspd.length <= stmspd_offset)
      throw new RuntimeException("array offset argument \"stmspd_offset\" (" + stmspd_offset + ") equals or exceeds array length (" + stmspd.length + ")");
    if(helicity != null && helicity.length <= helicity_offset)
      throw new RuntimeException("array offset argument \"helicity_offset\" (" + helicity_offset + ") equals or exceeds array length (" + helicity.length + ")");
    if(SRHel != null && SRHel.length <= SRHel_offset)
      throw new RuntimeException("array offset argument \"SRHel_offset\" (" + SRHel_offset + ") equals or exceeds array length (" + SRHel.length + ")");
        calchelicity1(HW, BufferFactory.SIZEOF_FLOAT * HW_offset, PW, BufferFactory.SIZEOF_FLOAT * PW_offset, UW, BufferFactory.SIZEOF_FLOAT * UW_offset, VW, BufferFactory.SIZEOF_FLOAT * VW_offset, NW, BufferFactory.SIZEOF_INT * NW_offset, elev, BufferFactory.SIZEOF_FLOAT * elev_offset, ztop, BufferFactory.SIZEOF_FLOAT * ztop_offset, ghx, BufferFactory.SIZEOF_FLOAT * ghx_offset, ghy, BufferFactory.SIZEOF_FLOAT * ghy_offset, diravg, BufferFactory.SIZEOF_FLOAT * diravg_offset, spdavg, BufferFactory.SIZEOF_FLOAT * spdavg_offset, stmdir, BufferFactory.SIZEOF_FLOAT * stmdir_offset, stmspd, BufferFactory.SIZEOF_FLOAT * stmspd_offset, helicity, BufferFactory.SIZEOF_FLOAT * helicity_offset, SRHel, BufferFactory.SIZEOF_FLOAT * SRHel_offset);

  }

  /** Interface to C language function: <br> <code> void calckidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  K); </code>    */
  public static void calckidx(java.nio.FloatBuffer press, java.nio.FloatBuffer temp, java.nio.FloatBuffer td, int numOfLevel, java.nio.FloatBuffer K)
  {
    boolean _direct = BufferFactory.isDirect(press);
    if (temp != null && _direct != BufferFactory.isDirect(temp))
      throw new RuntimeException("Argument \"temp\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (K != null && _direct != BufferFactory.isDirect(K))
      throw new RuntimeException("Argument \"K\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calckidx0(press, BufferFactory.getDirectBufferByteOffset(press), temp, BufferFactory.getDirectBufferByteOffset(temp), td, BufferFactory.getDirectBufferByteOffset(td), numOfLevel, K, BufferFactory.getDirectBufferByteOffset(K));
    } else {
      calckidx1(BufferFactory.getArray(press), BufferFactory.getIndirectBufferByteOffset(press), BufferFactory.getArray(temp), BufferFactory.getIndirectBufferByteOffset(temp), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), numOfLevel, BufferFactory.getArray(K), BufferFactory.getIndirectBufferByteOffset(K));
    }
  }

  /** Entry point to C language function: <br> <code> void calckidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  K); </code>    */
  private static native void calckidx0(Object press, int press_byte_offset, Object temp, int temp_byte_offset, Object td, int td_byte_offset, int numOfLevel, Object K, int K_byte_offset);

  /** Entry point to C language function: <br> <code> void calckidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  K); </code>    */
  private static native void calckidx1(Object press, int press_byte_offset, Object temp, int temp_byte_offset, Object td, int td_byte_offset, int numOfLevel, Object K, int K_byte_offset);

  /** Interface to C language function: <br> <code> void calckidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  K); </code>    */
  public static void calckidx(float[] press, int press_offset, float[] temp, int temp_offset, float[] td, int td_offset, int numOfLevel, float[] K, int K_offset)
  {
    if(press != null && press.length <= press_offset)
      throw new RuntimeException("array offset argument \"press_offset\" (" + press_offset + ") equals or exceeds array length (" + press.length + ")");
    if(temp != null && temp.length <= temp_offset)
      throw new RuntimeException("array offset argument \"temp_offset\" (" + temp_offset + ") equals or exceeds array length (" + temp.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(K != null && K.length <= K_offset)
      throw new RuntimeException("array offset argument \"K_offset\" (" + K_offset + ") equals or exceeds array length (" + K.length + ")");
        calckidx1(press, BufferFactory.SIZEOF_FLOAT * press_offset, temp, BufferFactory.SIZEOF_FLOAT * temp_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, numOfLevel, K, BufferFactory.SIZEOF_FLOAT * K_offset);

  }

  /** Interface to C language function: <br> <code> void calcli(float *  p, float *  t, float *  rh, float *  t5, float *  p5, int *  mni, int *  ni, int *  nj, float *  li); </code>    */
  public static void calcli(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.FloatBuffer t5, java.nio.FloatBuffer p5, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer li)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (t5 != null && _direct != BufferFactory.isDirect(t5))
      throw new RuntimeException("Argument \"t5\" : Buffers passed to this method must all be either direct or indirect");
    if (p5 != null && _direct != BufferFactory.isDirect(p5))
      throw new RuntimeException("Argument \"p5\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (li != null && _direct != BufferFactory.isDirect(li))
      throw new RuntimeException("Argument \"li\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcli0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), t5, BufferFactory.getDirectBufferByteOffset(t5), p5, BufferFactory.getDirectBufferByteOffset(p5), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), li, BufferFactory.getDirectBufferByteOffset(li));
    } else {
      calcli1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(t5), BufferFactory.getIndirectBufferByteOffset(t5), BufferFactory.getArray(p5), BufferFactory.getIndirectBufferByteOffset(p5), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(li), BufferFactory.getIndirectBufferByteOffset(li));
    }
  }

  /** Entry point to C language function: <br> <code> void calcli(float *  p, float *  t, float *  rh, float *  t5, float *  p5, int *  mni, int *  ni, int *  nj, float *  li); </code>    */
  private static native void calcli0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object t5, int t5_byte_offset, Object p5, int p5_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object li, int li_byte_offset);

  /** Entry point to C language function: <br> <code> void calcli(float *  p, float *  t, float *  rh, float *  t5, float *  p5, int *  mni, int *  ni, int *  nj, float *  li); </code>    */
  private static native void calcli1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object t5, int t5_byte_offset, Object p5, int p5_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object li, int li_byte_offset);

  /** Interface to C language function: <br> <code> void calcli(float *  p, float *  t, float *  rh, float *  t5, float *  p5, int *  mni, int *  ni, int *  nj, float *  li); </code>    */
  public static void calcli(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, float[] t5, int t5_offset, float[] p5, int p5_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] li, int li_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(t5 != null && t5.length <= t5_offset)
      throw new RuntimeException("array offset argument \"t5_offset\" (" + t5_offset + ") equals or exceeds array length (" + t5.length + ")");
    if(p5 != null && p5.length <= p5_offset)
      throw new RuntimeException("array offset argument \"p5_offset\" (" + p5_offset + ") equals or exceeds array length (" + p5.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(li != null && li.length <= li_offset)
      throw new RuntimeException("array offset argument \"li_offset\" (" + li_offset + ") equals or exceeds array length (" + li.length + ")");
        calcli1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, t5, BufferFactory.SIZEOF_FLOAT * t5_offset, p5, BufferFactory.SIZEOF_FLOAT * p5_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, li, BufferFactory.SIZEOF_FLOAT * li_offset);

  }

  /** Interface to C language function: <br> <code> void calcpv(float *  p_up, float *  p_low, float *  o_up, float *  o_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dx, float *  dy, float *  coriolis); </code>    */
  public static void calcpv(java.nio.FloatBuffer p_up, java.nio.FloatBuffer p_low, java.nio.FloatBuffer o_up, java.nio.FloatBuffer o_low, java.nio.FloatBuffer pvort, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer u_up, java.nio.FloatBuffer v_up, java.nio.FloatBuffer u_low, java.nio.FloatBuffer v_low, java.nio.FloatBuffer avort1, java.nio.FloatBuffer avort2, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer coriolis)
  {
    boolean _direct = BufferFactory.isDirect(p_up);
    if (p_low != null && _direct != BufferFactory.isDirect(p_low))
      throw new RuntimeException("Argument \"p_low\" : Buffers passed to this method must all be either direct or indirect");
    if (o_up != null && _direct != BufferFactory.isDirect(o_up))
      throw new RuntimeException("Argument \"o_up\" : Buffers passed to this method must all be either direct or indirect");
    if (o_low != null && _direct != BufferFactory.isDirect(o_low))
      throw new RuntimeException("Argument \"o_low\" : Buffers passed to this method must all be either direct or indirect");
    if (pvort != null && _direct != BufferFactory.isDirect(pvort))
      throw new RuntimeException("Argument \"pvort\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (u_up != null && _direct != BufferFactory.isDirect(u_up))
      throw new RuntimeException("Argument \"u_up\" : Buffers passed to this method must all be either direct or indirect");
    if (v_up != null && _direct != BufferFactory.isDirect(v_up))
      throw new RuntimeException("Argument \"v_up\" : Buffers passed to this method must all be either direct or indirect");
    if (u_low != null && _direct != BufferFactory.isDirect(u_low))
      throw new RuntimeException("Argument \"u_low\" : Buffers passed to this method must all be either direct or indirect");
    if (v_low != null && _direct != BufferFactory.isDirect(v_low))
      throw new RuntimeException("Argument \"v_low\" : Buffers passed to this method must all be either direct or indirect");
    if (avort1 != null && _direct != BufferFactory.isDirect(avort1))
      throw new RuntimeException("Argument \"avort1\" : Buffers passed to this method must all be either direct or indirect");
    if (avort2 != null && _direct != BufferFactory.isDirect(avort2))
      throw new RuntimeException("Argument \"avort2\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (coriolis != null && _direct != BufferFactory.isDirect(coriolis))
      throw new RuntimeException("Argument \"coriolis\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcpv0(p_up, BufferFactory.getDirectBufferByteOffset(p_up), p_low, BufferFactory.getDirectBufferByteOffset(p_low), o_up, BufferFactory.getDirectBufferByteOffset(o_up), o_low, BufferFactory.getDirectBufferByteOffset(o_low), pvort, BufferFactory.getDirectBufferByteOffset(pvort), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), u_up, BufferFactory.getDirectBufferByteOffset(u_up), v_up, BufferFactory.getDirectBufferByteOffset(v_up), u_low, BufferFactory.getDirectBufferByteOffset(u_low), v_low, BufferFactory.getDirectBufferByteOffset(v_low), avort1, BufferFactory.getDirectBufferByteOffset(avort1), avort2, BufferFactory.getDirectBufferByteOffset(avort2), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), coriolis, BufferFactory.getDirectBufferByteOffset(coriolis));
    } else {
      calcpv1(BufferFactory.getArray(p_up), BufferFactory.getIndirectBufferByteOffset(p_up), BufferFactory.getArray(p_low), BufferFactory.getIndirectBufferByteOffset(p_low), BufferFactory.getArray(o_up), BufferFactory.getIndirectBufferByteOffset(o_up), BufferFactory.getArray(o_low), BufferFactory.getIndirectBufferByteOffset(o_low), BufferFactory.getArray(pvort), BufferFactory.getIndirectBufferByteOffset(pvort), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(u_up), BufferFactory.getIndirectBufferByteOffset(u_up), BufferFactory.getArray(v_up), BufferFactory.getIndirectBufferByteOffset(v_up), BufferFactory.getArray(u_low), BufferFactory.getIndirectBufferByteOffset(u_low), BufferFactory.getArray(v_low), BufferFactory.getIndirectBufferByteOffset(v_low), BufferFactory.getArray(avort1), BufferFactory.getIndirectBufferByteOffset(avort1), BufferFactory.getArray(avort2), BufferFactory.getIndirectBufferByteOffset(avort2), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(coriolis), BufferFactory.getIndirectBufferByteOffset(coriolis));
    }
  }

  /** Entry point to C language function: <br> <code> void calcpv(float *  p_up, float *  p_low, float *  o_up, float *  o_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dx, float *  dy, float *  coriolis); </code>    */
  private static native void calcpv0(Object p_up, int p_up_byte_offset, Object p_low, int p_low_byte_offset, Object o_up, int o_up_byte_offset, Object o_low, int o_low_byte_offset, Object pvort, int pvort_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object u_up, int u_up_byte_offset, Object v_up, int v_up_byte_offset, Object u_low, int u_low_byte_offset, Object v_low, int v_low_byte_offset, Object avort1, int avort1_byte_offset, Object avort2, int avort2_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset);

  /** Entry point to C language function: <br> <code> void calcpv(float *  p_up, float *  p_low, float *  o_up, float *  o_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dx, float *  dy, float *  coriolis); </code>    */
  private static native void calcpv1(Object p_up, int p_up_byte_offset, Object p_low, int p_low_byte_offset, Object o_up, int o_up_byte_offset, Object o_low, int o_low_byte_offset, Object pvort, int pvort_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object u_up, int u_up_byte_offset, Object v_up, int v_up_byte_offset, Object u_low, int u_low_byte_offset, Object v_low, int v_low_byte_offset, Object avort1, int avort1_byte_offset, Object avort2, int avort2_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset);

  /** Interface to C language function: <br> <code> void calcpv(float *  p_up, float *  p_low, float *  o_up, float *  o_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dx, float *  dy, float *  coriolis); </code>    */
  public static void calcpv(float[] p_up, int p_up_offset, float[] p_low, int p_low_offset, float[] o_up, int o_up_offset, float[] o_low, int o_low_offset, float[] pvort, int pvort_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] u_up, int u_up_offset, float[] v_up, int v_up_offset, float[] u_low, int u_low_offset, float[] v_low, int v_low_offset, float[] avort1, int avort1_offset, float[] avort2, int avort2_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] coriolis, int coriolis_offset)
  {
    if(p_up != null && p_up.length <= p_up_offset)
      throw new RuntimeException("array offset argument \"p_up_offset\" (" + p_up_offset + ") equals or exceeds array length (" + p_up.length + ")");
    if(p_low != null && p_low.length <= p_low_offset)
      throw new RuntimeException("array offset argument \"p_low_offset\" (" + p_low_offset + ") equals or exceeds array length (" + p_low.length + ")");
    if(o_up != null && o_up.length <= o_up_offset)
      throw new RuntimeException("array offset argument \"o_up_offset\" (" + o_up_offset + ") equals or exceeds array length (" + o_up.length + ")");
    if(o_low != null && o_low.length <= o_low_offset)
      throw new RuntimeException("array offset argument \"o_low_offset\" (" + o_low_offset + ") equals or exceeds array length (" + o_low.length + ")");
    if(pvort != null && pvort.length <= pvort_offset)
      throw new RuntimeException("array offset argument \"pvort_offset\" (" + pvort_offset + ") equals or exceeds array length (" + pvort.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(u_up != null && u_up.length <= u_up_offset)
      throw new RuntimeException("array offset argument \"u_up_offset\" (" + u_up_offset + ") equals or exceeds array length (" + u_up.length + ")");
    if(v_up != null && v_up.length <= v_up_offset)
      throw new RuntimeException("array offset argument \"v_up_offset\" (" + v_up_offset + ") equals or exceeds array length (" + v_up.length + ")");
    if(u_low != null && u_low.length <= u_low_offset)
      throw new RuntimeException("array offset argument \"u_low_offset\" (" + u_low_offset + ") equals or exceeds array length (" + u_low.length + ")");
    if(v_low != null && v_low.length <= v_low_offset)
      throw new RuntimeException("array offset argument \"v_low_offset\" (" + v_low_offset + ") equals or exceeds array length (" + v_low.length + ")");
    if(avort1 != null && avort1.length <= avort1_offset)
      throw new RuntimeException("array offset argument \"avort1_offset\" (" + avort1_offset + ") equals or exceeds array length (" + avort1.length + ")");
    if(avort2 != null && avort2.length <= avort2_offset)
      throw new RuntimeException("array offset argument \"avort2_offset\" (" + avort2_offset + ") equals or exceeds array length (" + avort2.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(coriolis != null && coriolis.length <= coriolis_offset)
      throw new RuntimeException("array offset argument \"coriolis_offset\" (" + coriolis_offset + ") equals or exceeds array length (" + coriolis.length + ")");
        calcpv1(p_up, BufferFactory.SIZEOF_FLOAT * p_up_offset, p_low, BufferFactory.SIZEOF_FLOAT * p_low_offset, o_up, BufferFactory.SIZEOF_FLOAT * o_up_offset, o_low, BufferFactory.SIZEOF_FLOAT * o_low_offset, pvort, BufferFactory.SIZEOF_FLOAT * pvort_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, u_up, BufferFactory.SIZEOF_FLOAT * u_up_offset, v_up, BufferFactory.SIZEOF_FLOAT * v_up_offset, u_low, BufferFactory.SIZEOF_FLOAT * u_low_offset, v_low, BufferFactory.SIZEOF_FLOAT * v_low_offset, avort1, BufferFactory.SIZEOF_FLOAT * avort1_offset, avort2, BufferFactory.SIZEOF_FLOAT * avort2_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, coriolis, BufferFactory.SIZEOF_FLOAT * coriolis_offset);

  }

  /** Interface to C language function: <br> <code> void calcrh(float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  public static void calcrh(java.nio.FloatBuffer t, java.nio.FloatBuffer td, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer rh)
  {
    boolean _direct = BufferFactory.isDirect(t);
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcrh0(t, BufferFactory.getDirectBufferByteOffset(t), td, BufferFactory.getDirectBufferByteOffset(td), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), rh, BufferFactory.getDirectBufferByteOffset(rh));
    } else {
      calcrh1(BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh));
    }
  }

  /** Entry point to C language function: <br> <code> void calcrh(float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  private static native void calcrh0(Object t, int t_byte_offset, Object td, int td_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object rh, int rh_byte_offset);

  /** Entry point to C language function: <br> <code> void calcrh(float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  private static native void calcrh1(Object t, int t_byte_offset, Object td, int td_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object rh, int rh_byte_offset);

  /** Interface to C language function: <br> <code> void calcrh(float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  public static void calcrh(float[] t, int t_offset, float[] td, int td_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] rh, int rh_offset)
  {
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
        calcrh1(t, BufferFactory.SIZEOF_FLOAT * t_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset);

  }

  /** Interface to C language function: <br> <code> void calcrh2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  public static void calcrh2(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer q, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer rh)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcrh20(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), q, BufferFactory.getDirectBufferByteOffset(q), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), rh, BufferFactory.getDirectBufferByteOffset(rh));
    } else {
      calcrh21(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh));
    }
  }

  /** Entry point to C language function: <br> <code> void calcrh2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  private static native void calcrh20(Object p, int p_byte_offset, Object t, int t_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object rh, int rh_byte_offset);

  /** Entry point to C language function: <br> <code> void calcrh2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  private static native void calcrh21(Object p, int p_byte_offset, Object t, int t_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object rh, int rh_byte_offset);

  /** Interface to C language function: <br> <code> void calcrh2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  rh); </code>    */
  public static void calcrh2(float[] p, int p_offset, float[] t, int t_offset, float[] q, int q_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] rh, int rh_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
        calcrh21(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset);

  }

  /** Interface to C language function: <br> <code> void calctd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  public static void calctd(java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer td)
  {
    boolean _direct = BufferFactory.isDirect(t);
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calctd0(t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), td, BufferFactory.getDirectBufferByteOffset(td));
    } else {
      calctd1(BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td));
    }
  }

  /** Entry point to C language function: <br> <code> void calctd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  private static native void calctd0(Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object td, int td_byte_offset);

  /** Entry point to C language function: <br> <code> void calctd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  private static native void calctd1(Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object td, int td_byte_offset);

  /** Interface to C language function: <br> <code> void calctd(float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  public static void calctd(float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] td, int td_offset)
  {
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
        calctd1(t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset);

  }

  /** Interface to C language function: <br> <code> void calctd2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  public static void calctd2(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer q, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer td)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calctd20(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), q, BufferFactory.getDirectBufferByteOffset(q), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), td, BufferFactory.getDirectBufferByteOffset(td));
    } else {
      calctd21(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td));
    }
  }

  /** Entry point to C language function: <br> <code> void calctd2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  private static native void calctd20(Object p, int p_byte_offset, Object t, int t_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object td, int td_byte_offset);

  /** Entry point to C language function: <br> <code> void calctd2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  private static native void calctd21(Object p, int p_byte_offset, Object t, int t_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object td, int td_byte_offset);

  /** Interface to C language function: <br> <code> void calctd2(float *  p, float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  td); </code>    */
  public static void calctd2(float[] p, int p_offset, float[] t, int t_offset, float[] q, int q_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] td, int td_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
        calctd21(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset);

  }

  /** Interface to C language function: <br> <code> void calcthetae(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calcthetae(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcthetae0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      calcthetae1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void calcthetae(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calcthetae0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void calcthetae(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calcthetae1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void calcthetae(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calcthetae(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        calcthetae1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void calcthetae2(float *  p, float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calcthetae2(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer td, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calcthetae20(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), td, BufferFactory.getDirectBufferByteOffset(td), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      calcthetae21(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void calcthetae2(float *  p, float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calcthetae20(Object p, int p_byte_offset, Object t, int t_byte_offset, Object td, int td_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void calcthetae2(float *  p, float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void calcthetae21(Object p, int p_byte_offset, Object t, int t_byte_offset, Object td, int td_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void calcthetae2(float *  p, float *  t, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void calcthetae2(float[] p, int p_offset, float[] t, int t_offset, float[] td, int td_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        calcthetae21(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void calctotidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  total); </code>    */
  public static void calctotidx(java.nio.FloatBuffer press, java.nio.FloatBuffer temp, java.nio.FloatBuffer td, int numOfLevel, java.nio.FloatBuffer total)
  {
    boolean _direct = BufferFactory.isDirect(press);
    if (temp != null && _direct != BufferFactory.isDirect(temp))
      throw new RuntimeException("Argument \"temp\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (total != null && _direct != BufferFactory.isDirect(total))
      throw new RuntimeException("Argument \"total\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calctotidx0(press, BufferFactory.getDirectBufferByteOffset(press), temp, BufferFactory.getDirectBufferByteOffset(temp), td, BufferFactory.getDirectBufferByteOffset(td), numOfLevel, total, BufferFactory.getDirectBufferByteOffset(total));
    } else {
      calctotidx1(BufferFactory.getArray(press), BufferFactory.getIndirectBufferByteOffset(press), BufferFactory.getArray(temp), BufferFactory.getIndirectBufferByteOffset(temp), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), numOfLevel, BufferFactory.getArray(total), BufferFactory.getIndirectBufferByteOffset(total));
    }
  }

  /** Entry point to C language function: <br> <code> void calctotidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  total); </code>    */
  private static native void calctotidx0(Object press, int press_byte_offset, Object temp, int temp_byte_offset, Object td, int td_byte_offset, int numOfLevel, Object total, int total_byte_offset);

  /** Entry point to C language function: <br> <code> void calctotidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  total); </code>    */
  private static native void calctotidx1(Object press, int press_byte_offset, Object temp, int temp_byte_offset, Object td, int td_byte_offset, int numOfLevel, Object total, int total_byte_offset);

  /** Interface to C language function: <br> <code> void calctotidx(float *  press, float *  temp, float *  td, int numOfLevel, float *  total); </code>    */
  public static void calctotidx(float[] press, int press_offset, float[] temp, int temp_offset, float[] td, int td_offset, int numOfLevel, float[] total, int total_offset)
  {
    if(press != null && press.length <= press_offset)
      throw new RuntimeException("array offset argument \"press_offset\" (" + press_offset + ") equals or exceeds array length (" + press.length + ")");
    if(temp != null && temp.length <= temp_offset)
      throw new RuntimeException("array offset argument \"temp_offset\" (" + temp_offset + ") equals or exceeds array length (" + temp.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(total != null && total.length <= total_offset)
      throw new RuntimeException("array offset argument \"total_offset\" (" + total_offset + ") equals or exceeds array length (" + total.length + ")");
        calctotidx1(press, BufferFactory.SIZEOF_FLOAT * press_offset, temp, BufferFactory.SIZEOF_FLOAT * temp_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, numOfLevel, total, BufferFactory.SIZEOF_FLOAT * total_offset);

  }

  /** Interface to C language function: <br> <code> void calctv(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  public static void calctv(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer tv)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (tv != null && _direct != BufferFactory.isDirect(tv))
      throw new RuntimeException("Argument \"tv\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calctv0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), tv, BufferFactory.getDirectBufferByteOffset(tv));
    } else {
      calctv1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(tv), BufferFactory.getIndirectBufferByteOffset(tv));
    }
  }

  /** Entry point to C language function: <br> <code> void calctv(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  private static native void calctv0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object tv, int tv_byte_offset);

  /** Entry point to C language function: <br> <code> void calctv(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  private static native void calctv1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object tv, int tv_byte_offset);

  /** Interface to C language function: <br> <code> void calctv(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  public static void calctv(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] tv, int tv_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(tv != null && tv.length <= tv_offset)
      throw new RuntimeException("array offset argument \"tv_offset\" (" + tv_offset + ") equals or exceeds array length (" + tv.length + ")");
        calctv1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, tv, BufferFactory.SIZEOF_FLOAT * tv_offset);

  }

  /** Interface to C language function: <br> <code> void calctv2(float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  public static void calctv2(java.nio.FloatBuffer t, java.nio.FloatBuffer q, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer tv)
  {
    boolean _direct = BufferFactory.isDirect(t);
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (tv != null && _direct != BufferFactory.isDirect(tv))
      throw new RuntimeException("Argument \"tv\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calctv20(t, BufferFactory.getDirectBufferByteOffset(t), q, BufferFactory.getDirectBufferByteOffset(q), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), tv, BufferFactory.getDirectBufferByteOffset(tv));
    } else {
      calctv21(BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(tv), BufferFactory.getIndirectBufferByteOffset(tv));
    }
  }

  /** Entry point to C language function: <br> <code> void calctv2(float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  private static native void calctv20(Object t, int t_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object tv, int tv_byte_offset);

  /** Entry point to C language function: <br> <code> void calctv2(float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  private static native void calctv21(Object t, int t_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object tv, int tv_byte_offset);

  /** Interface to C language function: <br> <code> void calctv2(float *  t, float *  q, int *  mni, int *  ni, int *  nj, float *  tv); </code>    */
  public static void calctv2(float[] t, int t_offset, float[] q, int q_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] tv, int tv_offset)
  {
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(tv != null && tv.length <= tv_offset)
      throw new RuntimeException("array offset argument \"tv_offset\" (" + tv_offset + ") equals or exceeds array length (" + tv.length + ")");
        calctv21(t, BufferFactory.SIZEOF_FLOAT * t_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, tv, BufferFactory.SIZEOF_FLOAT * tv_offset);

  }

  /** Interface to C language function: <br> <code> void calctw(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tw); </code>    */
  public static void calctw(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer tw)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (tw != null && _direct != BufferFactory.isDirect(tw))
      throw new RuntimeException("Argument \"tw\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        calctw0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), tw, BufferFactory.getDirectBufferByteOffset(tw));
    } else {
      calctw1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(tw), BufferFactory.getIndirectBufferByteOffset(tw));
    }
  }

  /** Entry point to C language function: <br> <code> void calctw(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tw); </code>    */
  private static native void calctw0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object tw, int tw_byte_offset);

  /** Entry point to C language function: <br> <code> void calctw(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tw); </code>    */
  private static native void calctw1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object tw, int tw_byte_offset);

  /** Interface to C language function: <br> <code> void calctw(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  tw); </code>    */
  public static void calctw(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] tw, int tw_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(tw != null && tw.length <= tw_offset)
      throw new RuntimeException("array offset argument \"tw_offset\" (" + tw_offset + ") equals or exceeds array length (" + tw.length + ")");
        calctw1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, tw, BufferFactory.SIZEOF_FLOAT * tw_offset);

  }

  /** Interface to C language function: <br> <code> int capeFunc(float usetv, const float *  *  p_dat, const float *  *  tve_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float *  cape_dat, float *  cin_dat); </code>    */
  public static int capeFunc(float usetv, java.nio.FloatBuffer[] p_dat, java.nio.FloatBuffer[] tve_dat, java.nio.FloatBuffer p0, java.nio.FloatBuffer th0, java.nio.FloatBuffer sh0, int mnx, int nx, int ny, int nz, java.nio.FloatBuffer cape_dat, java.nio.FloatBuffer cin_dat)
  {
    int[] p_dat_byte_offset_array = new int[p_dat.length];
    if (p_dat != null) {
      for (int _ctr = 0; _ctr < p_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(p_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"p_dat\" was not a direct buffer");
        }
        p_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(p_dat[_ctr]);
      }
    }
    int[] tve_dat_byte_offset_array = new int[tve_dat.length];
    if (tve_dat != null) {
      for (int _ctr = 0; _ctr < tve_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(tve_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"tve_dat\" was not a direct buffer");
        }
        tve_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(tve_dat[_ctr]);
      }
    }
    boolean _direct = BufferFactory.isDirect(p0);
    if (th0 != null && _direct != BufferFactory.isDirect(th0))
      throw new RuntimeException("Argument \"th0\" : Buffers passed to this method must all be either direct or indirect");
    if (sh0 != null && _direct != BufferFactory.isDirect(sh0))
      throw new RuntimeException("Argument \"sh0\" : Buffers passed to this method must all be either direct or indirect");
    if (cape_dat != null && _direct != BufferFactory.isDirect(cape_dat))
      throw new RuntimeException("Argument \"cape_dat\" : Buffers passed to this method must all be either direct or indirect");
    if (cin_dat != null && _direct != BufferFactory.isDirect(cin_dat))
      throw new RuntimeException("Argument \"cin_dat\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return capeFunc0(usetv, p_dat, p_dat_byte_offset_array, tve_dat, tve_dat_byte_offset_array, p0, BufferFactory.getDirectBufferByteOffset(p0), th0, BufferFactory.getDirectBufferByteOffset(th0), sh0, BufferFactory.getDirectBufferByteOffset(sh0), mnx, nx, ny, nz, cape_dat, BufferFactory.getDirectBufferByteOffset(cape_dat), cin_dat, BufferFactory.getDirectBufferByteOffset(cin_dat));
    } else {
      return capeFunc1(usetv, p_dat, p_dat_byte_offset_array, tve_dat, tve_dat_byte_offset_array, BufferFactory.getArray(p0), BufferFactory.getIndirectBufferByteOffset(p0), BufferFactory.getArray(th0), BufferFactory.getIndirectBufferByteOffset(th0), BufferFactory.getArray(sh0), BufferFactory.getIndirectBufferByteOffset(sh0), mnx, nx, ny, nz, BufferFactory.getArray(cape_dat), BufferFactory.getIndirectBufferByteOffset(cape_dat), BufferFactory.getArray(cin_dat), BufferFactory.getIndirectBufferByteOffset(cin_dat));
    }
  }

  /** Entry point to C language function: <br> <code> int capeFunc(float usetv, const float *  *  p_dat, const float *  *  tve_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float *  cape_dat, float *  cin_dat); </code>    */
  private static native int capeFunc0(float usetv, Object[] p_dat, int[] p_dat_byte_offset_array, Object[] tve_dat, int[] tve_dat_byte_offset_array, Object p0, int p0_byte_offset, Object th0, int th0_byte_offset, Object sh0, int sh0_byte_offset, int mnx, int nx, int ny, int nz, Object cape_dat, int cape_dat_byte_offset, Object cin_dat, int cin_dat_byte_offset);

  /** Entry point to C language function: <br> <code> int capeFunc(float usetv, const float *  *  p_dat, const float *  *  tve_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float *  cape_dat, float *  cin_dat); </code>    */
  private static native int capeFunc1(float usetv, Object[] p_dat, int[] p_dat_byte_offset_array, Object[] tve_dat, int[] tve_dat_byte_offset_array, Object p0, int p0_byte_offset, Object th0, int th0_byte_offset, Object sh0, int sh0_byte_offset, int mnx, int nx, int ny, int nz, Object cape_dat, int cape_dat_byte_offset, Object cin_dat, int cin_dat_byte_offset);

  /** Interface to C language function: <br> <code> int capeFunc(float usetv, const float *  *  p_dat, const float *  *  tve_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float *  cape_dat, float *  cin_dat); </code>    */
  public static int capeFunc(float usetv, java.nio.FloatBuffer[] p_dat, java.nio.FloatBuffer[] tve_dat, float[] p0, int p0_offset, float[] th0, int th0_offset, float[] sh0, int sh0_offset, int mnx, int nx, int ny, int nz, float[] cape_dat, int cape_dat_offset, float[] cin_dat, int cin_dat_offset)
  {
    int[] p_dat_byte_offset_array = new int[p_dat.length];
    if (p_dat != null) {
      for (int _ctr = 0; _ctr < p_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(p_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"p_dat\" was not a direct buffer");
        }
        p_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(p_dat[_ctr]);
      }
    }
    int[] tve_dat_byte_offset_array = new int[tve_dat.length];
    if (tve_dat != null) {
      for (int _ctr = 0; _ctr < tve_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(tve_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"tve_dat\" was not a direct buffer");
        }
        tve_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(tve_dat[_ctr]);
      }
    }
    if(p0 != null && p0.length <= p0_offset)
      throw new RuntimeException("array offset argument \"p0_offset\" (" + p0_offset + ") equals or exceeds array length (" + p0.length + ")");
    if(th0 != null && th0.length <= th0_offset)
      throw new RuntimeException("array offset argument \"th0_offset\" (" + th0_offset + ") equals or exceeds array length (" + th0.length + ")");
    if(sh0 != null && sh0.length <= sh0_offset)
      throw new RuntimeException("array offset argument \"sh0_offset\" (" + sh0_offset + ") equals or exceeds array length (" + sh0.length + ")");
    if(cape_dat != null && cape_dat.length <= cape_dat_offset)
      throw new RuntimeException("array offset argument \"cape_dat_offset\" (" + cape_dat_offset + ") equals or exceeds array length (" + cape_dat.length + ")");
    if(cin_dat != null && cin_dat.length <= cin_dat_offset)
      throw new RuntimeException("array offset argument \"cin_dat_offset\" (" + cin_dat_offset + ") equals or exceeds array length (" + cin_dat.length + ")");
        return capeFunc1(usetv, p_dat, p_dat_byte_offset_array, tve_dat, tve_dat_byte_offset_array, p0, BufferFactory.SIZEOF_FLOAT * p0_offset, th0, BufferFactory.SIZEOF_FLOAT * th0_offset, sh0, BufferFactory.SIZEOF_FLOAT * sh0_offset, mnx, nx, ny, nz, cape_dat, BufferFactory.SIZEOF_FLOAT * cape_dat_offset, cin_dat, BufferFactory.SIZEOF_FLOAT * cin_dat_offset);

  }

  /** Interface to C language function: <br> <code> void cclpar(float *  MIX, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PCCL, float *  TCCL, float *  HCCL); </code>    */
  public static void cclpar(java.nio.FloatBuffer MIX, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer T, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer PCCL, java.nio.FloatBuffer TCCL, java.nio.FloatBuffer HCCL)
  {
    boolean _direct = BufferFactory.isDirect(MIX);
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (PCCL != null && _direct != BufferFactory.isDirect(PCCL))
      throw new RuntimeException("Argument \"PCCL\" : Buffers passed to this method must all be either direct or indirect");
    if (TCCL != null && _direct != BufferFactory.isDirect(TCCL))
      throw new RuntimeException("Argument \"TCCL\" : Buffers passed to this method must all be either direct or indirect");
    if (HCCL != null && _direct != BufferFactory.isDirect(HCCL))
      throw new RuntimeException("Argument \"HCCL\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        cclpar0(MIX, BufferFactory.getDirectBufferByteOffset(MIX), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), T, BufferFactory.getDirectBufferByteOffset(T), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), PCCL, BufferFactory.getDirectBufferByteOffset(PCCL), TCCL, BufferFactory.getDirectBufferByteOffset(TCCL), HCCL, BufferFactory.getDirectBufferByteOffset(HCCL));
    } else {
      cclpar1(BufferFactory.getArray(MIX), BufferFactory.getIndirectBufferByteOffset(MIX), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(PCCL), BufferFactory.getIndirectBufferByteOffset(PCCL), BufferFactory.getArray(TCCL), BufferFactory.getIndirectBufferByteOffset(TCCL), BufferFactory.getArray(HCCL), BufferFactory.getIndirectBufferByteOffset(HCCL));
    }
  }

  /** Entry point to C language function: <br> <code> void cclpar(float *  MIX, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PCCL, float *  TCCL, float *  HCCL); </code>    */
  private static native void cclpar0(Object MIX, int MIX_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PCCL, int PCCL_byte_offset, Object TCCL, int TCCL_byte_offset, Object HCCL, int HCCL_byte_offset);

  /** Entry point to C language function: <br> <code> void cclpar(float *  MIX, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PCCL, float *  TCCL, float *  HCCL); </code>    */
  private static native void cclpar1(Object MIX, int MIX_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PCCL, int PCCL_byte_offset, Object TCCL, int TCCL_byte_offset, Object HCCL, int HCCL_byte_offset);

  /** Interface to C language function: <br> <code> void cclpar(float *  MIX, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PCCL, float *  TCCL, float *  HCCL); </code>    */
  public static void cclpar(float[] MIX, int MIX_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] T, int T_offset, int[] NLVLS, int NLVLS_offset, float[] PCCL, int PCCL_offset, float[] TCCL, int TCCL_offset, float[] HCCL, int HCCL_offset)
  {
    if(MIX != null && MIX.length <= MIX_offset)
      throw new RuntimeException("array offset argument \"MIX_offset\" (" + MIX_offset + ") equals or exceeds array length (" + MIX.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(PCCL != null && PCCL.length <= PCCL_offset)
      throw new RuntimeException("array offset argument \"PCCL_offset\" (" + PCCL_offset + ") equals or exceeds array length (" + PCCL.length + ")");
    if(TCCL != null && TCCL.length <= TCCL_offset)
      throw new RuntimeException("array offset argument \"TCCL_offset\" (" + TCCL_offset + ") equals or exceeds array length (" + TCCL.length + ")");
    if(HCCL != null && HCCL.length <= HCCL_offset)
      throw new RuntimeException("array offset argument \"HCCL_offset\" (" + HCCL_offset + ") equals or exceeds array length (" + HCCL.length + ")");
        cclpar1(MIX, BufferFactory.SIZEOF_FLOAT * MIX_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, PCCL, BufferFactory.SIZEOF_FLOAT * PCCL_offset, TCCL, BufferFactory.SIZEOF_FLOAT * TCCL_offset, HCCL, BufferFactory.SIZEOF_FLOAT * HCCL_offset);

  }

  /** Interface to C language function: <br> <code> int cgp(float *  tempip, float *  dwptip, float *  presip, float *  thetawip, float *  sfcpres, float *  toppres, int *  iw, float *  deltap); </code>    */
  public static int cgp(java.nio.FloatBuffer tempip, java.nio.FloatBuffer dwptip, java.nio.FloatBuffer presip, java.nio.FloatBuffer thetawip, java.nio.FloatBuffer sfcpres, java.nio.FloatBuffer toppres, java.nio.IntBuffer iw, java.nio.FloatBuffer deltap)
  {
    boolean _direct = BufferFactory.isDirect(tempip);
    if (dwptip != null && _direct != BufferFactory.isDirect(dwptip))
      throw new RuntimeException("Argument \"dwptip\" : Buffers passed to this method must all be either direct or indirect");
    if (presip != null && _direct != BufferFactory.isDirect(presip))
      throw new RuntimeException("Argument \"presip\" : Buffers passed to this method must all be either direct or indirect");
    if (thetawip != null && _direct != BufferFactory.isDirect(thetawip))
      throw new RuntimeException("Argument \"thetawip\" : Buffers passed to this method must all be either direct or indirect");
    if (sfcpres != null && _direct != BufferFactory.isDirect(sfcpres))
      throw new RuntimeException("Argument \"sfcpres\" : Buffers passed to this method must all be either direct or indirect");
    if (toppres != null && _direct != BufferFactory.isDirect(toppres))
      throw new RuntimeException("Argument \"toppres\" : Buffers passed to this method must all be either direct or indirect");
    if (iw != null && _direct != BufferFactory.isDirect(iw))
      throw new RuntimeException("Argument \"iw\" : Buffers passed to this method must all be either direct or indirect");
    if (deltap != null && _direct != BufferFactory.isDirect(deltap))
      throw new RuntimeException("Argument \"deltap\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return cgp0(tempip, BufferFactory.getDirectBufferByteOffset(tempip), dwptip, BufferFactory.getDirectBufferByteOffset(dwptip), presip, BufferFactory.getDirectBufferByteOffset(presip), thetawip, BufferFactory.getDirectBufferByteOffset(thetawip), sfcpres, BufferFactory.getDirectBufferByteOffset(sfcpres), toppres, BufferFactory.getDirectBufferByteOffset(toppres), iw, BufferFactory.getDirectBufferByteOffset(iw), deltap, BufferFactory.getDirectBufferByteOffset(deltap));
    } else {
      return cgp1(BufferFactory.getArray(tempip), BufferFactory.getIndirectBufferByteOffset(tempip), BufferFactory.getArray(dwptip), BufferFactory.getIndirectBufferByteOffset(dwptip), BufferFactory.getArray(presip), BufferFactory.getIndirectBufferByteOffset(presip), BufferFactory.getArray(thetawip), BufferFactory.getIndirectBufferByteOffset(thetawip), BufferFactory.getArray(sfcpres), BufferFactory.getIndirectBufferByteOffset(sfcpres), BufferFactory.getArray(toppres), BufferFactory.getIndirectBufferByteOffset(toppres), BufferFactory.getArray(iw), BufferFactory.getIndirectBufferByteOffset(iw), BufferFactory.getArray(deltap), BufferFactory.getIndirectBufferByteOffset(deltap));
    }
  }

  /** Entry point to C language function: <br> <code> int cgp(float *  tempip, float *  dwptip, float *  presip, float *  thetawip, float *  sfcpres, float *  toppres, int *  iw, float *  deltap); </code>    */
  private static native int cgp0(Object tempip, int tempip_byte_offset, Object dwptip, int dwptip_byte_offset, Object presip, int presip_byte_offset, Object thetawip, int thetawip_byte_offset, Object sfcpres, int sfcpres_byte_offset, Object toppres, int toppres_byte_offset, Object iw, int iw_byte_offset, Object deltap, int deltap_byte_offset);

  /** Entry point to C language function: <br> <code> int cgp(float *  tempip, float *  dwptip, float *  presip, float *  thetawip, float *  sfcpres, float *  toppres, int *  iw, float *  deltap); </code>    */
  private static native int cgp1(Object tempip, int tempip_byte_offset, Object dwptip, int dwptip_byte_offset, Object presip, int presip_byte_offset, Object thetawip, int thetawip_byte_offset, Object sfcpres, int sfcpres_byte_offset, Object toppres, int toppres_byte_offset, Object iw, int iw_byte_offset, Object deltap, int deltap_byte_offset);

  /** Interface to C language function: <br> <code> int cgp(float *  tempip, float *  dwptip, float *  presip, float *  thetawip, float *  sfcpres, float *  toppres, int *  iw, float *  deltap); </code>    */
  public static int cgp(float[] tempip, int tempip_offset, float[] dwptip, int dwptip_offset, float[] presip, int presip_offset, float[] thetawip, int thetawip_offset, float[] sfcpres, int sfcpres_offset, float[] toppres, int toppres_offset, int[] iw, int iw_offset, float[] deltap, int deltap_offset)
  {
    if(tempip != null && tempip.length <= tempip_offset)
      throw new RuntimeException("array offset argument \"tempip_offset\" (" + tempip_offset + ") equals or exceeds array length (" + tempip.length + ")");
    if(dwptip != null && dwptip.length <= dwptip_offset)
      throw new RuntimeException("array offset argument \"dwptip_offset\" (" + dwptip_offset + ") equals or exceeds array length (" + dwptip.length + ")");
    if(presip != null && presip.length <= presip_offset)
      throw new RuntimeException("array offset argument \"presip_offset\" (" + presip_offset + ") equals or exceeds array length (" + presip.length + ")");
    if(thetawip != null && thetawip.length <= thetawip_offset)
      throw new RuntimeException("array offset argument \"thetawip_offset\" (" + thetawip_offset + ") equals or exceeds array length (" + thetawip.length + ")");
    if(sfcpres != null && sfcpres.length <= sfcpres_offset)
      throw new RuntimeException("array offset argument \"sfcpres_offset\" (" + sfcpres_offset + ") equals or exceeds array length (" + sfcpres.length + ")");
    if(toppres != null && toppres.length <= toppres_offset)
      throw new RuntimeException("array offset argument \"toppres_offset\" (" + toppres_offset + ") equals or exceeds array length (" + toppres.length + ")");
    if(iw != null && iw.length <= iw_offset)
      throw new RuntimeException("array offset argument \"iw_offset\" (" + iw_offset + ") equals or exceeds array length (" + iw.length + ")");
    if(deltap != null && deltap.length <= deltap_offset)
      throw new RuntimeException("array offset argument \"deltap_offset\" (" + deltap_offset + ") equals or exceeds array length (" + deltap.length + ")");
        return cgp1(tempip, BufferFactory.SIZEOF_FLOAT * tempip_offset, dwptip, BufferFactory.SIZEOF_FLOAT * dwptip_offset, presip, BufferFactory.SIZEOF_FLOAT * presip_offset, thetawip, BufferFactory.SIZEOF_FLOAT * thetawip_offset, sfcpres, BufferFactory.SIZEOF_FLOAT * sfcpres_offset, toppres, BufferFactory.SIZEOF_FLOAT * toppres_offset, iw, BufferFactory.SIZEOF_INT * iw_offset, deltap, BufferFactory.SIZEOF_FLOAT * deltap_offset);

  }

  /** Interface to C language function: <br> <code> void comp_by(float *  u, float *  v, float *  uu, float *  vv, int *  mni, int *  ni, int *  nj, float *  control, float *  comp, float *  comp2); </code>    */
  public static void comp_by(java.nio.FloatBuffer u, java.nio.FloatBuffer v, java.nio.FloatBuffer uu, java.nio.FloatBuffer vv, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer control, java.nio.FloatBuffer comp, java.nio.FloatBuffer comp2)
  {
    boolean _direct = BufferFactory.isDirect(u);
    if (v != null && _direct != BufferFactory.isDirect(v))
      throw new RuntimeException("Argument \"v\" : Buffers passed to this method must all be either direct or indirect");
    if (uu != null && _direct != BufferFactory.isDirect(uu))
      throw new RuntimeException("Argument \"uu\" : Buffers passed to this method must all be either direct or indirect");
    if (vv != null && _direct != BufferFactory.isDirect(vv))
      throw new RuntimeException("Argument \"vv\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (control != null && _direct != BufferFactory.isDirect(control))
      throw new RuntimeException("Argument \"control\" : Buffers passed to this method must all be either direct or indirect");
    if (comp != null && _direct != BufferFactory.isDirect(comp))
      throw new RuntimeException("Argument \"comp\" : Buffers passed to this method must all be either direct or indirect");
    if (comp2 != null && _direct != BufferFactory.isDirect(comp2))
      throw new RuntimeException("Argument \"comp2\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        comp_by0(u, BufferFactory.getDirectBufferByteOffset(u), v, BufferFactory.getDirectBufferByteOffset(v), uu, BufferFactory.getDirectBufferByteOffset(uu), vv, BufferFactory.getDirectBufferByteOffset(vv), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), control, BufferFactory.getDirectBufferByteOffset(control), comp, BufferFactory.getDirectBufferByteOffset(comp), comp2, BufferFactory.getDirectBufferByteOffset(comp2));
    } else {
      comp_by1(BufferFactory.getArray(u), BufferFactory.getIndirectBufferByteOffset(u), BufferFactory.getArray(v), BufferFactory.getIndirectBufferByteOffset(v), BufferFactory.getArray(uu), BufferFactory.getIndirectBufferByteOffset(uu), BufferFactory.getArray(vv), BufferFactory.getIndirectBufferByteOffset(vv), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(control), BufferFactory.getIndirectBufferByteOffset(control), BufferFactory.getArray(comp), BufferFactory.getIndirectBufferByteOffset(comp), BufferFactory.getArray(comp2), BufferFactory.getIndirectBufferByteOffset(comp2));
    }
  }

  /** Entry point to C language function: <br> <code> void comp_by(float *  u, float *  v, float *  uu, float *  vv, int *  mni, int *  ni, int *  nj, float *  control, float *  comp, float *  comp2); </code>    */
  private static native void comp_by0(Object u, int u_byte_offset, Object v, int v_byte_offset, Object uu, int uu_byte_offset, Object vv, int vv_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object control, int control_byte_offset, Object comp, int comp_byte_offset, Object comp2, int comp2_byte_offset);

  /** Entry point to C language function: <br> <code> void comp_by(float *  u, float *  v, float *  uu, float *  vv, int *  mni, int *  ni, int *  nj, float *  control, float *  comp, float *  comp2); </code>    */
  private static native void comp_by1(Object u, int u_byte_offset, Object v, int v_byte_offset, Object uu, int uu_byte_offset, Object vv, int vv_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object control, int control_byte_offset, Object comp, int comp_byte_offset, Object comp2, int comp2_byte_offset);

  /** Interface to C language function: <br> <code> void comp_by(float *  u, float *  v, float *  uu, float *  vv, int *  mni, int *  ni, int *  nj, float *  control, float *  comp, float *  comp2); </code>    */
  public static void comp_by(float[] u, int u_offset, float[] v, int v_offset, float[] uu, int uu_offset, float[] vv, int vv_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] control, int control_offset, float[] comp, int comp_offset, float[] comp2, int comp2_offset)
  {
    if(u != null && u.length <= u_offset)
      throw new RuntimeException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    if(uu != null && uu.length <= uu_offset)
      throw new RuntimeException("array offset argument \"uu_offset\" (" + uu_offset + ") equals or exceeds array length (" + uu.length + ")");
    if(vv != null && vv.length <= vv_offset)
      throw new RuntimeException("array offset argument \"vv_offset\" (" + vv_offset + ") equals or exceeds array length (" + vv.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(control != null && control.length <= control_offset)
      throw new RuntimeException("array offset argument \"control_offset\" (" + control_offset + ") equals or exceeds array length (" + control.length + ")");
    if(comp != null && comp.length <= comp_offset)
      throw new RuntimeException("array offset argument \"comp_offset\" (" + comp_offset + ") equals or exceeds array length (" + comp.length + ")");
    if(comp2 != null && comp2.length <= comp2_offset)
      throw new RuntimeException("array offset argument \"comp2_offset\" (" + comp2_offset + ") equals or exceeds array length (" + comp2.length + ")");
        comp_by1(u, BufferFactory.SIZEOF_FLOAT * u_offset, v, BufferFactory.SIZEOF_FLOAT * v_offset, uu, BufferFactory.SIZEOF_FLOAT * uu_offset, vv, BufferFactory.SIZEOF_FLOAT * vv_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, control, BufferFactory.SIZEOF_FLOAT * control_offset, comp, BufferFactory.SIZEOF_FLOAT * comp_offset, comp2, BufferFactory.SIZEOF_FLOAT * comp2_offset);

  }

  /** Interface to C language function: <br> <code> void createSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, float *  slice); </code>    */
  public static void createSlice(java.nio.FloatBuffer[] vc3d, java.nio.FloatBuffer vc2d, java.nio.FloatBuffer[] slice3d, int mnx, int nx, int ny, int nz, int sense, java.nio.FloatBuffer slice)
  {
    int[] vc3d_byte_offset_array = new int[vc3d.length];
    if (vc3d != null) {
      for (int _ctr = 0; _ctr < vc3d.length; _ctr++) {
        if (!BufferFactory.isDirect(vc3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"vc3d\" was not a direct buffer");
        }
        vc3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(vc3d[_ctr]);
      }
    }
    boolean _direct = BufferFactory.isDirect(vc2d);
    int[] slice3d_byte_offset_array = new int[slice3d.length];
    if (slice3d != null) {
      for (int _ctr = 0; _ctr < slice3d.length; _ctr++) {
        if (!BufferFactory.isDirect(slice3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"slice3d\" was not a direct buffer");
        }
        slice3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(slice3d[_ctr]);
      }
    }
    if (slice != null && _direct != BufferFactory.isDirect(slice))
      throw new RuntimeException("Argument \"slice\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        createSlice0(vc3d, vc3d_byte_offset_array, vc2d, BufferFactory.getDirectBufferByteOffset(vc2d), slice3d, slice3d_byte_offset_array, mnx, nx, ny, nz, sense, slice, BufferFactory.getDirectBufferByteOffset(slice));
    } else {
      createSlice1(vc3d, vc3d_byte_offset_array, BufferFactory.getArray(vc2d), BufferFactory.getIndirectBufferByteOffset(vc2d), slice3d, slice3d_byte_offset_array, mnx, nx, ny, nz, sense, BufferFactory.getArray(slice), BufferFactory.getIndirectBufferByteOffset(slice));
    }
  }

  /** Entry point to C language function: <br> <code> void createSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, float *  slice); </code>    */
  private static native void createSlice0(Object[] vc3d, int[] vc3d_byte_offset_array, Object vc2d, int vc2d_byte_offset, Object[] slice3d, int[] slice3d_byte_offset_array, int mnx, int nx, int ny, int nz, int sense, Object slice, int slice_byte_offset);

  /** Entry point to C language function: <br> <code> void createSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, float *  slice); </code>    */
  private static native void createSlice1(Object[] vc3d, int[] vc3d_byte_offset_array, Object vc2d, int vc2d_byte_offset, Object[] slice3d, int[] slice3d_byte_offset_array, int mnx, int nx, int ny, int nz, int sense, Object slice, int slice_byte_offset);

  /** Interface to C language function: <br> <code> void createSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, float *  slice); </code>    */
  public static void createSlice(java.nio.FloatBuffer[] vc3d, float[] vc2d, int vc2d_offset, java.nio.FloatBuffer[] slice3d, int mnx, int nx, int ny, int nz, int sense, float[] slice, int slice_offset)
  {
    int[] vc3d_byte_offset_array = new int[vc3d.length];
    if (vc3d != null) {
      for (int _ctr = 0; _ctr < vc3d.length; _ctr++) {
        if (!BufferFactory.isDirect(vc3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"vc3d\" was not a direct buffer");
        }
        vc3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(vc3d[_ctr]);
      }
    }
    if(vc2d != null && vc2d.length <= vc2d_offset)
      throw new RuntimeException("array offset argument \"vc2d_offset\" (" + vc2d_offset + ") equals or exceeds array length (" + vc2d.length + ")");
    int[] slice3d_byte_offset_array = new int[slice3d.length];
    if (slice3d != null) {
      for (int _ctr = 0; _ctr < slice3d.length; _ctr++) {
        if (!BufferFactory.isDirect(slice3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"slice3d\" was not a direct buffer");
        }
        slice3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(slice3d[_ctr]);
      }
    }
    if(slice != null && slice.length <= slice_offset)
      throw new RuntimeException("array offset argument \"slice_offset\" (" + slice_offset + ") equals or exceeds array length (" + slice.length + ")");
        createSlice1(vc3d, vc3d_byte_offset_array, vc2d, BufferFactory.SIZEOF_FLOAT * vc2d_offset, slice3d, slice3d_byte_offset_array, mnx, nx, ny, nz, sense, slice, BufferFactory.SIZEOF_FLOAT * slice_offset);

  }

  /** Interface to C language function: <br> <code> void createSlices(float *  vc3d, float *  param3d, int sense, int nx, int ny, int nz, float *  vcC, int nc, float *  paramC); </code>    */
  public static void createSlices(java.nio.FloatBuffer vc3d, java.nio.FloatBuffer param3d, int sense, int nx, int ny, int nz, java.nio.FloatBuffer vcC, int nc, java.nio.FloatBuffer paramC)
  {
    boolean _direct = BufferFactory.isDirect(vc3d);
    if (param3d != null && _direct != BufferFactory.isDirect(param3d))
      throw new RuntimeException("Argument \"param3d\" : Buffers passed to this method must all be either direct or indirect");
    if (vcC != null && _direct != BufferFactory.isDirect(vcC))
      throw new RuntimeException("Argument \"vcC\" : Buffers passed to this method must all be either direct or indirect");
    if (paramC != null && _direct != BufferFactory.isDirect(paramC))
      throw new RuntimeException("Argument \"paramC\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        createSlices0(vc3d, BufferFactory.getDirectBufferByteOffset(vc3d), param3d, BufferFactory.getDirectBufferByteOffset(param3d), sense, nx, ny, nz, vcC, BufferFactory.getDirectBufferByteOffset(vcC), nc, paramC, BufferFactory.getDirectBufferByteOffset(paramC));
    } else {
      createSlices1(BufferFactory.getArray(vc3d), BufferFactory.getIndirectBufferByteOffset(vc3d), BufferFactory.getArray(param3d), BufferFactory.getIndirectBufferByteOffset(param3d), sense, nx, ny, nz, BufferFactory.getArray(vcC), BufferFactory.getIndirectBufferByteOffset(vcC), nc, BufferFactory.getArray(paramC), BufferFactory.getIndirectBufferByteOffset(paramC));
    }
  }

  /** Entry point to C language function: <br> <code> void createSlices(float *  vc3d, float *  param3d, int sense, int nx, int ny, int nz, float *  vcC, int nc, float *  paramC); </code>    */
  private static native void createSlices0(Object vc3d, int vc3d_byte_offset, Object param3d, int param3d_byte_offset, int sense, int nx, int ny, int nz, Object vcC, int vcC_byte_offset, int nc, Object paramC, int paramC_byte_offset);

  /** Entry point to C language function: <br> <code> void createSlices(float *  vc3d, float *  param3d, int sense, int nx, int ny, int nz, float *  vcC, int nc, float *  paramC); </code>    */
  private static native void createSlices1(Object vc3d, int vc3d_byte_offset, Object param3d, int param3d_byte_offset, int sense, int nx, int ny, int nz, Object vcC, int vcC_byte_offset, int nc, Object paramC, int paramC_byte_offset);

  /** Interface to C language function: <br> <code> void createSlices(float *  vc3d, float *  param3d, int sense, int nx, int ny, int nz, float *  vcC, int nc, float *  paramC); </code>    */
  public static void createSlices(float[] vc3d, int vc3d_offset, float[] param3d, int param3d_offset, int sense, int nx, int ny, int nz, float[] vcC, int vcC_offset, int nc, float[] paramC, int paramC_offset)
  {
    if(vc3d != null && vc3d.length <= vc3d_offset)
      throw new RuntimeException("array offset argument \"vc3d_offset\" (" + vc3d_offset + ") equals or exceeds array length (" + vc3d.length + ")");
    if(param3d != null && param3d.length <= param3d_offset)
      throw new RuntimeException("array offset argument \"param3d_offset\" (" + param3d_offset + ") equals or exceeds array length (" + param3d.length + ")");
    if(vcC != null && vcC.length <= vcC_offset)
      throw new RuntimeException("array offset argument \"vcC_offset\" (" + vcC_offset + ") equals or exceeds array length (" + vcC.length + ")");
    if(paramC != null && paramC.length <= paramC_offset)
      throw new RuntimeException("array offset argument \"paramC_offset\" (" + paramC_offset + ") equals or exceeds array length (" + paramC.length + ")");
        createSlices1(vc3d, BufferFactory.SIZEOF_FLOAT * vc3d_offset, param3d, BufferFactory.SIZEOF_FLOAT * param3d_offset, sense, nx, ny, nz, vcC, BufferFactory.SIZEOF_FLOAT * vcC_offset, nc, paramC, BufferFactory.SIZEOF_FLOAT * paramC_offset);

  }

  /** Interface to C language function: <br> <code> void crossvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void crossvectors(java.nio.FloatBuffer aX, java.nio.FloatBuffer aY, java.nio.FloatBuffer bX, java.nio.FloatBuffer bY, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(aX);
    if (aY != null && _direct != BufferFactory.isDirect(aY))
      throw new RuntimeException("Argument \"aY\" : Buffers passed to this method must all be either direct or indirect");
    if (bX != null && _direct != BufferFactory.isDirect(bX))
      throw new RuntimeException("Argument \"bX\" : Buffers passed to this method must all be either direct or indirect");
    if (bY != null && _direct != BufferFactory.isDirect(bY))
      throw new RuntimeException("Argument \"bY\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        crossvectors0(aX, BufferFactory.getDirectBufferByteOffset(aX), aY, BufferFactory.getDirectBufferByteOffset(aY), bX, BufferFactory.getDirectBufferByteOffset(bX), bY, BufferFactory.getDirectBufferByteOffset(bY), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      crossvectors1(BufferFactory.getArray(aX), BufferFactory.getIndirectBufferByteOffset(aX), BufferFactory.getArray(aY), BufferFactory.getIndirectBufferByteOffset(aY), BufferFactory.getArray(bX), BufferFactory.getIndirectBufferByteOffset(bX), BufferFactory.getArray(bY), BufferFactory.getIndirectBufferByteOffset(bY), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void crossvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void crossvectors0(Object aX, int aX_byte_offset, Object aY, int aY_byte_offset, Object bX, int bX_byte_offset, Object bY, int bY_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void crossvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void crossvectors1(Object aX, int aX_byte_offset, Object aY, int aY_byte_offset, Object bX, int bX_byte_offset, Object bY, int bY_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void crossvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void crossvectors(float[] aX, int aX_offset, float[] aY, int aY_offset, float[] bX, int bX_offset, float[] bY, int bY_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(aX != null && aX.length <= aX_offset)
      throw new RuntimeException("array offset argument \"aX_offset\" (" + aX_offset + ") equals or exceeds array length (" + aX.length + ")");
    if(aY != null && aY.length <= aY_offset)
      throw new RuntimeException("array offset argument \"aY_offset\" (" + aY_offset + ") equals or exceeds array length (" + aY.length + ")");
    if(bX != null && bX.length <= bX_offset)
      throw new RuntimeException("array offset argument \"bX_offset\" (" + bX_offset + ") equals or exceeds array length (" + bX.length + ")");
    if(bY != null && bY.length <= bY_offset)
      throw new RuntimeException("array offset argument \"bY_offset\" (" + bY_offset + ") equals or exceeds array length (" + bY.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        crossvectors1(aX, BufferFactory.SIZEOF_FLOAT * aX_offset, aY, BufferFactory.SIZEOF_FLOAT * aY_offset, bX, BufferFactory.SIZEOF_FLOAT * bX_offset, bY, BufferFactory.SIZEOF_FLOAT * bY_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void ctop(float *  P, float *  HT, float *  VV, float *  PEQLEV, int *  NPAR, float *  CLDTOP); </code>    */
  public static void ctop(java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer VV, java.nio.FloatBuffer PEQLEV, java.nio.IntBuffer NPAR, java.nio.FloatBuffer CLDTOP)
  {
    boolean _direct = BufferFactory.isDirect(P);
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (VV != null && _direct != BufferFactory.isDirect(VV))
      throw new RuntimeException("Argument \"VV\" : Buffers passed to this method must all be either direct or indirect");
    if (PEQLEV != null && _direct != BufferFactory.isDirect(PEQLEV))
      throw new RuntimeException("Argument \"PEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (CLDTOP != null && _direct != BufferFactory.isDirect(CLDTOP))
      throw new RuntimeException("Argument \"CLDTOP\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        ctop0(P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), VV, BufferFactory.getDirectBufferByteOffset(VV), PEQLEV, BufferFactory.getDirectBufferByteOffset(PEQLEV), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), CLDTOP, BufferFactory.getDirectBufferByteOffset(CLDTOP));
    } else {
      ctop1(BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(VV), BufferFactory.getIndirectBufferByteOffset(VV), BufferFactory.getArray(PEQLEV), BufferFactory.getIndirectBufferByteOffset(PEQLEV), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(CLDTOP), BufferFactory.getIndirectBufferByteOffset(CLDTOP));
    }
  }

  /** Entry point to C language function: <br> <code> void ctop(float *  P, float *  HT, float *  VV, float *  PEQLEV, int *  NPAR, float *  CLDTOP); </code>    */
  private static native void ctop0(Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object VV, int VV_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object NPAR, int NPAR_byte_offset, Object CLDTOP, int CLDTOP_byte_offset);

  /** Entry point to C language function: <br> <code> void ctop(float *  P, float *  HT, float *  VV, float *  PEQLEV, int *  NPAR, float *  CLDTOP); </code>    */
  private static native void ctop1(Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object VV, int VV_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object NPAR, int NPAR_byte_offset, Object CLDTOP, int CLDTOP_byte_offset);

  /** Interface to C language function: <br> <code> void ctop(float *  P, float *  HT, float *  VV, float *  PEQLEV, int *  NPAR, float *  CLDTOP); </code>    */
  public static void ctop(float[] P, int P_offset, float[] HT, int HT_offset, float[] VV, int VV_offset, float[] PEQLEV, int PEQLEV_offset, int[] NPAR, int NPAR_offset, float[] CLDTOP, int CLDTOP_offset)
  {
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(VV != null && VV.length <= VV_offset)
      throw new RuntimeException("array offset argument \"VV_offset\" (" + VV_offset + ") equals or exceeds array length (" + VV.length + ")");
    if(PEQLEV != null && PEQLEV.length <= PEQLEV_offset)
      throw new RuntimeException("array offset argument \"PEQLEV_offset\" (" + PEQLEV_offset + ") equals or exceeds array length (" + PEQLEV.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(CLDTOP != null && CLDTOP.length <= CLDTOP_offset)
      throw new RuntimeException("array offset argument \"CLDTOP_offset\" (" + CLDTOP_offset + ") equals or exceeds array length (" + CLDTOP.length + ")");
        ctop1(P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, VV, BufferFactory.SIZEOF_FLOAT * VV_offset, PEQLEV, BufferFactory.SIZEOF_FLOAT * PEQLEV_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, CLDTOP, BufferFactory.SIZEOF_FLOAT * CLDTOP_offset);

  }

  /** Interface to C language function: <br> <code> void cv_date2jul(int *  YR, int *  MON, int *  DAY, int *  JD, int *  ISTATUS); </code>    */
  public static void cv_date2jul(java.nio.IntBuffer YR, java.nio.IntBuffer MON, java.nio.IntBuffer DAY, java.nio.IntBuffer JD, java.nio.IntBuffer ISTATUS)
  {
    boolean _direct = BufferFactory.isDirect(YR);
    if (MON != null && _direct != BufferFactory.isDirect(MON))
      throw new RuntimeException("Argument \"MON\" : Buffers passed to this method must all be either direct or indirect");
    if (DAY != null && _direct != BufferFactory.isDirect(DAY))
      throw new RuntimeException("Argument \"DAY\" : Buffers passed to this method must all be either direct or indirect");
    if (JD != null && _direct != BufferFactory.isDirect(JD))
      throw new RuntimeException("Argument \"JD\" : Buffers passed to this method must all be either direct or indirect");
    if (ISTATUS != null && _direct != BufferFactory.isDirect(ISTATUS))
      throw new RuntimeException("Argument \"ISTATUS\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        cv_date2jul0(YR, BufferFactory.getDirectBufferByteOffset(YR), MON, BufferFactory.getDirectBufferByteOffset(MON), DAY, BufferFactory.getDirectBufferByteOffset(DAY), JD, BufferFactory.getDirectBufferByteOffset(JD), ISTATUS, BufferFactory.getDirectBufferByteOffset(ISTATUS));
    } else {
      cv_date2jul1(BufferFactory.getArray(YR), BufferFactory.getIndirectBufferByteOffset(YR), BufferFactory.getArray(MON), BufferFactory.getIndirectBufferByteOffset(MON), BufferFactory.getArray(DAY), BufferFactory.getIndirectBufferByteOffset(DAY), BufferFactory.getArray(JD), BufferFactory.getIndirectBufferByteOffset(JD), BufferFactory.getArray(ISTATUS), BufferFactory.getIndirectBufferByteOffset(ISTATUS));
    }
  }

  /** Entry point to C language function: <br> <code> void cv_date2jul(int *  YR, int *  MON, int *  DAY, int *  JD, int *  ISTATUS); </code>    */
  private static native void cv_date2jul0(Object YR, int YR_byte_offset, Object MON, int MON_byte_offset, Object DAY, int DAY_byte_offset, Object JD, int JD_byte_offset, Object ISTATUS, int ISTATUS_byte_offset);

  /** Entry point to C language function: <br> <code> void cv_date2jul(int *  YR, int *  MON, int *  DAY, int *  JD, int *  ISTATUS); </code>    */
  private static native void cv_date2jul1(Object YR, int YR_byte_offset, Object MON, int MON_byte_offset, Object DAY, int DAY_byte_offset, Object JD, int JD_byte_offset, Object ISTATUS, int ISTATUS_byte_offset);

  /** Interface to C language function: <br> <code> void cv_date2jul(int *  YR, int *  MON, int *  DAY, int *  JD, int *  ISTATUS); </code>    */
  public static void cv_date2jul(int[] YR, int YR_offset, int[] MON, int MON_offset, int[] DAY, int DAY_offset, int[] JD, int JD_offset, int[] ISTATUS, int ISTATUS_offset)
  {
    if(YR != null && YR.length <= YR_offset)
      throw new RuntimeException("array offset argument \"YR_offset\" (" + YR_offset + ") equals or exceeds array length (" + YR.length + ")");
    if(MON != null && MON.length <= MON_offset)
      throw new RuntimeException("array offset argument \"MON_offset\" (" + MON_offset + ") equals or exceeds array length (" + MON.length + ")");
    if(DAY != null && DAY.length <= DAY_offset)
      throw new RuntimeException("array offset argument \"DAY_offset\" (" + DAY_offset + ") equals or exceeds array length (" + DAY.length + ")");
    if(JD != null && JD.length <= JD_offset)
      throw new RuntimeException("array offset argument \"JD_offset\" (" + JD_offset + ") equals or exceeds array length (" + JD.length + ")");
    if(ISTATUS != null && ISTATUS.length <= ISTATUS_offset)
      throw new RuntimeException("array offset argument \"ISTATUS_offset\" (" + ISTATUS_offset + ") equals or exceeds array length (" + ISTATUS.length + ")");
        cv_date2jul1(YR, BufferFactory.SIZEOF_INT * YR_offset, MON, BufferFactory.SIZEOF_INT * MON_offset, DAY, BufferFactory.SIZEOF_INT * DAY_offset, JD, BufferFactory.SIZEOF_INT * JD_offset, ISTATUS, BufferFactory.SIZEOF_INT * ISTATUS_offset);

  }

  /** Interface to C language function: <br> <code> void cvgust(float *  dd7, float *  ui, int *  gstpot); </code>    */
  public static void cvgust(java.nio.FloatBuffer dd7, java.nio.FloatBuffer ui, java.nio.IntBuffer gstpot)
  {
    boolean _direct = BufferFactory.isDirect(dd7);
    if (ui != null && _direct != BufferFactory.isDirect(ui))
      throw new RuntimeException("Argument \"ui\" : Buffers passed to this method must all be either direct or indirect");
    if (gstpot != null && _direct != BufferFactory.isDirect(gstpot))
      throw new RuntimeException("Argument \"gstpot\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        cvgust0(dd7, BufferFactory.getDirectBufferByteOffset(dd7), ui, BufferFactory.getDirectBufferByteOffset(ui), gstpot, BufferFactory.getDirectBufferByteOffset(gstpot));
    } else {
      cvgust1(BufferFactory.getArray(dd7), BufferFactory.getIndirectBufferByteOffset(dd7), BufferFactory.getArray(ui), BufferFactory.getIndirectBufferByteOffset(ui), BufferFactory.getArray(gstpot), BufferFactory.getIndirectBufferByteOffset(gstpot));
    }
  }

  /** Entry point to C language function: <br> <code> void cvgust(float *  dd7, float *  ui, int *  gstpot); </code>    */
  private static native void cvgust0(Object dd7, int dd7_byte_offset, Object ui, int ui_byte_offset, Object gstpot, int gstpot_byte_offset);

  /** Entry point to C language function: <br> <code> void cvgust(float *  dd7, float *  ui, int *  gstpot); </code>    */
  private static native void cvgust1(Object dd7, int dd7_byte_offset, Object ui, int ui_byte_offset, Object gstpot, int gstpot_byte_offset);

  /** Interface to C language function: <br> <code> void cvgust(float *  dd7, float *  ui, int *  gstpot); </code>    */
  public static void cvgust(float[] dd7, int dd7_offset, float[] ui, int ui_offset, int[] gstpot, int gstpot_offset)
  {
    if(dd7 != null && dd7.length <= dd7_offset)
      throw new RuntimeException("array offset argument \"dd7_offset\" (" + dd7_offset + ") equals or exceeds array length (" + dd7.length + ")");
    if(ui != null && ui.length <= ui_offset)
      throw new RuntimeException("array offset argument \"ui_offset\" (" + ui_offset + ") equals or exceeds array length (" + ui.length + ")");
    if(gstpot != null && gstpot.length <= gstpot_offset)
      throw new RuntimeException("array offset argument \"gstpot_offset\" (" + gstpot_offset + ") equals or exceeds array length (" + gstpot.length + ")");
        cvgust1(dd7, BufferFactory.SIZEOF_FLOAT * dd7_offset, ui, BufferFactory.SIZEOF_FLOAT * ui_offset, gstpot, BufferFactory.SIZEOF_INT * gstpot_offset);

  }

  /** Interface to C language function: <br> <code> void dcapeFunc(float usetv, const float *  *  p_dat, const float *  *  t_dat, const float *  *  td_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, float *  dcape_dat); </code>    */
  public static void dcapeFunc(float usetv, java.nio.FloatBuffer[] p_dat, java.nio.FloatBuffer[] t_dat, java.nio.FloatBuffer[] td_dat, java.nio.FloatBuffer p0, java.nio.FloatBuffer th0, java.nio.FloatBuffer sh0, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, java.nio.FloatBuffer dcape_dat)
  {
    int[] p_dat_byte_offset_array = new int[p_dat.length];
    if (p_dat != null) {
      for (int _ctr = 0; _ctr < p_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(p_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"p_dat\" was not a direct buffer");
        }
        p_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(p_dat[_ctr]);
      }
    }
    int[] t_dat_byte_offset_array = new int[t_dat.length];
    if (t_dat != null) {
      for (int _ctr = 0; _ctr < t_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(t_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"t_dat\" was not a direct buffer");
        }
        t_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(t_dat[_ctr]);
      }
    }
    int[] td_dat_byte_offset_array = new int[td_dat.length];
    if (td_dat != null) {
      for (int _ctr = 0; _ctr < td_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(td_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"td_dat\" was not a direct buffer");
        }
        td_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(td_dat[_ctr]);
      }
    }
    boolean _direct = BufferFactory.isDirect(p0);
    if (th0 != null && _direct != BufferFactory.isDirect(th0))
      throw new RuntimeException("Argument \"th0\" : Buffers passed to this method must all be either direct or indirect");
    if (sh0 != null && _direct != BufferFactory.isDirect(sh0))
      throw new RuntimeException("Argument \"sh0\" : Buffers passed to this method must all be either direct or indirect");
    if (dcape_dat != null && _direct != BufferFactory.isDirect(dcape_dat))
      throw new RuntimeException("Argument \"dcape_dat\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        dcapeFunc0(usetv, p_dat, p_dat_byte_offset_array, t_dat, t_dat_byte_offset_array, td_dat, td_dat_byte_offset_array, p0, BufferFactory.getDirectBufferByteOffset(p0), th0, BufferFactory.getDirectBufferByteOffset(th0), sh0, BufferFactory.getDirectBufferByteOffset(sh0), mnx, nx, ny, nz, max_evap, max_rh, dcape_dat, BufferFactory.getDirectBufferByteOffset(dcape_dat));
    } else {
      dcapeFunc1(usetv, p_dat, p_dat_byte_offset_array, t_dat, t_dat_byte_offset_array, td_dat, td_dat_byte_offset_array, BufferFactory.getArray(p0), BufferFactory.getIndirectBufferByteOffset(p0), BufferFactory.getArray(th0), BufferFactory.getIndirectBufferByteOffset(th0), BufferFactory.getArray(sh0), BufferFactory.getIndirectBufferByteOffset(sh0), mnx, nx, ny, nz, max_evap, max_rh, BufferFactory.getArray(dcape_dat), BufferFactory.getIndirectBufferByteOffset(dcape_dat));
    }
  }

  /** Entry point to C language function: <br> <code> void dcapeFunc(float usetv, const float *  *  p_dat, const float *  *  t_dat, const float *  *  td_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, float *  dcape_dat); </code>    */
  private static native void dcapeFunc0(float usetv, Object[] p_dat, int[] p_dat_byte_offset_array, Object[] t_dat, int[] t_dat_byte_offset_array, Object[] td_dat, int[] td_dat_byte_offset_array, Object p0, int p0_byte_offset, Object th0, int th0_byte_offset, Object sh0, int sh0_byte_offset, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, Object dcape_dat, int dcape_dat_byte_offset);

  /** Entry point to C language function: <br> <code> void dcapeFunc(float usetv, const float *  *  p_dat, const float *  *  t_dat, const float *  *  td_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, float *  dcape_dat); </code>    */
  private static native void dcapeFunc1(float usetv, Object[] p_dat, int[] p_dat_byte_offset_array, Object[] t_dat, int[] t_dat_byte_offset_array, Object[] td_dat, int[] td_dat_byte_offset_array, Object p0, int p0_byte_offset, Object th0, int th0_byte_offset, Object sh0, int sh0_byte_offset, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, Object dcape_dat, int dcape_dat_byte_offset);

  /** Interface to C language function: <br> <code> void dcapeFunc(float usetv, const float *  *  p_dat, const float *  *  t_dat, const float *  *  td_dat, float *  p0, float *  th0, float *  sh0, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, float *  dcape_dat); </code>    */
  public static void dcapeFunc(float usetv, java.nio.FloatBuffer[] p_dat, java.nio.FloatBuffer[] t_dat, java.nio.FloatBuffer[] td_dat, float[] p0, int p0_offset, float[] th0, int th0_offset, float[] sh0, int sh0_offset, int mnx, int nx, int ny, int nz, float max_evap, float max_rh, float[] dcape_dat, int dcape_dat_offset)
  {
    int[] p_dat_byte_offset_array = new int[p_dat.length];
    if (p_dat != null) {
      for (int _ctr = 0; _ctr < p_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(p_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"p_dat\" was not a direct buffer");
        }
        p_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(p_dat[_ctr]);
      }
    }
    int[] t_dat_byte_offset_array = new int[t_dat.length];
    if (t_dat != null) {
      for (int _ctr = 0; _ctr < t_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(t_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"t_dat\" was not a direct buffer");
        }
        t_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(t_dat[_ctr]);
      }
    }
    int[] td_dat_byte_offset_array = new int[td_dat.length];
    if (td_dat != null) {
      for (int _ctr = 0; _ctr < td_dat.length; _ctr++) {
        if (!BufferFactory.isDirect(td_dat[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"td_dat\" was not a direct buffer");
        }
        td_dat_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(td_dat[_ctr]);
      }
    }
    if(p0 != null && p0.length <= p0_offset)
      throw new RuntimeException("array offset argument \"p0_offset\" (" + p0_offset + ") equals or exceeds array length (" + p0.length + ")");
    if(th0 != null && th0.length <= th0_offset)
      throw new RuntimeException("array offset argument \"th0_offset\" (" + th0_offset + ") equals or exceeds array length (" + th0.length + ")");
    if(sh0 != null && sh0.length <= sh0_offset)
      throw new RuntimeException("array offset argument \"sh0_offset\" (" + sh0_offset + ") equals or exceeds array length (" + sh0.length + ")");
    if(dcape_dat != null && dcape_dat.length <= dcape_dat_offset)
      throw new RuntimeException("array offset argument \"dcape_dat_offset\" (" + dcape_dat_offset + ") equals or exceeds array length (" + dcape_dat.length + ")");
        dcapeFunc1(usetv, p_dat, p_dat_byte_offset_array, t_dat, t_dat_byte_offset_array, td_dat, td_dat_byte_offset_array, p0, BufferFactory.SIZEOF_FLOAT * p0_offset, th0, BufferFactory.SIZEOF_FLOAT * th0_offset, sh0, BufferFactory.SIZEOF_FLOAT * sh0_offset, mnx, nx, ny, nz, max_evap, max_rh, dcape_dat, BufferFactory.SIZEOF_FLOAT * dcape_dat_offset);

  }

  /** Interface to C language function: <br> <code> void ddff(float *  U, float *  V, float *  DIR, float *  SPD, int *  NLVLS); </code>    */
  public static void ddff(java.nio.FloatBuffer U, java.nio.FloatBuffer V, java.nio.FloatBuffer DIR, java.nio.FloatBuffer SPD, java.nio.IntBuffer NLVLS)
  {
    boolean _direct = BufferFactory.isDirect(U);
    if (V != null && _direct != BufferFactory.isDirect(V))
      throw new RuntimeException("Argument \"V\" : Buffers passed to this method must all be either direct or indirect");
    if (DIR != null && _direct != BufferFactory.isDirect(DIR))
      throw new RuntimeException("Argument \"DIR\" : Buffers passed to this method must all be either direct or indirect");
    if (SPD != null && _direct != BufferFactory.isDirect(SPD))
      throw new RuntimeException("Argument \"SPD\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        ddff0(U, BufferFactory.getDirectBufferByteOffset(U), V, BufferFactory.getDirectBufferByteOffset(V), DIR, BufferFactory.getDirectBufferByteOffset(DIR), SPD, BufferFactory.getDirectBufferByteOffset(SPD), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS));
    } else {
      ddff1(BufferFactory.getArray(U), BufferFactory.getIndirectBufferByteOffset(U), BufferFactory.getArray(V), BufferFactory.getIndirectBufferByteOffset(V), BufferFactory.getArray(DIR), BufferFactory.getIndirectBufferByteOffset(DIR), BufferFactory.getArray(SPD), BufferFactory.getIndirectBufferByteOffset(SPD), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS));
    }
  }

  /** Entry point to C language function: <br> <code> void ddff(float *  U, float *  V, float *  DIR, float *  SPD, int *  NLVLS); </code>    */
  private static native void ddff0(Object U, int U_byte_offset, Object V, int V_byte_offset, Object DIR, int DIR_byte_offset, Object SPD, int SPD_byte_offset, Object NLVLS, int NLVLS_byte_offset);

  /** Entry point to C language function: <br> <code> void ddff(float *  U, float *  V, float *  DIR, float *  SPD, int *  NLVLS); </code>    */
  private static native void ddff1(Object U, int U_byte_offset, Object V, int V_byte_offset, Object DIR, int DIR_byte_offset, Object SPD, int SPD_byte_offset, Object NLVLS, int NLVLS_byte_offset);

  /** Interface to C language function: <br> <code> void ddff(float *  U, float *  V, float *  DIR, float *  SPD, int *  NLVLS); </code>    */
  public static void ddff(float[] U, int U_offset, float[] V, int V_offset, float[] DIR, int DIR_offset, float[] SPD, int SPD_offset, int[] NLVLS, int NLVLS_offset)
  {
    if(U != null && U.length <= U_offset)
      throw new RuntimeException("array offset argument \"U_offset\" (" + U_offset + ") equals or exceeds array length (" + U.length + ")");
    if(V != null && V.length <= V_offset)
      throw new RuntimeException("array offset argument \"V_offset\" (" + V_offset + ") equals or exceeds array length (" + V.length + ")");
    if(DIR != null && DIR.length <= DIR_offset)
      throw new RuntimeException("array offset argument \"DIR_offset\" (" + DIR_offset + ") equals or exceeds array length (" + DIR.length + ")");
    if(SPD != null && SPD.length <= SPD_offset)
      throw new RuntimeException("array offset argument \"SPD_offset\" (" + SPD_offset + ") equals or exceeds array length (" + SPD.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
        ddff1(U, BufferFactory.SIZEOF_FLOAT * U_offset, V, BufferFactory.SIZEOF_FLOAT * V_offset, DIR, BufferFactory.SIZEOF_FLOAT * DIR_offset, SPD, BufferFactory.SIZEOF_FLOAT * SPD_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset);

  }

  /** Interface to C language function: <br> <code> void defineSlice(const float *  *  vc3d, const float *  *  param3d, int mnx, int nx, int ny, int nz, float param, int sense, float *  vc2d); </code>    */
  public static void defineSlice(java.nio.FloatBuffer[] vc3d, java.nio.FloatBuffer[] param3d, int mnx, int nx, int ny, int nz, float param, int sense, java.nio.FloatBuffer vc2d)
  {
    int[] vc3d_byte_offset_array = new int[vc3d.length];
    if (vc3d != null) {
      for (int _ctr = 0; _ctr < vc3d.length; _ctr++) {
        if (!BufferFactory.isDirect(vc3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"vc3d\" was not a direct buffer");
        }
        vc3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(vc3d[_ctr]);
      }
    }
    int[] param3d_byte_offset_array = new int[param3d.length];
    if (param3d != null) {
      for (int _ctr = 0; _ctr < param3d.length; _ctr++) {
        if (!BufferFactory.isDirect(param3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"param3d\" was not a direct buffer");
        }
        param3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(param3d[_ctr]);
      }
    }
    boolean _direct = BufferFactory.isDirect(vc2d);
    if (_direct) {
        defineSlice0(vc3d, vc3d_byte_offset_array, param3d, param3d_byte_offset_array, mnx, nx, ny, nz, param, sense, vc2d, BufferFactory.getDirectBufferByteOffset(vc2d));
    } else {
      defineSlice1(vc3d, vc3d_byte_offset_array, param3d, param3d_byte_offset_array, mnx, nx, ny, nz, param, sense, BufferFactory.getArray(vc2d), BufferFactory.getIndirectBufferByteOffset(vc2d));
    }
  }

  /** Entry point to C language function: <br> <code> void defineSlice(const float *  *  vc3d, const float *  *  param3d, int mnx, int nx, int ny, int nz, float param, int sense, float *  vc2d); </code>    */
  private static native void defineSlice0(Object[] vc3d, int[] vc3d_byte_offset_array, Object[] param3d, int[] param3d_byte_offset_array, int mnx, int nx, int ny, int nz, float param, int sense, Object vc2d, int vc2d_byte_offset);

  /** Entry point to C language function: <br> <code> void defineSlice(const float *  *  vc3d, const float *  *  param3d, int mnx, int nx, int ny, int nz, float param, int sense, float *  vc2d); </code>    */
  private static native void defineSlice1(Object[] vc3d, int[] vc3d_byte_offset_array, Object[] param3d, int[] param3d_byte_offset_array, int mnx, int nx, int ny, int nz, float param, int sense, Object vc2d, int vc2d_byte_offset);

  /** Interface to C language function: <br> <code> void defineSlice(const float *  *  vc3d, const float *  *  param3d, int mnx, int nx, int ny, int nz, float param, int sense, float *  vc2d); </code>    */
  public static void defineSlice(java.nio.FloatBuffer[] vc3d, java.nio.FloatBuffer[] param3d, int mnx, int nx, int ny, int nz, float param, int sense, float[] vc2d, int vc2d_offset)
  {
    int[] vc3d_byte_offset_array = new int[vc3d.length];
    if (vc3d != null) {
      for (int _ctr = 0; _ctr < vc3d.length; _ctr++) {
        if (!BufferFactory.isDirect(vc3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"vc3d\" was not a direct buffer");
        }
        vc3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(vc3d[_ctr]);
      }
    }
    int[] param3d_byte_offset_array = new int[param3d.length];
    if (param3d != null) {
      for (int _ctr = 0; _ctr < param3d.length; _ctr++) {
        if (!BufferFactory.isDirect(param3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"param3d\" was not a direct buffer");
        }
        param3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(param3d[_ctr]);
      }
    }
    if(vc2d != null && vc2d.length <= vc2d_offset)
      throw new RuntimeException("array offset argument \"vc2d_offset\" (" + vc2d_offset + ") equals or exceeds array length (" + vc2d.length + ")");
        defineSlice1(vc3d, vc3d_byte_offset_array, param3d, param3d_byte_offset_array, mnx, nx, ny, nz, param, sense, vc2d, BufferFactory.SIZEOF_FLOAT * vc2d_offset);

  }

  /** Interface to C language function: <br> <code> void defineSlices(float *  vc3d, int senseA, float *  param3d, int senseB, int nx, int ny, int nz, float *  paramC, int nc, float *  vcC); </code>    */
  public static void defineSlices(java.nio.FloatBuffer vc3d, int senseA, java.nio.FloatBuffer param3d, int senseB, int nx, int ny, int nz, java.nio.FloatBuffer paramC, int nc, java.nio.FloatBuffer vcC)
  {
    boolean _direct = BufferFactory.isDirect(vc3d);
    if (param3d != null && _direct != BufferFactory.isDirect(param3d))
      throw new RuntimeException("Argument \"param3d\" : Buffers passed to this method must all be either direct or indirect");
    if (paramC != null && _direct != BufferFactory.isDirect(paramC))
      throw new RuntimeException("Argument \"paramC\" : Buffers passed to this method must all be either direct or indirect");
    if (vcC != null && _direct != BufferFactory.isDirect(vcC))
      throw new RuntimeException("Argument \"vcC\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        defineSlices0(vc3d, BufferFactory.getDirectBufferByteOffset(vc3d), senseA, param3d, BufferFactory.getDirectBufferByteOffset(param3d), senseB, nx, ny, nz, paramC, BufferFactory.getDirectBufferByteOffset(paramC), nc, vcC, BufferFactory.getDirectBufferByteOffset(vcC));
    } else {
      defineSlices1(BufferFactory.getArray(vc3d), BufferFactory.getIndirectBufferByteOffset(vc3d), senseA, BufferFactory.getArray(param3d), BufferFactory.getIndirectBufferByteOffset(param3d), senseB, nx, ny, nz, BufferFactory.getArray(paramC), BufferFactory.getIndirectBufferByteOffset(paramC), nc, BufferFactory.getArray(vcC), BufferFactory.getIndirectBufferByteOffset(vcC));
    }
  }

  /** Entry point to C language function: <br> <code> void defineSlices(float *  vc3d, int senseA, float *  param3d, int senseB, int nx, int ny, int nz, float *  paramC, int nc, float *  vcC); </code>    */
  private static native void defineSlices0(Object vc3d, int vc3d_byte_offset, int senseA, Object param3d, int param3d_byte_offset, int senseB, int nx, int ny, int nz, Object paramC, int paramC_byte_offset, int nc, Object vcC, int vcC_byte_offset);

  /** Entry point to C language function: <br> <code> void defineSlices(float *  vc3d, int senseA, float *  param3d, int senseB, int nx, int ny, int nz, float *  paramC, int nc, float *  vcC); </code>    */
  private static native void defineSlices1(Object vc3d, int vc3d_byte_offset, int senseA, Object param3d, int param3d_byte_offset, int senseB, int nx, int ny, int nz, Object paramC, int paramC_byte_offset, int nc, Object vcC, int vcC_byte_offset);

  /** Interface to C language function: <br> <code> void defineSlices(float *  vc3d, int senseA, float *  param3d, int senseB, int nx, int ny, int nz, float *  paramC, int nc, float *  vcC); </code>    */
  public static void defineSlices(float[] vc3d, int vc3d_offset, int senseA, float[] param3d, int param3d_offset, int senseB, int nx, int ny, int nz, float[] paramC, int paramC_offset, int nc, float[] vcC, int vcC_offset)
  {
    if(vc3d != null && vc3d.length <= vc3d_offset)
      throw new RuntimeException("array offset argument \"vc3d_offset\" (" + vc3d_offset + ") equals or exceeds array length (" + vc3d.length + ")");
    if(param3d != null && param3d.length <= param3d_offset)
      throw new RuntimeException("array offset argument \"param3d_offset\" (" + param3d_offset + ") equals or exceeds array length (" + param3d.length + ")");
    if(paramC != null && paramC.length <= paramC_offset)
      throw new RuntimeException("array offset argument \"paramC_offset\" (" + paramC_offset + ") equals or exceeds array length (" + paramC.length + ")");
    if(vcC != null && vcC.length <= vcC_offset)
      throw new RuntimeException("array offset argument \"vcC_offset\" (" + vcC_offset + ") equals or exceeds array length (" + vcC.length + ")");
        defineSlices1(vc3d, BufferFactory.SIZEOF_FLOAT * vc3d_offset, senseA, param3d, BufferFactory.SIZEOF_FLOAT * param3d_offset, senseB, nx, ny, nz, paramC, BufferFactory.SIZEOF_FLOAT * paramC_offset, nc, vcC, BufferFactory.SIZEOF_FLOAT * vcC_offset);

  }

  /** Interface to C language function: <br> <code> void deftrk(float *  tcb, float *  pcb, float *  thdpar, float *  eptpar); </code>    */
  public static void deftrk(java.nio.FloatBuffer tcb, java.nio.FloatBuffer pcb, java.nio.FloatBuffer thdpar, java.nio.FloatBuffer eptpar)
  {
    boolean _direct = BufferFactory.isDirect(tcb);
    if (pcb != null && _direct != BufferFactory.isDirect(pcb))
      throw new RuntimeException("Argument \"pcb\" : Buffers passed to this method must all be either direct or indirect");
    if (thdpar != null && _direct != BufferFactory.isDirect(thdpar))
      throw new RuntimeException("Argument \"thdpar\" : Buffers passed to this method must all be either direct or indirect");
    if (eptpar != null && _direct != BufferFactory.isDirect(eptpar))
      throw new RuntimeException("Argument \"eptpar\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        deftrk0(tcb, BufferFactory.getDirectBufferByteOffset(tcb), pcb, BufferFactory.getDirectBufferByteOffset(pcb), thdpar, BufferFactory.getDirectBufferByteOffset(thdpar), eptpar, BufferFactory.getDirectBufferByteOffset(eptpar));
    } else {
      deftrk1(BufferFactory.getArray(tcb), BufferFactory.getIndirectBufferByteOffset(tcb), BufferFactory.getArray(pcb), BufferFactory.getIndirectBufferByteOffset(pcb), BufferFactory.getArray(thdpar), BufferFactory.getIndirectBufferByteOffset(thdpar), BufferFactory.getArray(eptpar), BufferFactory.getIndirectBufferByteOffset(eptpar));
    }
  }

  /** Entry point to C language function: <br> <code> void deftrk(float *  tcb, float *  pcb, float *  thdpar, float *  eptpar); </code>    */
  private static native void deftrk0(Object tcb, int tcb_byte_offset, Object pcb, int pcb_byte_offset, Object thdpar, int thdpar_byte_offset, Object eptpar, int eptpar_byte_offset);

  /** Entry point to C language function: <br> <code> void deftrk(float *  tcb, float *  pcb, float *  thdpar, float *  eptpar); </code>    */
  private static native void deftrk1(Object tcb, int tcb_byte_offset, Object pcb, int pcb_byte_offset, Object thdpar, int thdpar_byte_offset, Object eptpar, int eptpar_byte_offset);

  /** Interface to C language function: <br> <code> void deftrk(float *  tcb, float *  pcb, float *  thdpar, float *  eptpar); </code>    */
  public static void deftrk(float[] tcb, int tcb_offset, float[] pcb, int pcb_offset, float[] thdpar, int thdpar_offset, float[] eptpar, int eptpar_offset)
  {
    if(tcb != null && tcb.length <= tcb_offset)
      throw new RuntimeException("array offset argument \"tcb_offset\" (" + tcb_offset + ") equals or exceeds array length (" + tcb.length + ")");
    if(pcb != null && pcb.length <= pcb_offset)
      throw new RuntimeException("array offset argument \"pcb_offset\" (" + pcb_offset + ") equals or exceeds array length (" + pcb.length + ")");
    if(thdpar != null && thdpar.length <= thdpar_offset)
      throw new RuntimeException("array offset argument \"thdpar_offset\" (" + thdpar_offset + ") equals or exceeds array length (" + thdpar.length + ")");
    if(eptpar != null && eptpar.length <= eptpar_offset)
      throw new RuntimeException("array offset argument \"eptpar_offset\" (" + eptpar_offset + ") equals or exceeds array length (" + eptpar.length + ")");
        deftrk1(tcb, BufferFactory.SIZEOF_FLOAT * tcb_offset, pcb, BufferFactory.SIZEOF_FLOAT * pcb_offset, thdpar, BufferFactory.SIZEOF_FLOAT * thdpar_offset, eptpar, BufferFactory.SIZEOF_FLOAT * eptpar_offset);

  }

  /** Interface to C language function: <br> <code> void density(float *  P, float *  TVIR, int *  NLVLS, float *  RHO); </code>    */
  public static void density(java.nio.FloatBuffer P, java.nio.FloatBuffer TVIR, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer RHO)
  {
    boolean _direct = BufferFactory.isDirect(P);
    if (TVIR != null && _direct != BufferFactory.isDirect(TVIR))
      throw new RuntimeException("Argument \"TVIR\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (RHO != null && _direct != BufferFactory.isDirect(RHO))
      throw new RuntimeException("Argument \"RHO\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        density0(P, BufferFactory.getDirectBufferByteOffset(P), TVIR, BufferFactory.getDirectBufferByteOffset(TVIR), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), RHO, BufferFactory.getDirectBufferByteOffset(RHO));
    } else {
      density1(BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(TVIR), BufferFactory.getIndirectBufferByteOffset(TVIR), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(RHO), BufferFactory.getIndirectBufferByteOffset(RHO));
    }
  }

  /** Entry point to C language function: <br> <code> void density(float *  P, float *  TVIR, int *  NLVLS, float *  RHO); </code>    */
  private static native void density0(Object P, int P_byte_offset, Object TVIR, int TVIR_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object RHO, int RHO_byte_offset);

  /** Entry point to C language function: <br> <code> void density(float *  P, float *  TVIR, int *  NLVLS, float *  RHO); </code>    */
  private static native void density1(Object P, int P_byte_offset, Object TVIR, int TVIR_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object RHO, int RHO_byte_offset);

  /** Interface to C language function: <br> <code> void density(float *  P, float *  TVIR, int *  NLVLS, float *  RHO); </code>    */
  public static void density(float[] P, int P_offset, float[] TVIR, int TVIR_offset, int[] NLVLS, int NLVLS_offset, float[] RHO, int RHO_offset)
  {
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(TVIR != null && TVIR.length <= TVIR_offset)
      throw new RuntimeException("array offset argument \"TVIR_offset\" (" + TVIR_offset + ") equals or exceeds array length (" + TVIR.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(RHO != null && RHO.length <= RHO_offset)
      throw new RuntimeException("array offset argument \"RHO_offset\" (" + RHO_offset + ") equals or exceeds array length (" + RHO.length + ")");
        density1(P, BufferFactory.SIZEOF_FLOAT * P_offset, TVIR, BufferFactory.SIZEOF_FLOAT * TVIR_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, RHO, BufferFactory.SIZEOF_FLOAT * RHO_offset);

  }

  /** Interface to C language function: <br> <code> void derivative(float *  a1, float *  a2, float *  b1, float *  b2, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void derivative(java.nio.FloatBuffer a1, java.nio.FloatBuffer a2, java.nio.FloatBuffer b1, java.nio.FloatBuffer b2, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a1);
    if (a2 != null && _direct != BufferFactory.isDirect(a2))
      throw new RuntimeException("Argument \"a2\" : Buffers passed to this method must all be either direct or indirect");
    if (b1 != null && _direct != BufferFactory.isDirect(b1))
      throw new RuntimeException("Argument \"b1\" : Buffers passed to this method must all be either direct or indirect");
    if (b2 != null && _direct != BufferFactory.isDirect(b2))
      throw new RuntimeException("Argument \"b2\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        derivative0(a1, BufferFactory.getDirectBufferByteOffset(a1), a2, BufferFactory.getDirectBufferByteOffset(a2), b1, BufferFactory.getDirectBufferByteOffset(b1), b2, BufferFactory.getDirectBufferByteOffset(b2), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      derivative1(BufferFactory.getArray(a1), BufferFactory.getIndirectBufferByteOffset(a1), BufferFactory.getArray(a2), BufferFactory.getIndirectBufferByteOffset(a2), BufferFactory.getArray(b1), BufferFactory.getIndirectBufferByteOffset(b1), BufferFactory.getArray(b2), BufferFactory.getIndirectBufferByteOffset(b2), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void derivative(float *  a1, float *  a2, float *  b1, float *  b2, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void derivative0(Object a1, int a1_byte_offset, Object a2, int a2_byte_offset, Object b1, int b1_byte_offset, Object b2, int b2_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void derivative(float *  a1, float *  a2, float *  b1, float *  b2, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void derivative1(Object a1, int a1_byte_offset, Object a2, int a2_byte_offset, Object b1, int b1_byte_offset, Object b2, int b2_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void derivative(float *  a1, float *  a2, float *  b1, float *  b2, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void derivative(float[] a1, int a1_offset, float[] a2, int a2_offset, float[] b1, int b1_offset, float[] b2, int b2_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a1 != null && a1.length <= a1_offset)
      throw new RuntimeException("array offset argument \"a1_offset\" (" + a1_offset + ") equals or exceeds array length (" + a1.length + ")");
    if(a2 != null && a2.length <= a2_offset)
      throw new RuntimeException("array offset argument \"a2_offset\" (" + a2_offset + ") equals or exceeds array length (" + a2.length + ")");
    if(b1 != null && b1.length <= b1_offset)
      throw new RuntimeException("array offset argument \"b1_offset\" (" + b1_offset + ") equals or exceeds array length (" + b1.length + ")");
    if(b2 != null && b2.length <= b2_offset)
      throw new RuntimeException("array offset argument \"b2_offset\" (" + b2_offset + ") equals or exceeds array length (" + b2.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        derivative1(a1, BufferFactory.SIZEOF_FLOAT * a1_offset, a2, BufferFactory.SIZEOF_FLOAT * a2_offset, b1, BufferFactory.SIZEOF_FLOAT * b1_offset, b2, BufferFactory.SIZEOF_FLOAT * b2_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void dist_filter(float *  a, float *  npts, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void dist_filter(java.nio.FloatBuffer a, java.nio.FloatBuffer npts, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (npts != null && _direct != BufferFactory.isDirect(npts))
      throw new RuntimeException("Argument \"npts\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        dist_filter0(a, BufferFactory.getDirectBufferByteOffset(a), npts, BufferFactory.getDirectBufferByteOffset(npts), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      dist_filter1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(npts), BufferFactory.getIndirectBufferByteOffset(npts), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void dist_filter(float *  a, float *  npts, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void dist_filter0(Object a, int a_byte_offset, Object npts, int npts_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void dist_filter(float *  a, float *  npts, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void dist_filter1(Object a, int a_byte_offset, Object npts, int npts_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void dist_filter(float *  a, float *  npts, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void dist_filter(float[] a, int a_offset, float[] npts, int npts_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(npts != null && npts.length <= npts_offset)
      throw new RuntimeException("array offset argument \"npts_offset\" (" + npts_offset + ") equals or exceeds array length (" + npts.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        dist_filter1(a, BufferFactory.SIZEOF_FLOAT * a_offset, npts, BufferFactory.SIZEOF_FLOAT * npts_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void div_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void div_aray(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        div_aray0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      div_aray1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void div_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void div_aray0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void div_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void div_aray1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void div_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void div_aray(float[] a, int a_offset, float[] b, int b_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        div_aray1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> float dmixr(float *  temp, float *  pres, int *  iw); </code>    */
  public static float dmixr(java.nio.FloatBuffer temp, java.nio.FloatBuffer pres, java.nio.IntBuffer iw)
  {
    boolean _direct = BufferFactory.isDirect(temp);
    if (pres != null && _direct != BufferFactory.isDirect(pres))
      throw new RuntimeException("Argument \"pres\" : Buffers passed to this method must all be either direct or indirect");
    if (iw != null && _direct != BufferFactory.isDirect(iw))
      throw new RuntimeException("Argument \"iw\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return dmixr0(temp, BufferFactory.getDirectBufferByteOffset(temp), pres, BufferFactory.getDirectBufferByteOffset(pres), iw, BufferFactory.getDirectBufferByteOffset(iw));
    } else {
      return dmixr1(BufferFactory.getArray(temp), BufferFactory.getIndirectBufferByteOffset(temp), BufferFactory.getArray(pres), BufferFactory.getIndirectBufferByteOffset(pres), BufferFactory.getArray(iw), BufferFactory.getIndirectBufferByteOffset(iw));
    }
  }

  /** Entry point to C language function: <br> <code> float dmixr(float *  temp, float *  pres, int *  iw); </code>    */
  private static native float dmixr0(Object temp, int temp_byte_offset, Object pres, int pres_byte_offset, Object iw, int iw_byte_offset);

  /** Entry point to C language function: <br> <code> float dmixr(float *  temp, float *  pres, int *  iw); </code>    */
  private static native float dmixr1(Object temp, int temp_byte_offset, Object pres, int pres_byte_offset, Object iw, int iw_byte_offset);

  /** Interface to C language function: <br> <code> float dmixr(float *  temp, float *  pres, int *  iw); </code>    */
  public static float dmixr(float[] temp, int temp_offset, float[] pres, int pres_offset, int[] iw, int iw_offset)
  {
    if(temp != null && temp.length <= temp_offset)
      throw new RuntimeException("array offset argument \"temp_offset\" (" + temp_offset + ") equals or exceeds array length (" + temp.length + ")");
    if(pres != null && pres.length <= pres_offset)
      throw new RuntimeException("array offset argument \"pres_offset\" (" + pres_offset + ") equals or exceeds array length (" + pres.length + ")");
    if(iw != null && iw.length <= iw_offset)
      throw new RuntimeException("array offset argument \"iw_offset\" (" + iw_offset + ") equals or exceeds array length (" + iw.length + ")");
        return dmixr1(temp, BufferFactory.SIZEOF_FLOAT * temp_offset, pres, BufferFactory.SIZEOF_FLOAT * pres_offset, iw, BufferFactory.SIZEOF_INT * iw_offset);

  }

  /** Interface to C language function: <br> <code> void dotvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void dotvectors(java.nio.FloatBuffer aX, java.nio.FloatBuffer aY, java.nio.FloatBuffer bX, java.nio.FloatBuffer bY, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(aX);
    if (aY != null && _direct != BufferFactory.isDirect(aY))
      throw new RuntimeException("Argument \"aY\" : Buffers passed to this method must all be either direct or indirect");
    if (bX != null && _direct != BufferFactory.isDirect(bX))
      throw new RuntimeException("Argument \"bX\" : Buffers passed to this method must all be either direct or indirect");
    if (bY != null && _direct != BufferFactory.isDirect(bY))
      throw new RuntimeException("Argument \"bY\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        dotvectors0(aX, BufferFactory.getDirectBufferByteOffset(aX), aY, BufferFactory.getDirectBufferByteOffset(aY), bX, BufferFactory.getDirectBufferByteOffset(bX), bY, BufferFactory.getDirectBufferByteOffset(bY), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      dotvectors1(BufferFactory.getArray(aX), BufferFactory.getIndirectBufferByteOffset(aX), BufferFactory.getArray(aY), BufferFactory.getIndirectBufferByteOffset(aY), BufferFactory.getArray(bX), BufferFactory.getIndirectBufferByteOffset(bX), BufferFactory.getArray(bY), BufferFactory.getIndirectBufferByteOffset(bY), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void dotvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void dotvectors0(Object aX, int aX_byte_offset, Object aY, int aY_byte_offset, Object bX, int bX_byte_offset, Object bY, int bY_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void dotvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void dotvectors1(Object aX, int aX_byte_offset, Object aY, int aY_byte_offset, Object bX, int bX_byte_offset, Object bY, int bY_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void dotvectors(float *  aX, float *  aY, float *  bX, float *  bY, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void dotvectors(float[] aX, int aX_offset, float[] aY, int aY_offset, float[] bX, int bX_offset, float[] bY, int bY_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(aX != null && aX.length <= aX_offset)
      throw new RuntimeException("array offset argument \"aX_offset\" (" + aX_offset + ") equals or exceeds array length (" + aX.length + ")");
    if(aY != null && aY.length <= aY_offset)
      throw new RuntimeException("array offset argument \"aY_offset\" (" + aY_offset + ") equals or exceeds array length (" + aY.length + ")");
    if(bX != null && bX.length <= bX_offset)
      throw new RuntimeException("array offset argument \"bX_offset\" (" + bX_offset + ") equals or exceeds array length (" + bX.length + ")");
    if(bY != null && bY.length <= bY_offset)
      throw new RuntimeException("array offset argument \"bY_offset\" (" + bY_offset + ") equals or exceeds array length (" + bY.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        dotvectors1(aX, BufferFactory.SIZEOF_FLOAT * aX_offset, aY, BufferFactory.SIZEOF_FLOAT * aY_offset, bX, BufferFactory.SIZEOF_FLOAT * bX_offset, bY, BufferFactory.SIZEOF_FLOAT * bY_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> float dzdlnp(float * , float * , float * ); </code>    */
  public static float dzdlnp(java.nio.FloatBuffer arg0, java.nio.FloatBuffer arg1, java.nio.FloatBuffer arg2)
  {
    boolean _direct = BufferFactory.isDirect(arg0);
    if (arg1 != null && _direct != BufferFactory.isDirect(arg1))
      throw new RuntimeException("Argument \"arg1\" : Buffers passed to this method must all be either direct or indirect");
    if (arg2 != null && _direct != BufferFactory.isDirect(arg2))
      throw new RuntimeException("Argument \"arg2\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return dzdlnp0(arg0, BufferFactory.getDirectBufferByteOffset(arg0), arg1, BufferFactory.getDirectBufferByteOffset(arg1), arg2, BufferFactory.getDirectBufferByteOffset(arg2));
    } else {
      return dzdlnp1(BufferFactory.getArray(arg0), BufferFactory.getIndirectBufferByteOffset(arg0), BufferFactory.getArray(arg1), BufferFactory.getIndirectBufferByteOffset(arg1), BufferFactory.getArray(arg2), BufferFactory.getIndirectBufferByteOffset(arg2));
    }
  }

  /** Entry point to C language function: <br> <code> float dzdlnp(float * , float * , float * ); </code>    */
  private static native float dzdlnp0(Object arg0, int arg0_byte_offset, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset);

  /** Entry point to C language function: <br> <code> float dzdlnp(float * , float * , float * ); </code>    */
  private static native float dzdlnp1(Object arg0, int arg0_byte_offset, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset);

  /** Interface to C language function: <br> <code> float dzdlnp(float * , float * , float * ); </code>    */
  public static float dzdlnp(float[] arg0, int arg0_offset, float[] arg1, int arg1_offset, float[] arg2, int arg2_offset)
  {
    if(arg0 != null && arg0.length <= arg0_offset)
      throw new RuntimeException("array offset argument \"arg0_offset\" (" + arg0_offset + ") equals or exceeds array length (" + arg0.length + ")");
    if(arg1 != null && arg1.length <= arg1_offset)
      throw new RuntimeException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    if(arg2 != null && arg2.length <= arg2_offset)
      throw new RuntimeException("array offset argument \"arg2_offset\" (" + arg2_offset + ") equals or exceeds array length (" + arg2.length + ")");
        return dzdlnp1(arg0, BufferFactory.SIZEOF_FLOAT * arg0_offset, arg1, BufferFactory.SIZEOF_FLOAT * arg1_offset, arg2, BufferFactory.SIZEOF_FLOAT * arg2_offset);

  }

  /** Interface to C language function: <br> <code> float ept(float *  t, float *  td, float *  p); </code>    */
  public static float ept(java.nio.FloatBuffer t, java.nio.FloatBuffer td, java.nio.FloatBuffer p)
  {
    boolean _direct = BufferFactory.isDirect(t);
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return ept0(t, BufferFactory.getDirectBufferByteOffset(t), td, BufferFactory.getDirectBufferByteOffset(td), p, BufferFactory.getDirectBufferByteOffset(p));
    } else {
      return ept1(BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p));
    }
  }

  /** Entry point to C language function: <br> <code> float ept(float *  t, float *  td, float *  p); </code>    */
  private static native float ept0(Object t, int t_byte_offset, Object td, int td_byte_offset, Object p, int p_byte_offset);

  /** Entry point to C language function: <br> <code> float ept(float *  t, float *  td, float *  p); </code>    */
  private static native float ept1(Object t, int t_byte_offset, Object td, int td_byte_offset, Object p, int p_byte_offset);

  /** Interface to C language function: <br> <code> float ept(float *  t, float *  td, float *  p); </code>    */
  public static float ept(float[] t, int t_offset, float[] td, int td_offset, float[] p, int p_offset)
  {
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
        return ept1(t, BufferFactory.SIZEOF_FLOAT * t_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset);

  }

  /** Interface to C language function: <br> <code> void eqlev(float *  P, float *  HT, float *  TP, float *  TE, float *  PLFC, float *  EPTPAR, int *  NPAR, float *  PEQLEV, float *  HEQLEV, float *  TEQLEV); </code>    */
  public static void eqlev(java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer TP, java.nio.FloatBuffer TE, java.nio.FloatBuffer PLFC, java.nio.FloatBuffer EPTPAR, java.nio.IntBuffer NPAR, java.nio.FloatBuffer PEQLEV, java.nio.FloatBuffer HEQLEV, java.nio.FloatBuffer TEQLEV)
  {
    boolean _direct = BufferFactory.isDirect(P);
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (TP != null && _direct != BufferFactory.isDirect(TP))
      throw new RuntimeException("Argument \"TP\" : Buffers passed to this method must all be either direct or indirect");
    if (TE != null && _direct != BufferFactory.isDirect(TE))
      throw new RuntimeException("Argument \"TE\" : Buffers passed to this method must all be either direct or indirect");
    if (PLFC != null && _direct != BufferFactory.isDirect(PLFC))
      throw new RuntimeException("Argument \"PLFC\" : Buffers passed to this method must all be either direct or indirect");
    if (EPTPAR != null && _direct != BufferFactory.isDirect(EPTPAR))
      throw new RuntimeException("Argument \"EPTPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (PEQLEV != null && _direct != BufferFactory.isDirect(PEQLEV))
      throw new RuntimeException("Argument \"PEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (HEQLEV != null && _direct != BufferFactory.isDirect(HEQLEV))
      throw new RuntimeException("Argument \"HEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (TEQLEV != null && _direct != BufferFactory.isDirect(TEQLEV))
      throw new RuntimeException("Argument \"TEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        eqlev0(P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), TP, BufferFactory.getDirectBufferByteOffset(TP), TE, BufferFactory.getDirectBufferByteOffset(TE), PLFC, BufferFactory.getDirectBufferByteOffset(PLFC), EPTPAR, BufferFactory.getDirectBufferByteOffset(EPTPAR), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), PEQLEV, BufferFactory.getDirectBufferByteOffset(PEQLEV), HEQLEV, BufferFactory.getDirectBufferByteOffset(HEQLEV), TEQLEV, BufferFactory.getDirectBufferByteOffset(TEQLEV));
    } else {
      eqlev1(BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(TP), BufferFactory.getIndirectBufferByteOffset(TP), BufferFactory.getArray(TE), BufferFactory.getIndirectBufferByteOffset(TE), BufferFactory.getArray(PLFC), BufferFactory.getIndirectBufferByteOffset(PLFC), BufferFactory.getArray(EPTPAR), BufferFactory.getIndirectBufferByteOffset(EPTPAR), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(PEQLEV), BufferFactory.getIndirectBufferByteOffset(PEQLEV), BufferFactory.getArray(HEQLEV), BufferFactory.getIndirectBufferByteOffset(HEQLEV), BufferFactory.getArray(TEQLEV), BufferFactory.getIndirectBufferByteOffset(TEQLEV));
    }
  }

  /** Entry point to C language function: <br> <code> void eqlev(float *  P, float *  HT, float *  TP, float *  TE, float *  PLFC, float *  EPTPAR, int *  NPAR, float *  PEQLEV, float *  HEQLEV, float *  TEQLEV); </code>    */
  private static native void eqlev0(Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TP, int TP_byte_offset, Object TE, int TE_byte_offset, Object PLFC, int PLFC_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object NPAR, int NPAR_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object HEQLEV, int HEQLEV_byte_offset, Object TEQLEV, int TEQLEV_byte_offset);

  /** Entry point to C language function: <br> <code> void eqlev(float *  P, float *  HT, float *  TP, float *  TE, float *  PLFC, float *  EPTPAR, int *  NPAR, float *  PEQLEV, float *  HEQLEV, float *  TEQLEV); </code>    */
  private static native void eqlev1(Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TP, int TP_byte_offset, Object TE, int TE_byte_offset, Object PLFC, int PLFC_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object NPAR, int NPAR_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object HEQLEV, int HEQLEV_byte_offset, Object TEQLEV, int TEQLEV_byte_offset);

  /** Interface to C language function: <br> <code> void eqlev(float *  P, float *  HT, float *  TP, float *  TE, float *  PLFC, float *  EPTPAR, int *  NPAR, float *  PEQLEV, float *  HEQLEV, float *  TEQLEV); </code>    */
  public static void eqlev(float[] P, int P_offset, float[] HT, int HT_offset, float[] TP, int TP_offset, float[] TE, int TE_offset, float[] PLFC, int PLFC_offset, float[] EPTPAR, int EPTPAR_offset, int[] NPAR, int NPAR_offset, float[] PEQLEV, int PEQLEV_offset, float[] HEQLEV, int HEQLEV_offset, float[] TEQLEV, int TEQLEV_offset)
  {
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(TP != null && TP.length <= TP_offset)
      throw new RuntimeException("array offset argument \"TP_offset\" (" + TP_offset + ") equals or exceeds array length (" + TP.length + ")");
    if(TE != null && TE.length <= TE_offset)
      throw new RuntimeException("array offset argument \"TE_offset\" (" + TE_offset + ") equals or exceeds array length (" + TE.length + ")");
    if(PLFC != null && PLFC.length <= PLFC_offset)
      throw new RuntimeException("array offset argument \"PLFC_offset\" (" + PLFC_offset + ") equals or exceeds array length (" + PLFC.length + ")");
    if(EPTPAR != null && EPTPAR.length <= EPTPAR_offset)
      throw new RuntimeException("array offset argument \"EPTPAR_offset\" (" + EPTPAR_offset + ") equals or exceeds array length (" + EPTPAR.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(PEQLEV != null && PEQLEV.length <= PEQLEV_offset)
      throw new RuntimeException("array offset argument \"PEQLEV_offset\" (" + PEQLEV_offset + ") equals or exceeds array length (" + PEQLEV.length + ")");
    if(HEQLEV != null && HEQLEV.length <= HEQLEV_offset)
      throw new RuntimeException("array offset argument \"HEQLEV_offset\" (" + HEQLEV_offset + ") equals or exceeds array length (" + HEQLEV.length + ")");
    if(TEQLEV != null && TEQLEV.length <= TEQLEV_offset)
      throw new RuntimeException("array offset argument \"TEQLEV_offset\" (" + TEQLEV_offset + ") equals or exceeds array length (" + TEQLEV.length + ")");
        eqlev1(P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, TP, BufferFactory.SIZEOF_FLOAT * TP_offset, TE, BufferFactory.SIZEOF_FLOAT * TE_offset, PLFC, BufferFactory.SIZEOF_FLOAT * PLFC_offset, EPTPAR, BufferFactory.SIZEOF_FLOAT * EPTPAR_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, PEQLEV, BufferFactory.SIZEOF_FLOAT * PEQLEV_offset, HEQLEV, BufferFactory.SIZEOF_FLOAT * HEQLEV_offset, TEQLEV, BufferFactory.SIZEOF_FLOAT * TEQLEV_offset);

  }

  /** Interface to C language function: <br> <code> void eqp(float *  DELTAP, float *  P, float *  HT, float *  T, float *  TD, int *  N, float *  PP, float *  HTT, float *  TT, float *  TTD, int *  NN); </code>    */
  public static void eqp(java.nio.FloatBuffer DELTAP, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer T, java.nio.FloatBuffer TD, java.nio.IntBuffer N, java.nio.FloatBuffer PP, java.nio.FloatBuffer HTT, java.nio.FloatBuffer TT, java.nio.FloatBuffer TTD, java.nio.IntBuffer NN)
  {
    boolean _direct = BufferFactory.isDirect(DELTAP);
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (TD != null && _direct != BufferFactory.isDirect(TD))
      throw new RuntimeException("Argument \"TD\" : Buffers passed to this method must all be either direct or indirect");
    if (N != null && _direct != BufferFactory.isDirect(N))
      throw new RuntimeException("Argument \"N\" : Buffers passed to this method must all be either direct or indirect");
    if (PP != null && _direct != BufferFactory.isDirect(PP))
      throw new RuntimeException("Argument \"PP\" : Buffers passed to this method must all be either direct or indirect");
    if (HTT != null && _direct != BufferFactory.isDirect(HTT))
      throw new RuntimeException("Argument \"HTT\" : Buffers passed to this method must all be either direct or indirect");
    if (TT != null && _direct != BufferFactory.isDirect(TT))
      throw new RuntimeException("Argument \"TT\" : Buffers passed to this method must all be either direct or indirect");
    if (TTD != null && _direct != BufferFactory.isDirect(TTD))
      throw new RuntimeException("Argument \"TTD\" : Buffers passed to this method must all be either direct or indirect");
    if (NN != null && _direct != BufferFactory.isDirect(NN))
      throw new RuntimeException("Argument \"NN\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        eqp0(DELTAP, BufferFactory.getDirectBufferByteOffset(DELTAP), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), T, BufferFactory.getDirectBufferByteOffset(T), TD, BufferFactory.getDirectBufferByteOffset(TD), N, BufferFactory.getDirectBufferByteOffset(N), PP, BufferFactory.getDirectBufferByteOffset(PP), HTT, BufferFactory.getDirectBufferByteOffset(HTT), TT, BufferFactory.getDirectBufferByteOffset(TT), TTD, BufferFactory.getDirectBufferByteOffset(TTD), NN, BufferFactory.getDirectBufferByteOffset(NN));
    } else {
      eqp1(BufferFactory.getArray(DELTAP), BufferFactory.getIndirectBufferByteOffset(DELTAP), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(TD), BufferFactory.getIndirectBufferByteOffset(TD), BufferFactory.getArray(N), BufferFactory.getIndirectBufferByteOffset(N), BufferFactory.getArray(PP), BufferFactory.getIndirectBufferByteOffset(PP), BufferFactory.getArray(HTT), BufferFactory.getIndirectBufferByteOffset(HTT), BufferFactory.getArray(TT), BufferFactory.getIndirectBufferByteOffset(TT), BufferFactory.getArray(TTD), BufferFactory.getIndirectBufferByteOffset(TTD), BufferFactory.getArray(NN), BufferFactory.getIndirectBufferByteOffset(NN));
    }
  }

  /** Entry point to C language function: <br> <code> void eqp(float *  DELTAP, float *  P, float *  HT, float *  T, float *  TD, int *  N, float *  PP, float *  HTT, float *  TT, float *  TTD, int *  NN); </code>    */
  private static native void eqp0(Object DELTAP, int DELTAP_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object N, int N_byte_offset, Object PP, int PP_byte_offset, Object HTT, int HTT_byte_offset, Object TT, int TT_byte_offset, Object TTD, int TTD_byte_offset, Object NN, int NN_byte_offset);

  /** Entry point to C language function: <br> <code> void eqp(float *  DELTAP, float *  P, float *  HT, float *  T, float *  TD, int *  N, float *  PP, float *  HTT, float *  TT, float *  TTD, int *  NN); </code>    */
  private static native void eqp1(Object DELTAP, int DELTAP_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object N, int N_byte_offset, Object PP, int PP_byte_offset, Object HTT, int HTT_byte_offset, Object TT, int TT_byte_offset, Object TTD, int TTD_byte_offset, Object NN, int NN_byte_offset);

  /** Interface to C language function: <br> <code> void eqp(float *  DELTAP, float *  P, float *  HT, float *  T, float *  TD, int *  N, float *  PP, float *  HTT, float *  TT, float *  TTD, int *  NN); </code>    */
  public static void eqp(float[] DELTAP, int DELTAP_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] T, int T_offset, float[] TD, int TD_offset, int[] N, int N_offset, float[] PP, int PP_offset, float[] HTT, int HTT_offset, float[] TT, int TT_offset, float[] TTD, int TTD_offset, int[] NN, int NN_offset)
  {
    if(DELTAP != null && DELTAP.length <= DELTAP_offset)
      throw new RuntimeException("array offset argument \"DELTAP_offset\" (" + DELTAP_offset + ") equals or exceeds array length (" + DELTAP.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(TD != null && TD.length <= TD_offset)
      throw new RuntimeException("array offset argument \"TD_offset\" (" + TD_offset + ") equals or exceeds array length (" + TD.length + ")");
    if(N != null && N.length <= N_offset)
      throw new RuntimeException("array offset argument \"N_offset\" (" + N_offset + ") equals or exceeds array length (" + N.length + ")");
    if(PP != null && PP.length <= PP_offset)
      throw new RuntimeException("array offset argument \"PP_offset\" (" + PP_offset + ") equals or exceeds array length (" + PP.length + ")");
    if(HTT != null && HTT.length <= HTT_offset)
      throw new RuntimeException("array offset argument \"HTT_offset\" (" + HTT_offset + ") equals or exceeds array length (" + HTT.length + ")");
    if(TT != null && TT.length <= TT_offset)
      throw new RuntimeException("array offset argument \"TT_offset\" (" + TT_offset + ") equals or exceeds array length (" + TT.length + ")");
    if(TTD != null && TTD.length <= TTD_offset)
      throw new RuntimeException("array offset argument \"TTD_offset\" (" + TTD_offset + ") equals or exceeds array length (" + TTD.length + ")");
    if(NN != null && NN.length <= NN_offset)
      throw new RuntimeException("array offset argument \"NN_offset\" (" + NN_offset + ") equals or exceeds array length (" + NN.length + ")");
        eqp1(DELTAP, BufferFactory.SIZEOF_FLOAT * DELTAP_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, TD, BufferFactory.SIZEOF_FLOAT * TD_offset, N, BufferFactory.SIZEOF_INT * N_offset, PP, BufferFactory.SIZEOF_FLOAT * PP_offset, HTT, BufferFactory.SIZEOF_FLOAT * HTT_offset, TT, BufferFactory.SIZEOF_FLOAT * TT_offset, TTD, BufferFactory.SIZEOF_FLOAT * TTD_offset, NN, BufferFactory.SIZEOF_INT * NN_offset);

  }

  /** Interface to C language function: <br> <code> float esat(float *  T); </code>    */
  public static float esat(java.nio.FloatBuffer T)
  {
    boolean _direct = BufferFactory.isDirect(T);
    if (_direct) {
        return esat0(T, BufferFactory.getDirectBufferByteOffset(T));
    } else {
      return esat1(BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T));
    }
  }

  /** Entry point to C language function: <br> <code> float esat(float *  T); </code>    */
  private static native float esat0(Object T, int T_byte_offset);

  /** Entry point to C language function: <br> <code> float esat(float *  T); </code>    */
  private static native float esat1(Object T, int T_byte_offset);

  /** Interface to C language function: <br> <code> float esat(float *  T); </code>    */
  public static float esat(float[] T, int T_offset)
  {
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
        return esat1(T, BufferFactory.SIZEOF_FLOAT * T_offset);

  }

  /** Interface to C language function: <br> <code> void exp_aray(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  public static void exp_aray(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        exp_aray0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      exp_aray1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void exp_aray(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void exp_aray0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void exp_aray(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void exp_aray1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void exp_aray(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  public static void exp_aray(float[] a, int a_offset, float[] b, int b_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        exp_aray1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void fndiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fnx, float *  fny, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fndiv); </code>    */
  public static void fndiverg(java.nio.FloatBuffer zmid, java.nio.FloatBuffer ztop, java.nio.FloatBuffer zbot, java.nio.FloatBuffer ptop, java.nio.FloatBuffer pbot, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer f, java.nio.FloatBuffer fnx, java.nio.FloatBuffer fny, java.nio.FloatBuffer w1, java.nio.FloatBuffer dtdx, java.nio.FloatBuffer dtdy, java.nio.FloatBuffer qx, java.nio.FloatBuffer qy, java.nio.FloatBuffer fndiv)
  {
    boolean _direct = BufferFactory.isDirect(zmid);
    if (ztop != null && _direct != BufferFactory.isDirect(ztop))
      throw new RuntimeException("Argument \"ztop\" : Buffers passed to this method must all be either direct or indirect");
    if (zbot != null && _direct != BufferFactory.isDirect(zbot))
      throw new RuntimeException("Argument \"zbot\" : Buffers passed to this method must all be either direct or indirect");
    if (ptop != null && _direct != BufferFactory.isDirect(ptop))
      throw new RuntimeException("Argument \"ptop\" : Buffers passed to this method must all be either direct or indirect");
    if (pbot != null && _direct != BufferFactory.isDirect(pbot))
      throw new RuntimeException("Argument \"pbot\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (f != null && _direct != BufferFactory.isDirect(f))
      throw new RuntimeException("Argument \"f\" : Buffers passed to this method must all be either direct or indirect");
    if (fnx != null && _direct != BufferFactory.isDirect(fnx))
      throw new RuntimeException("Argument \"fnx\" : Buffers passed to this method must all be either direct or indirect");
    if (fny != null && _direct != BufferFactory.isDirect(fny))
      throw new RuntimeException("Argument \"fny\" : Buffers passed to this method must all be either direct or indirect");
    if (w1 != null && _direct != BufferFactory.isDirect(w1))
      throw new RuntimeException("Argument \"w1\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx != null && _direct != BufferFactory.isDirect(dtdx))
      throw new RuntimeException("Argument \"dtdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy != null && _direct != BufferFactory.isDirect(dtdy))
      throw new RuntimeException("Argument \"dtdy\" : Buffers passed to this method must all be either direct or indirect");
    if (qx != null && _direct != BufferFactory.isDirect(qx))
      throw new RuntimeException("Argument \"qx\" : Buffers passed to this method must all be either direct or indirect");
    if (qy != null && _direct != BufferFactory.isDirect(qy))
      throw new RuntimeException("Argument \"qy\" : Buffers passed to this method must all be either direct or indirect");
    if (fndiv != null && _direct != BufferFactory.isDirect(fndiv))
      throw new RuntimeException("Argument \"fndiv\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        fndiverg0(zmid, BufferFactory.getDirectBufferByteOffset(zmid), ztop, BufferFactory.getDirectBufferByteOffset(ztop), zbot, BufferFactory.getDirectBufferByteOffset(zbot), ptop, BufferFactory.getDirectBufferByteOffset(ptop), pbot, BufferFactory.getDirectBufferByteOffset(pbot), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), f, BufferFactory.getDirectBufferByteOffset(f), fnx, BufferFactory.getDirectBufferByteOffset(fnx), fny, BufferFactory.getDirectBufferByteOffset(fny), w1, BufferFactory.getDirectBufferByteOffset(w1), dtdx, BufferFactory.getDirectBufferByteOffset(dtdx), dtdy, BufferFactory.getDirectBufferByteOffset(dtdy), qx, BufferFactory.getDirectBufferByteOffset(qx), qy, BufferFactory.getDirectBufferByteOffset(qy), fndiv, BufferFactory.getDirectBufferByteOffset(fndiv));
    } else {
      fndiverg1(BufferFactory.getArray(zmid), BufferFactory.getIndirectBufferByteOffset(zmid), BufferFactory.getArray(ztop), BufferFactory.getIndirectBufferByteOffset(ztop), BufferFactory.getArray(zbot), BufferFactory.getIndirectBufferByteOffset(zbot), BufferFactory.getArray(ptop), BufferFactory.getIndirectBufferByteOffset(ptop), BufferFactory.getArray(pbot), BufferFactory.getIndirectBufferByteOffset(pbot), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(f), BufferFactory.getIndirectBufferByteOffset(f), BufferFactory.getArray(fnx), BufferFactory.getIndirectBufferByteOffset(fnx), BufferFactory.getArray(fny), BufferFactory.getIndirectBufferByteOffset(fny), BufferFactory.getArray(w1), BufferFactory.getIndirectBufferByteOffset(w1), BufferFactory.getArray(dtdx), BufferFactory.getIndirectBufferByteOffset(dtdx), BufferFactory.getArray(dtdy), BufferFactory.getIndirectBufferByteOffset(dtdy), BufferFactory.getArray(qx), BufferFactory.getIndirectBufferByteOffset(qx), BufferFactory.getArray(qy), BufferFactory.getIndirectBufferByteOffset(qy), BufferFactory.getArray(fndiv), BufferFactory.getIndirectBufferByteOffset(fndiv));
    }
  }

  /** Entry point to C language function: <br> <code> void fndiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fnx, float *  fny, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fndiv); </code>    */
  private static native void fndiverg0(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object fnx, int fnx_byte_offset, Object fny, int fny_byte_offset, Object w1, int w1_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset, Object fndiv, int fndiv_byte_offset);

  /** Entry point to C language function: <br> <code> void fndiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fnx, float *  fny, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fndiv); </code>    */
  private static native void fndiverg1(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object fnx, int fnx_byte_offset, Object fny, int fny_byte_offset, Object w1, int w1_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset, Object fndiv, int fndiv_byte_offset);

  /** Interface to C language function: <br> <code> void fndiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fnx, float *  fny, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fndiv); </code>    */
  public static void fndiverg(float[] zmid, int zmid_offset, float[] ztop, int ztop_offset, float[] zbot, int zbot_offset, float[] ptop, int ptop_offset, float[] pbot, int pbot_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] f, int f_offset, float[] fnx, int fnx_offset, float[] fny, int fny_offset, float[] w1, int w1_offset, float[] dtdx, int dtdx_offset, float[] dtdy, int dtdy_offset, float[] qx, int qx_offset, float[] qy, int qy_offset, float[] fndiv, int fndiv_offset)
  {
    if(zmid != null && zmid.length <= zmid_offset)
      throw new RuntimeException("array offset argument \"zmid_offset\" (" + zmid_offset + ") equals or exceeds array length (" + zmid.length + ")");
    if(ztop != null && ztop.length <= ztop_offset)
      throw new RuntimeException("array offset argument \"ztop_offset\" (" + ztop_offset + ") equals or exceeds array length (" + ztop.length + ")");
    if(zbot != null && zbot.length <= zbot_offset)
      throw new RuntimeException("array offset argument \"zbot_offset\" (" + zbot_offset + ") equals or exceeds array length (" + zbot.length + ")");
    if(ptop != null && ptop.length <= ptop_offset)
      throw new RuntimeException("array offset argument \"ptop_offset\" (" + ptop_offset + ") equals or exceeds array length (" + ptop.length + ")");
    if(pbot != null && pbot.length <= pbot_offset)
      throw new RuntimeException("array offset argument \"pbot_offset\" (" + pbot_offset + ") equals or exceeds array length (" + pbot.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(f != null && f.length <= f_offset)
      throw new RuntimeException("array offset argument \"f_offset\" (" + f_offset + ") equals or exceeds array length (" + f.length + ")");
    if(fnx != null && fnx.length <= fnx_offset)
      throw new RuntimeException("array offset argument \"fnx_offset\" (" + fnx_offset + ") equals or exceeds array length (" + fnx.length + ")");
    if(fny != null && fny.length <= fny_offset)
      throw new RuntimeException("array offset argument \"fny_offset\" (" + fny_offset + ") equals or exceeds array length (" + fny.length + ")");
    if(w1 != null && w1.length <= w1_offset)
      throw new RuntimeException("array offset argument \"w1_offset\" (" + w1_offset + ") equals or exceeds array length (" + w1.length + ")");
    if(dtdx != null && dtdx.length <= dtdx_offset)
      throw new RuntimeException("array offset argument \"dtdx_offset\" (" + dtdx_offset + ") equals or exceeds array length (" + dtdx.length + ")");
    if(dtdy != null && dtdy.length <= dtdy_offset)
      throw new RuntimeException("array offset argument \"dtdy_offset\" (" + dtdy_offset + ") equals or exceeds array length (" + dtdy.length + ")");
    if(qx != null && qx.length <= qx_offset)
      throw new RuntimeException("array offset argument \"qx_offset\" (" + qx_offset + ") equals or exceeds array length (" + qx.length + ")");
    if(qy != null && qy.length <= qy_offset)
      throw new RuntimeException("array offset argument \"qy_offset\" (" + qy_offset + ") equals or exceeds array length (" + qy.length + ")");
    if(fndiv != null && fndiv.length <= fndiv_offset)
      throw new RuntimeException("array offset argument \"fndiv_offset\" (" + fndiv_offset + ") equals or exceeds array length (" + fndiv.length + ")");
        fndiverg1(zmid, BufferFactory.SIZEOF_FLOAT * zmid_offset, ztop, BufferFactory.SIZEOF_FLOAT * ztop_offset, zbot, BufferFactory.SIZEOF_FLOAT * zbot_offset, ptop, BufferFactory.SIZEOF_FLOAT * ptop_offset, pbot, BufferFactory.SIZEOF_FLOAT * pbot_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, f, BufferFactory.SIZEOF_FLOAT * f_offset, fnx, BufferFactory.SIZEOF_FLOAT * fnx_offset, fny, BufferFactory.SIZEOF_FLOAT * fny_offset, w1, BufferFactory.SIZEOF_FLOAT * w1_offset, dtdx, BufferFactory.SIZEOF_FLOAT * dtdx_offset, dtdy, BufferFactory.SIZEOF_FLOAT * dtdy_offset, qx, BufferFactory.SIZEOF_FLOAT * qx_offset, qy, BufferFactory.SIZEOF_FLOAT * qy_offset, fndiv, BufferFactory.SIZEOF_FLOAT * fndiv_offset);

  }

  /** Interface to C language function: <br> <code> void forecast(int *  yr, int *  mon, int *  day, int *  hour, int *  min, char *  stnid, int *  snow, float *  slat, float *  slon, float *  p, float *  ht, float *  t, float *  td, int *  nlvls, float *  ftmax, int *  status); </code>    */
  public static void forecast(java.nio.IntBuffer yr, java.nio.IntBuffer mon, java.nio.IntBuffer day, java.nio.IntBuffer hour, java.nio.IntBuffer min, java.nio.ByteBuffer stnid, java.nio.IntBuffer snow, java.nio.FloatBuffer slat, java.nio.FloatBuffer slon, java.nio.FloatBuffer p, java.nio.FloatBuffer ht, java.nio.FloatBuffer t, java.nio.FloatBuffer td, java.nio.IntBuffer nlvls, java.nio.FloatBuffer ftmax, java.nio.IntBuffer status)
  {
    boolean _direct = BufferFactory.isDirect(yr);
    if (mon != null && _direct != BufferFactory.isDirect(mon))
      throw new RuntimeException("Argument \"mon\" : Buffers passed to this method must all be either direct or indirect");
    if (day != null && _direct != BufferFactory.isDirect(day))
      throw new RuntimeException("Argument \"day\" : Buffers passed to this method must all be either direct or indirect");
    if (hour != null && _direct != BufferFactory.isDirect(hour))
      throw new RuntimeException("Argument \"hour\" : Buffers passed to this method must all be either direct or indirect");
    if (min != null && _direct != BufferFactory.isDirect(min))
      throw new RuntimeException("Argument \"min\" : Buffers passed to this method must all be either direct or indirect");
    if (stnid != null && _direct != BufferFactory.isDirect(stnid))
      throw new RuntimeException("Argument \"stnid\" : Buffers passed to this method must all be either direct or indirect");
    if (snow != null && _direct != BufferFactory.isDirect(snow))
      throw new RuntimeException("Argument \"snow\" : Buffers passed to this method must all be either direct or indirect");
    if (slat != null && _direct != BufferFactory.isDirect(slat))
      throw new RuntimeException("Argument \"slat\" : Buffers passed to this method must all be either direct or indirect");
    if (slon != null && _direct != BufferFactory.isDirect(slon))
      throw new RuntimeException("Argument \"slon\" : Buffers passed to this method must all be either direct or indirect");
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (ht != null && _direct != BufferFactory.isDirect(ht))
      throw new RuntimeException("Argument \"ht\" : Buffers passed to this method must all be either direct or indirect");
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (nlvls != null && _direct != BufferFactory.isDirect(nlvls))
      throw new RuntimeException("Argument \"nlvls\" : Buffers passed to this method must all be either direct or indirect");
    if (ftmax != null && _direct != BufferFactory.isDirect(ftmax))
      throw new RuntimeException("Argument \"ftmax\" : Buffers passed to this method must all be either direct or indirect");
    if (status != null && _direct != BufferFactory.isDirect(status))
      throw new RuntimeException("Argument \"status\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        forecast0(yr, BufferFactory.getDirectBufferByteOffset(yr), mon, BufferFactory.getDirectBufferByteOffset(mon), day, BufferFactory.getDirectBufferByteOffset(day), hour, BufferFactory.getDirectBufferByteOffset(hour), min, BufferFactory.getDirectBufferByteOffset(min), stnid, BufferFactory.getDirectBufferByteOffset(stnid), snow, BufferFactory.getDirectBufferByteOffset(snow), slat, BufferFactory.getDirectBufferByteOffset(slat), slon, BufferFactory.getDirectBufferByteOffset(slon), p, BufferFactory.getDirectBufferByteOffset(p), ht, BufferFactory.getDirectBufferByteOffset(ht), t, BufferFactory.getDirectBufferByteOffset(t), td, BufferFactory.getDirectBufferByteOffset(td), nlvls, BufferFactory.getDirectBufferByteOffset(nlvls), ftmax, BufferFactory.getDirectBufferByteOffset(ftmax), status, BufferFactory.getDirectBufferByteOffset(status));
    } else {
      forecast1(BufferFactory.getArray(yr), BufferFactory.getIndirectBufferByteOffset(yr), BufferFactory.getArray(mon), BufferFactory.getIndirectBufferByteOffset(mon), BufferFactory.getArray(day), BufferFactory.getIndirectBufferByteOffset(day), BufferFactory.getArray(hour), BufferFactory.getIndirectBufferByteOffset(hour), BufferFactory.getArray(min), BufferFactory.getIndirectBufferByteOffset(min), BufferFactory.getArray(stnid), BufferFactory.getIndirectBufferByteOffset(stnid), BufferFactory.getArray(snow), BufferFactory.getIndirectBufferByteOffset(snow), BufferFactory.getArray(slat), BufferFactory.getIndirectBufferByteOffset(slat), BufferFactory.getArray(slon), BufferFactory.getIndirectBufferByteOffset(slon), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(ht), BufferFactory.getIndirectBufferByteOffset(ht), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(nlvls), BufferFactory.getIndirectBufferByteOffset(nlvls), BufferFactory.getArray(ftmax), BufferFactory.getIndirectBufferByteOffset(ftmax), BufferFactory.getArray(status), BufferFactory.getIndirectBufferByteOffset(status));
    }
  }

  /** Entry point to C language function: <br> <code> void forecast(int *  yr, int *  mon, int *  day, int *  hour, int *  min, char *  stnid, int *  snow, float *  slat, float *  slon, float *  p, float *  ht, float *  t, float *  td, int *  nlvls, float *  ftmax, int *  status); </code>    */
  private static native void forecast0(Object yr, int yr_byte_offset, Object mon, int mon_byte_offset, Object day, int day_byte_offset, Object hour, int hour_byte_offset, Object min, int min_byte_offset, Object stnid, int stnid_byte_offset, Object snow, int snow_byte_offset, Object slat, int slat_byte_offset, Object slon, int slon_byte_offset, Object p, int p_byte_offset, Object ht, int ht_byte_offset, Object t, int t_byte_offset, Object td, int td_byte_offset, Object nlvls, int nlvls_byte_offset, Object ftmax, int ftmax_byte_offset, Object status, int status_byte_offset);

  /** Entry point to C language function: <br> <code> void forecast(int *  yr, int *  mon, int *  day, int *  hour, int *  min, char *  stnid, int *  snow, float *  slat, float *  slon, float *  p, float *  ht, float *  t, float *  td, int *  nlvls, float *  ftmax, int *  status); </code>    */
  private static native void forecast1(Object yr, int yr_byte_offset, Object mon, int mon_byte_offset, Object day, int day_byte_offset, Object hour, int hour_byte_offset, Object min, int min_byte_offset, Object stnid, int stnid_byte_offset, Object snow, int snow_byte_offset, Object slat, int slat_byte_offset, Object slon, int slon_byte_offset, Object p, int p_byte_offset, Object ht, int ht_byte_offset, Object t, int t_byte_offset, Object td, int td_byte_offset, Object nlvls, int nlvls_byte_offset, Object ftmax, int ftmax_byte_offset, Object status, int status_byte_offset);

  /** Interface to C language function: <br> <code> void forecast(int *  yr, int *  mon, int *  day, int *  hour, int *  min, char *  stnid, int *  snow, float *  slat, float *  slon, float *  p, float *  ht, float *  t, float *  td, int *  nlvls, float *  ftmax, int *  status); </code>    */
  public static void forecast(int[] yr, int yr_offset, int[] mon, int mon_offset, int[] day, int day_offset, int[] hour, int hour_offset, int[] min, int min_offset, byte[] stnid, int stnid_offset, int[] snow, int snow_offset, float[] slat, int slat_offset, float[] slon, int slon_offset, float[] p, int p_offset, float[] ht, int ht_offset, float[] t, int t_offset, float[] td, int td_offset, int[] nlvls, int nlvls_offset, float[] ftmax, int ftmax_offset, int[] status, int status_offset)
  {
    if(yr != null && yr.length <= yr_offset)
      throw new RuntimeException("array offset argument \"yr_offset\" (" + yr_offset + ") equals or exceeds array length (" + yr.length + ")");
    if(mon != null && mon.length <= mon_offset)
      throw new RuntimeException("array offset argument \"mon_offset\" (" + mon_offset + ") equals or exceeds array length (" + mon.length + ")");
    if(day != null && day.length <= day_offset)
      throw new RuntimeException("array offset argument \"day_offset\" (" + day_offset + ") equals or exceeds array length (" + day.length + ")");
    if(hour != null && hour.length <= hour_offset)
      throw new RuntimeException("array offset argument \"hour_offset\" (" + hour_offset + ") equals or exceeds array length (" + hour.length + ")");
    if(min != null && min.length <= min_offset)
      throw new RuntimeException("array offset argument \"min_offset\" (" + min_offset + ") equals or exceeds array length (" + min.length + ")");
    if(stnid != null && stnid.length <= stnid_offset)
      throw new RuntimeException("array offset argument \"stnid_offset\" (" + stnid_offset + ") equals or exceeds array length (" + stnid.length + ")");
    if(snow != null && snow.length <= snow_offset)
      throw new RuntimeException("array offset argument \"snow_offset\" (" + snow_offset + ") equals or exceeds array length (" + snow.length + ")");
    if(slat != null && slat.length <= slat_offset)
      throw new RuntimeException("array offset argument \"slat_offset\" (" + slat_offset + ") equals or exceeds array length (" + slat.length + ")");
    if(slon != null && slon.length <= slon_offset)
      throw new RuntimeException("array offset argument \"slon_offset\" (" + slon_offset + ") equals or exceeds array length (" + slon.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(ht != null && ht.length <= ht_offset)
      throw new RuntimeException("array offset argument \"ht_offset\" (" + ht_offset + ") equals or exceeds array length (" + ht.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(nlvls != null && nlvls.length <= nlvls_offset)
      throw new RuntimeException("array offset argument \"nlvls_offset\" (" + nlvls_offset + ") equals or exceeds array length (" + nlvls.length + ")");
    if(ftmax != null && ftmax.length <= ftmax_offset)
      throw new RuntimeException("array offset argument \"ftmax_offset\" (" + ftmax_offset + ") equals or exceeds array length (" + ftmax.length + ")");
    if(status != null && status.length <= status_offset)
      throw new RuntimeException("array offset argument \"status_offset\" (" + status_offset + ") equals or exceeds array length (" + status.length + ")");
        forecast1(yr, BufferFactory.SIZEOF_INT * yr_offset, mon, BufferFactory.SIZEOF_INT * mon_offset, day, BufferFactory.SIZEOF_INT * day_offset, hour, BufferFactory.SIZEOF_INT * hour_offset, min, BufferFactory.SIZEOF_INT * min_offset, stnid, stnid_offset, snow, BufferFactory.SIZEOF_INT * snow_offset, slat, BufferFactory.SIZEOF_FLOAT * slat_offset, slon, BufferFactory.SIZEOF_FLOAT * slon_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset, ht, BufferFactory.SIZEOF_FLOAT * ht_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, nlvls, BufferFactory.SIZEOF_INT * nlvls_offset, ftmax, BufferFactory.SIZEOF_FLOAT * ftmax_offset, status, BufferFactory.SIZEOF_INT * status_offset);

  }

  /** Interface to C language function: <br> <code> void fortconbuf(float *  Array, int *  Work, int *  mnx, int *  nx, int *  ny, float *  scale, float *  offset, int *  mode, float *  seed, float *  xpoints, float *  ypoints, int *  npoints, float *  badlo, float *  badhi, int *  status); </code>    */
  public static void fortconbuf(java.nio.FloatBuffer Array, java.nio.IntBuffer Work, java.nio.IntBuffer mnx, java.nio.IntBuffer nx, java.nio.IntBuffer ny, java.nio.FloatBuffer scale, java.nio.FloatBuffer offset, java.nio.IntBuffer mode, java.nio.FloatBuffer seed, java.nio.FloatBuffer xpoints, java.nio.FloatBuffer ypoints, java.nio.IntBuffer npoints, java.nio.FloatBuffer badlo, java.nio.FloatBuffer badhi, java.nio.IntBuffer status)
  {
    boolean _direct = BufferFactory.isDirect(Array);
    if (Work != null && _direct != BufferFactory.isDirect(Work))
      throw new RuntimeException("Argument \"Work\" : Buffers passed to this method must all be either direct or indirect");
    if (mnx != null && _direct != BufferFactory.isDirect(mnx))
      throw new RuntimeException("Argument \"mnx\" : Buffers passed to this method must all be either direct or indirect");
    if (nx != null && _direct != BufferFactory.isDirect(nx))
      throw new RuntimeException("Argument \"nx\" : Buffers passed to this method must all be either direct or indirect");
    if (ny != null && _direct != BufferFactory.isDirect(ny))
      throw new RuntimeException("Argument \"ny\" : Buffers passed to this method must all be either direct or indirect");
    if (scale != null && _direct != BufferFactory.isDirect(scale))
      throw new RuntimeException("Argument \"scale\" : Buffers passed to this method must all be either direct or indirect");
    if (offset != null && _direct != BufferFactory.isDirect(offset))
      throw new RuntimeException("Argument \"offset\" : Buffers passed to this method must all be either direct or indirect");
    if (mode != null && _direct != BufferFactory.isDirect(mode))
      throw new RuntimeException("Argument \"mode\" : Buffers passed to this method must all be either direct or indirect");
    if (seed != null && _direct != BufferFactory.isDirect(seed))
      throw new RuntimeException("Argument \"seed\" : Buffers passed to this method must all be either direct or indirect");
    if (xpoints != null && _direct != BufferFactory.isDirect(xpoints))
      throw new RuntimeException("Argument \"xpoints\" : Buffers passed to this method must all be either direct or indirect");
    if (ypoints != null && _direct != BufferFactory.isDirect(ypoints))
      throw new RuntimeException("Argument \"ypoints\" : Buffers passed to this method must all be either direct or indirect");
    if (npoints != null && _direct != BufferFactory.isDirect(npoints))
      throw new RuntimeException("Argument \"npoints\" : Buffers passed to this method must all be either direct or indirect");
    if (badlo != null && _direct != BufferFactory.isDirect(badlo))
      throw new RuntimeException("Argument \"badlo\" : Buffers passed to this method must all be either direct or indirect");
    if (badhi != null && _direct != BufferFactory.isDirect(badhi))
      throw new RuntimeException("Argument \"badhi\" : Buffers passed to this method must all be either direct or indirect");
    if (status != null && _direct != BufferFactory.isDirect(status))
      throw new RuntimeException("Argument \"status\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        fortconbuf0(Array, BufferFactory.getDirectBufferByteOffset(Array), Work, BufferFactory.getDirectBufferByteOffset(Work), mnx, BufferFactory.getDirectBufferByteOffset(mnx), nx, BufferFactory.getDirectBufferByteOffset(nx), ny, BufferFactory.getDirectBufferByteOffset(ny), scale, BufferFactory.getDirectBufferByteOffset(scale), offset, BufferFactory.getDirectBufferByteOffset(offset), mode, BufferFactory.getDirectBufferByteOffset(mode), seed, BufferFactory.getDirectBufferByteOffset(seed), xpoints, BufferFactory.getDirectBufferByteOffset(xpoints), ypoints, BufferFactory.getDirectBufferByteOffset(ypoints), npoints, BufferFactory.getDirectBufferByteOffset(npoints), badlo, BufferFactory.getDirectBufferByteOffset(badlo), badhi, BufferFactory.getDirectBufferByteOffset(badhi), status, BufferFactory.getDirectBufferByteOffset(status));
    } else {
      fortconbuf1(BufferFactory.getArray(Array), BufferFactory.getIndirectBufferByteOffset(Array), BufferFactory.getArray(Work), BufferFactory.getIndirectBufferByteOffset(Work), BufferFactory.getArray(mnx), BufferFactory.getIndirectBufferByteOffset(mnx), BufferFactory.getArray(nx), BufferFactory.getIndirectBufferByteOffset(nx), BufferFactory.getArray(ny), BufferFactory.getIndirectBufferByteOffset(ny), BufferFactory.getArray(scale), BufferFactory.getIndirectBufferByteOffset(scale), BufferFactory.getArray(offset), BufferFactory.getIndirectBufferByteOffset(offset), BufferFactory.getArray(mode), BufferFactory.getIndirectBufferByteOffset(mode), BufferFactory.getArray(seed), BufferFactory.getIndirectBufferByteOffset(seed), BufferFactory.getArray(xpoints), BufferFactory.getIndirectBufferByteOffset(xpoints), BufferFactory.getArray(ypoints), BufferFactory.getIndirectBufferByteOffset(ypoints), BufferFactory.getArray(npoints), BufferFactory.getIndirectBufferByteOffset(npoints), BufferFactory.getArray(badlo), BufferFactory.getIndirectBufferByteOffset(badlo), BufferFactory.getArray(badhi), BufferFactory.getIndirectBufferByteOffset(badhi), BufferFactory.getArray(status), BufferFactory.getIndirectBufferByteOffset(status));
    }
  }

  /** Entry point to C language function: <br> <code> void fortconbuf(float *  Array, int *  Work, int *  mnx, int *  nx, int *  ny, float *  scale, float *  offset, int *  mode, float *  seed, float *  xpoints, float *  ypoints, int *  npoints, float *  badlo, float *  badhi, int *  status); </code>    */
  private static native void fortconbuf0(Object Array, int Array_byte_offset, Object Work, int Work_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object scale, int scale_byte_offset, Object offset, int offset_byte_offset, Object mode, int mode_byte_offset, Object seed, int seed_byte_offset, Object xpoints, int xpoints_byte_offset, Object ypoints, int ypoints_byte_offset, Object npoints, int npoints_byte_offset, Object badlo, int badlo_byte_offset, Object badhi, int badhi_byte_offset, Object status, int status_byte_offset);

  /** Entry point to C language function: <br> <code> void fortconbuf(float *  Array, int *  Work, int *  mnx, int *  nx, int *  ny, float *  scale, float *  offset, int *  mode, float *  seed, float *  xpoints, float *  ypoints, int *  npoints, float *  badlo, float *  badhi, int *  status); </code>    */
  private static native void fortconbuf1(Object Array, int Array_byte_offset, Object Work, int Work_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object scale, int scale_byte_offset, Object offset, int offset_byte_offset, Object mode, int mode_byte_offset, Object seed, int seed_byte_offset, Object xpoints, int xpoints_byte_offset, Object ypoints, int ypoints_byte_offset, Object npoints, int npoints_byte_offset, Object badlo, int badlo_byte_offset, Object badhi, int badhi_byte_offset, Object status, int status_byte_offset);

  /** Interface to C language function: <br> <code> void fortconbuf(float *  Array, int *  Work, int *  mnx, int *  nx, int *  ny, float *  scale, float *  offset, int *  mode, float *  seed, float *  xpoints, float *  ypoints, int *  npoints, float *  badlo, float *  badhi, int *  status); </code>    */
  public static void fortconbuf(float[] Array, int Array_offset, int[] Work, int Work_offset, int[] mnx, int mnx_offset, int[] nx, int nx_offset, int[] ny, int ny_offset, float[] scale, int scale_offset, float[] offset, int offset_offset, int[] mode, int mode_offset, float[] seed, int seed_offset, float[] xpoints, int xpoints_offset, float[] ypoints, int ypoints_offset, int[] npoints, int npoints_offset, float[] badlo, int badlo_offset, float[] badhi, int badhi_offset, int[] status, int status_offset)
  {
    if(Array != null && Array.length <= Array_offset)
      throw new RuntimeException("array offset argument \"Array_offset\" (" + Array_offset + ") equals or exceeds array length (" + Array.length + ")");
    if(Work != null && Work.length <= Work_offset)
      throw new RuntimeException("array offset argument \"Work_offset\" (" + Work_offset + ") equals or exceeds array length (" + Work.length + ")");
    if(mnx != null && mnx.length <= mnx_offset)
      throw new RuntimeException("array offset argument \"mnx_offset\" (" + mnx_offset + ") equals or exceeds array length (" + mnx.length + ")");
    if(nx != null && nx.length <= nx_offset)
      throw new RuntimeException("array offset argument \"nx_offset\" (" + nx_offset + ") equals or exceeds array length (" + nx.length + ")");
    if(ny != null && ny.length <= ny_offset)
      throw new RuntimeException("array offset argument \"ny_offset\" (" + ny_offset + ") equals or exceeds array length (" + ny.length + ")");
    if(scale != null && scale.length <= scale_offset)
      throw new RuntimeException("array offset argument \"scale_offset\" (" + scale_offset + ") equals or exceeds array length (" + scale.length + ")");
    if(offset != null && offset.length <= offset_offset)
      throw new RuntimeException("array offset argument \"offset_offset\" (" + offset_offset + ") equals or exceeds array length (" + offset.length + ")");
    if(mode != null && mode.length <= mode_offset)
      throw new RuntimeException("array offset argument \"mode_offset\" (" + mode_offset + ") equals or exceeds array length (" + mode.length + ")");
    if(seed != null && seed.length <= seed_offset)
      throw new RuntimeException("array offset argument \"seed_offset\" (" + seed_offset + ") equals or exceeds array length (" + seed.length + ")");
    if(xpoints != null && xpoints.length <= xpoints_offset)
      throw new RuntimeException("array offset argument \"xpoints_offset\" (" + xpoints_offset + ") equals or exceeds array length (" + xpoints.length + ")");
    if(ypoints != null && ypoints.length <= ypoints_offset)
      throw new RuntimeException("array offset argument \"ypoints_offset\" (" + ypoints_offset + ") equals or exceeds array length (" + ypoints.length + ")");
    if(npoints != null && npoints.length <= npoints_offset)
      throw new RuntimeException("array offset argument \"npoints_offset\" (" + npoints_offset + ") equals or exceeds array length (" + npoints.length + ")");
    if(badlo != null && badlo.length <= badlo_offset)
      throw new RuntimeException("array offset argument \"badlo_offset\" (" + badlo_offset + ") equals or exceeds array length (" + badlo.length + ")");
    if(badhi != null && badhi.length <= badhi_offset)
      throw new RuntimeException("array offset argument \"badhi_offset\" (" + badhi_offset + ") equals or exceeds array length (" + badhi.length + ")");
    if(status != null && status.length <= status_offset)
      throw new RuntimeException("array offset argument \"status_offset\" (" + status_offset + ") equals or exceeds array length (" + status.length + ")");
        fortconbuf1(Array, BufferFactory.SIZEOF_FLOAT * Array_offset, Work, BufferFactory.SIZEOF_INT * Work_offset, mnx, BufferFactory.SIZEOF_INT * mnx_offset, nx, BufferFactory.SIZEOF_INT * nx_offset, ny, BufferFactory.SIZEOF_INT * ny_offset, scale, BufferFactory.SIZEOF_FLOAT * scale_offset, offset, BufferFactory.SIZEOF_FLOAT * offset_offset, mode, BufferFactory.SIZEOF_INT * mode_offset, seed, BufferFactory.SIZEOF_FLOAT * seed_offset, xpoints, BufferFactory.SIZEOF_FLOAT * xpoints_offset, ypoints, BufferFactory.SIZEOF_FLOAT * ypoints_offset, npoints, BufferFactory.SIZEOF_INT * npoints_offset, badlo, BufferFactory.SIZEOF_FLOAT * badlo_offset, badhi, BufferFactory.SIZEOF_FLOAT * badhi_offset, status, BufferFactory.SIZEOF_INT * status_offset);

  }

  /** Interface to C language function: <br> <code> void frontogen(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fgen); </code>    */
  public static void frontogen(java.nio.FloatBuffer zmid, java.nio.FloatBuffer ztop, java.nio.FloatBuffer zbot, java.nio.FloatBuffer ptop, java.nio.FloatBuffer pbot, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer f, java.nio.FloatBuffer w1, java.nio.FloatBuffer w2, java.nio.FloatBuffer w3, java.nio.FloatBuffer dtdx, java.nio.FloatBuffer dtdy, java.nio.FloatBuffer qx, java.nio.FloatBuffer qy, java.nio.FloatBuffer fgen)
  {
    boolean _direct = BufferFactory.isDirect(zmid);
    if (ztop != null && _direct != BufferFactory.isDirect(ztop))
      throw new RuntimeException("Argument \"ztop\" : Buffers passed to this method must all be either direct or indirect");
    if (zbot != null && _direct != BufferFactory.isDirect(zbot))
      throw new RuntimeException("Argument \"zbot\" : Buffers passed to this method must all be either direct or indirect");
    if (ptop != null && _direct != BufferFactory.isDirect(ptop))
      throw new RuntimeException("Argument \"ptop\" : Buffers passed to this method must all be either direct or indirect");
    if (pbot != null && _direct != BufferFactory.isDirect(pbot))
      throw new RuntimeException("Argument \"pbot\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (f != null && _direct != BufferFactory.isDirect(f))
      throw new RuntimeException("Argument \"f\" : Buffers passed to this method must all be either direct or indirect");
    if (w1 != null && _direct != BufferFactory.isDirect(w1))
      throw new RuntimeException("Argument \"w1\" : Buffers passed to this method must all be either direct or indirect");
    if (w2 != null && _direct != BufferFactory.isDirect(w2))
      throw new RuntimeException("Argument \"w2\" : Buffers passed to this method must all be either direct or indirect");
    if (w3 != null && _direct != BufferFactory.isDirect(w3))
      throw new RuntimeException("Argument \"w3\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx != null && _direct != BufferFactory.isDirect(dtdx))
      throw new RuntimeException("Argument \"dtdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy != null && _direct != BufferFactory.isDirect(dtdy))
      throw new RuntimeException("Argument \"dtdy\" : Buffers passed to this method must all be either direct or indirect");
    if (qx != null && _direct != BufferFactory.isDirect(qx))
      throw new RuntimeException("Argument \"qx\" : Buffers passed to this method must all be either direct or indirect");
    if (qy != null && _direct != BufferFactory.isDirect(qy))
      throw new RuntimeException("Argument \"qy\" : Buffers passed to this method must all be either direct or indirect");
    if (fgen != null && _direct != BufferFactory.isDirect(fgen))
      throw new RuntimeException("Argument \"fgen\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        frontogen0(zmid, BufferFactory.getDirectBufferByteOffset(zmid), ztop, BufferFactory.getDirectBufferByteOffset(ztop), zbot, BufferFactory.getDirectBufferByteOffset(zbot), ptop, BufferFactory.getDirectBufferByteOffset(ptop), pbot, BufferFactory.getDirectBufferByteOffset(pbot), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), f, BufferFactory.getDirectBufferByteOffset(f), w1, BufferFactory.getDirectBufferByteOffset(w1), w2, BufferFactory.getDirectBufferByteOffset(w2), w3, BufferFactory.getDirectBufferByteOffset(w3), dtdx, BufferFactory.getDirectBufferByteOffset(dtdx), dtdy, BufferFactory.getDirectBufferByteOffset(dtdy), qx, BufferFactory.getDirectBufferByteOffset(qx), qy, BufferFactory.getDirectBufferByteOffset(qy), fgen, BufferFactory.getDirectBufferByteOffset(fgen));
    } else {
      frontogen1(BufferFactory.getArray(zmid), BufferFactory.getIndirectBufferByteOffset(zmid), BufferFactory.getArray(ztop), BufferFactory.getIndirectBufferByteOffset(ztop), BufferFactory.getArray(zbot), BufferFactory.getIndirectBufferByteOffset(zbot), BufferFactory.getArray(ptop), BufferFactory.getIndirectBufferByteOffset(ptop), BufferFactory.getArray(pbot), BufferFactory.getIndirectBufferByteOffset(pbot), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(f), BufferFactory.getIndirectBufferByteOffset(f), BufferFactory.getArray(w1), BufferFactory.getIndirectBufferByteOffset(w1), BufferFactory.getArray(w2), BufferFactory.getIndirectBufferByteOffset(w2), BufferFactory.getArray(w3), BufferFactory.getIndirectBufferByteOffset(w3), BufferFactory.getArray(dtdx), BufferFactory.getIndirectBufferByteOffset(dtdx), BufferFactory.getArray(dtdy), BufferFactory.getIndirectBufferByteOffset(dtdy), BufferFactory.getArray(qx), BufferFactory.getIndirectBufferByteOffset(qx), BufferFactory.getArray(qy), BufferFactory.getIndirectBufferByteOffset(qy), BufferFactory.getArray(fgen), BufferFactory.getIndirectBufferByteOffset(fgen));
    }
  }

  /** Entry point to C language function: <br> <code> void frontogen(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fgen); </code>    */
  private static native void frontogen0(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object w1, int w1_byte_offset, Object w2, int w2_byte_offset, Object w3, int w3_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset, Object fgen, int fgen_byte_offset);

  /** Entry point to C language function: <br> <code> void frontogen(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fgen); </code>    */
  private static native void frontogen1(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object w1, int w1_byte_offset, Object w2, int w2_byte_offset, Object w3, int w3_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset, Object fgen, int fgen_byte_offset);

  /** Interface to C language function: <br> <code> void frontogen(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fgen); </code>    */
  public static void frontogen(float[] zmid, int zmid_offset, float[] ztop, int ztop_offset, float[] zbot, int zbot_offset, float[] ptop, int ptop_offset, float[] pbot, int pbot_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] f, int f_offset, float[] w1, int w1_offset, float[] w2, int w2_offset, float[] w3, int w3_offset, float[] dtdx, int dtdx_offset, float[] dtdy, int dtdy_offset, float[] qx, int qx_offset, float[] qy, int qy_offset, float[] fgen, int fgen_offset)
  {
    if(zmid != null && zmid.length <= zmid_offset)
      throw new RuntimeException("array offset argument \"zmid_offset\" (" + zmid_offset + ") equals or exceeds array length (" + zmid.length + ")");
    if(ztop != null && ztop.length <= ztop_offset)
      throw new RuntimeException("array offset argument \"ztop_offset\" (" + ztop_offset + ") equals or exceeds array length (" + ztop.length + ")");
    if(zbot != null && zbot.length <= zbot_offset)
      throw new RuntimeException("array offset argument \"zbot_offset\" (" + zbot_offset + ") equals or exceeds array length (" + zbot.length + ")");
    if(ptop != null && ptop.length <= ptop_offset)
      throw new RuntimeException("array offset argument \"ptop_offset\" (" + ptop_offset + ") equals or exceeds array length (" + ptop.length + ")");
    if(pbot != null && pbot.length <= pbot_offset)
      throw new RuntimeException("array offset argument \"pbot_offset\" (" + pbot_offset + ") equals or exceeds array length (" + pbot.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(f != null && f.length <= f_offset)
      throw new RuntimeException("array offset argument \"f_offset\" (" + f_offset + ") equals or exceeds array length (" + f.length + ")");
    if(w1 != null && w1.length <= w1_offset)
      throw new RuntimeException("array offset argument \"w1_offset\" (" + w1_offset + ") equals or exceeds array length (" + w1.length + ")");
    if(w2 != null && w2.length <= w2_offset)
      throw new RuntimeException("array offset argument \"w2_offset\" (" + w2_offset + ") equals or exceeds array length (" + w2.length + ")");
    if(w3 != null && w3.length <= w3_offset)
      throw new RuntimeException("array offset argument \"w3_offset\" (" + w3_offset + ") equals or exceeds array length (" + w3.length + ")");
    if(dtdx != null && dtdx.length <= dtdx_offset)
      throw new RuntimeException("array offset argument \"dtdx_offset\" (" + dtdx_offset + ") equals or exceeds array length (" + dtdx.length + ")");
    if(dtdy != null && dtdy.length <= dtdy_offset)
      throw new RuntimeException("array offset argument \"dtdy_offset\" (" + dtdy_offset + ") equals or exceeds array length (" + dtdy.length + ")");
    if(qx != null && qx.length <= qx_offset)
      throw new RuntimeException("array offset argument \"qx_offset\" (" + qx_offset + ") equals or exceeds array length (" + qx.length + ")");
    if(qy != null && qy.length <= qy_offset)
      throw new RuntimeException("array offset argument \"qy_offset\" (" + qy_offset + ") equals or exceeds array length (" + qy.length + ")");
    if(fgen != null && fgen.length <= fgen_offset)
      throw new RuntimeException("array offset argument \"fgen_offset\" (" + fgen_offset + ") equals or exceeds array length (" + fgen.length + ")");
        frontogen1(zmid, BufferFactory.SIZEOF_FLOAT * zmid_offset, ztop, BufferFactory.SIZEOF_FLOAT * ztop_offset, zbot, BufferFactory.SIZEOF_FLOAT * zbot_offset, ptop, BufferFactory.SIZEOF_FLOAT * ptop_offset, pbot, BufferFactory.SIZEOF_FLOAT * pbot_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, f, BufferFactory.SIZEOF_FLOAT * f_offset, w1, BufferFactory.SIZEOF_FLOAT * w1_offset, w2, BufferFactory.SIZEOF_FLOAT * w2_offset, w3, BufferFactory.SIZEOF_FLOAT * w3_offset, dtdx, BufferFactory.SIZEOF_FLOAT * dtdx_offset, dtdy, BufferFactory.SIZEOF_FLOAT * dtdy_offset, qx, BufferFactory.SIZEOF_FLOAT * qx_offset, qy, BufferFactory.SIZEOF_FLOAT * qy_offset, fgen, BufferFactory.SIZEOF_FLOAT * fgen_offset);

  }

  /** Interface to C language function: <br> <code> void frzlev(float *  ELEV, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PFRZ, float *  HFRZ); </code>    */
  public static void frzlev(java.nio.FloatBuffer ELEV, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer T, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer PFRZ, java.nio.FloatBuffer HFRZ)
  {
    boolean _direct = BufferFactory.isDirect(ELEV);
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (PFRZ != null && _direct != BufferFactory.isDirect(PFRZ))
      throw new RuntimeException("Argument \"PFRZ\" : Buffers passed to this method must all be either direct or indirect");
    if (HFRZ != null && _direct != BufferFactory.isDirect(HFRZ))
      throw new RuntimeException("Argument \"HFRZ\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        frzlev0(ELEV, BufferFactory.getDirectBufferByteOffset(ELEV), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), T, BufferFactory.getDirectBufferByteOffset(T), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), PFRZ, BufferFactory.getDirectBufferByteOffset(PFRZ), HFRZ, BufferFactory.getDirectBufferByteOffset(HFRZ));
    } else {
      frzlev1(BufferFactory.getArray(ELEV), BufferFactory.getIndirectBufferByteOffset(ELEV), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(PFRZ), BufferFactory.getIndirectBufferByteOffset(PFRZ), BufferFactory.getArray(HFRZ), BufferFactory.getIndirectBufferByteOffset(HFRZ));
    }
  }

  /** Entry point to C language function: <br> <code> void frzlev(float *  ELEV, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PFRZ, float *  HFRZ); </code>    */
  private static native void frzlev0(Object ELEV, int ELEV_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PFRZ, int PFRZ_byte_offset, Object HFRZ, int HFRZ_byte_offset);

  /** Entry point to C language function: <br> <code> void frzlev(float *  ELEV, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PFRZ, float *  HFRZ); </code>    */
  private static native void frzlev1(Object ELEV, int ELEV_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PFRZ, int PFRZ_byte_offset, Object HFRZ, int HFRZ_byte_offset);

  /** Interface to C language function: <br> <code> void frzlev(float *  ELEV, float *  P, float *  HT, float *  T, int *  NLVLS, float *  PFRZ, float *  HFRZ); </code>    */
  public static void frzlev(float[] ELEV, int ELEV_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] T, int T_offset, int[] NLVLS, int NLVLS_offset, float[] PFRZ, int PFRZ_offset, float[] HFRZ, int HFRZ_offset)
  {
    if(ELEV != null && ELEV.length <= ELEV_offset)
      throw new RuntimeException("array offset argument \"ELEV_offset\" (" + ELEV_offset + ") equals or exceeds array length (" + ELEV.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(PFRZ != null && PFRZ.length <= PFRZ_offset)
      throw new RuntimeException("array offset argument \"PFRZ_offset\" (" + PFRZ_offset + ") equals or exceeds array length (" + PFRZ.length + ")");
    if(HFRZ != null && HFRZ.length <= HFRZ_offset)
      throw new RuntimeException("array offset argument \"HFRZ_offset\" (" + HFRZ_offset + ") equals or exceeds array length (" + HFRZ.length + ")");
        frzlev1(ELEV, BufferFactory.SIZEOF_FLOAT * ELEV_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, PFRZ, BufferFactory.SIZEOF_FLOAT * PFRZ_offset, HFRZ, BufferFactory.SIZEOF_FLOAT * HFRZ_offset);

  }

  /** Interface to C language function: <br> <code> void fsdiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fsx, float *  fsy, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fsdiv); </code>    */
  public static void fsdiverg(java.nio.FloatBuffer zmid, java.nio.FloatBuffer ztop, java.nio.FloatBuffer zbot, java.nio.FloatBuffer ptop, java.nio.FloatBuffer pbot, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer f, java.nio.FloatBuffer fsx, java.nio.FloatBuffer fsy, java.nio.FloatBuffer w1, java.nio.FloatBuffer dtdx, java.nio.FloatBuffer dtdy, java.nio.FloatBuffer qx, java.nio.FloatBuffer qy, java.nio.FloatBuffer fsdiv)
  {
    boolean _direct = BufferFactory.isDirect(zmid);
    if (ztop != null && _direct != BufferFactory.isDirect(ztop))
      throw new RuntimeException("Argument \"ztop\" : Buffers passed to this method must all be either direct or indirect");
    if (zbot != null && _direct != BufferFactory.isDirect(zbot))
      throw new RuntimeException("Argument \"zbot\" : Buffers passed to this method must all be either direct or indirect");
    if (ptop != null && _direct != BufferFactory.isDirect(ptop))
      throw new RuntimeException("Argument \"ptop\" : Buffers passed to this method must all be either direct or indirect");
    if (pbot != null && _direct != BufferFactory.isDirect(pbot))
      throw new RuntimeException("Argument \"pbot\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (f != null && _direct != BufferFactory.isDirect(f))
      throw new RuntimeException("Argument \"f\" : Buffers passed to this method must all be either direct or indirect");
    if (fsx != null && _direct != BufferFactory.isDirect(fsx))
      throw new RuntimeException("Argument \"fsx\" : Buffers passed to this method must all be either direct or indirect");
    if (fsy != null && _direct != BufferFactory.isDirect(fsy))
      throw new RuntimeException("Argument \"fsy\" : Buffers passed to this method must all be either direct or indirect");
    if (w1 != null && _direct != BufferFactory.isDirect(w1))
      throw new RuntimeException("Argument \"w1\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx != null && _direct != BufferFactory.isDirect(dtdx))
      throw new RuntimeException("Argument \"dtdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy != null && _direct != BufferFactory.isDirect(dtdy))
      throw new RuntimeException("Argument \"dtdy\" : Buffers passed to this method must all be either direct or indirect");
    if (qx != null && _direct != BufferFactory.isDirect(qx))
      throw new RuntimeException("Argument \"qx\" : Buffers passed to this method must all be either direct or indirect");
    if (qy != null && _direct != BufferFactory.isDirect(qy))
      throw new RuntimeException("Argument \"qy\" : Buffers passed to this method must all be either direct or indirect");
    if (fsdiv != null && _direct != BufferFactory.isDirect(fsdiv))
      throw new RuntimeException("Argument \"fsdiv\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        fsdiverg0(zmid, BufferFactory.getDirectBufferByteOffset(zmid), ztop, BufferFactory.getDirectBufferByteOffset(ztop), zbot, BufferFactory.getDirectBufferByteOffset(zbot), ptop, BufferFactory.getDirectBufferByteOffset(ptop), pbot, BufferFactory.getDirectBufferByteOffset(pbot), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), f, BufferFactory.getDirectBufferByteOffset(f), fsx, BufferFactory.getDirectBufferByteOffset(fsx), fsy, BufferFactory.getDirectBufferByteOffset(fsy), w1, BufferFactory.getDirectBufferByteOffset(w1), dtdx, BufferFactory.getDirectBufferByteOffset(dtdx), dtdy, BufferFactory.getDirectBufferByteOffset(dtdy), qx, BufferFactory.getDirectBufferByteOffset(qx), qy, BufferFactory.getDirectBufferByteOffset(qy), fsdiv, BufferFactory.getDirectBufferByteOffset(fsdiv));
    } else {
      fsdiverg1(BufferFactory.getArray(zmid), BufferFactory.getIndirectBufferByteOffset(zmid), BufferFactory.getArray(ztop), BufferFactory.getIndirectBufferByteOffset(ztop), BufferFactory.getArray(zbot), BufferFactory.getIndirectBufferByteOffset(zbot), BufferFactory.getArray(ptop), BufferFactory.getIndirectBufferByteOffset(ptop), BufferFactory.getArray(pbot), BufferFactory.getIndirectBufferByteOffset(pbot), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(f), BufferFactory.getIndirectBufferByteOffset(f), BufferFactory.getArray(fsx), BufferFactory.getIndirectBufferByteOffset(fsx), BufferFactory.getArray(fsy), BufferFactory.getIndirectBufferByteOffset(fsy), BufferFactory.getArray(w1), BufferFactory.getIndirectBufferByteOffset(w1), BufferFactory.getArray(dtdx), BufferFactory.getIndirectBufferByteOffset(dtdx), BufferFactory.getArray(dtdy), BufferFactory.getIndirectBufferByteOffset(dtdy), BufferFactory.getArray(qx), BufferFactory.getIndirectBufferByteOffset(qx), BufferFactory.getArray(qy), BufferFactory.getIndirectBufferByteOffset(qy), BufferFactory.getArray(fsdiv), BufferFactory.getIndirectBufferByteOffset(fsdiv));
    }
  }

  /** Entry point to C language function: <br> <code> void fsdiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fsx, float *  fsy, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fsdiv); </code>    */
  private static native void fsdiverg0(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object fsx, int fsx_byte_offset, Object fsy, int fsy_byte_offset, Object w1, int w1_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset, Object fsdiv, int fsdiv_byte_offset);

  /** Entry point to C language function: <br> <code> void fsdiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fsx, float *  fsy, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fsdiv); </code>    */
  private static native void fsdiverg1(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object fsx, int fsx_byte_offset, Object fsy, int fsy_byte_offset, Object w1, int w1_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset, Object fsdiv, int fsdiv_byte_offset);

  /** Interface to C language function: <br> <code> void fsdiverg(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  fsx, float *  fsy, float *  w1, float *  dtdx, float *  dtdy, float *  qx, float *  qy, float *  fsdiv); </code>    */
  public static void fsdiverg(float[] zmid, int zmid_offset, float[] ztop, int ztop_offset, float[] zbot, int zbot_offset, float[] ptop, int ptop_offset, float[] pbot, int pbot_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] f, int f_offset, float[] fsx, int fsx_offset, float[] fsy, int fsy_offset, float[] w1, int w1_offset, float[] dtdx, int dtdx_offset, float[] dtdy, int dtdy_offset, float[] qx, int qx_offset, float[] qy, int qy_offset, float[] fsdiv, int fsdiv_offset)
  {
    if(zmid != null && zmid.length <= zmid_offset)
      throw new RuntimeException("array offset argument \"zmid_offset\" (" + zmid_offset + ") equals or exceeds array length (" + zmid.length + ")");
    if(ztop != null && ztop.length <= ztop_offset)
      throw new RuntimeException("array offset argument \"ztop_offset\" (" + ztop_offset + ") equals or exceeds array length (" + ztop.length + ")");
    if(zbot != null && zbot.length <= zbot_offset)
      throw new RuntimeException("array offset argument \"zbot_offset\" (" + zbot_offset + ") equals or exceeds array length (" + zbot.length + ")");
    if(ptop != null && ptop.length <= ptop_offset)
      throw new RuntimeException("array offset argument \"ptop_offset\" (" + ptop_offset + ") equals or exceeds array length (" + ptop.length + ")");
    if(pbot != null && pbot.length <= pbot_offset)
      throw new RuntimeException("array offset argument \"pbot_offset\" (" + pbot_offset + ") equals or exceeds array length (" + pbot.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(f != null && f.length <= f_offset)
      throw new RuntimeException("array offset argument \"f_offset\" (" + f_offset + ") equals or exceeds array length (" + f.length + ")");
    if(fsx != null && fsx.length <= fsx_offset)
      throw new RuntimeException("array offset argument \"fsx_offset\" (" + fsx_offset + ") equals or exceeds array length (" + fsx.length + ")");
    if(fsy != null && fsy.length <= fsy_offset)
      throw new RuntimeException("array offset argument \"fsy_offset\" (" + fsy_offset + ") equals or exceeds array length (" + fsy.length + ")");
    if(w1 != null && w1.length <= w1_offset)
      throw new RuntimeException("array offset argument \"w1_offset\" (" + w1_offset + ") equals or exceeds array length (" + w1.length + ")");
    if(dtdx != null && dtdx.length <= dtdx_offset)
      throw new RuntimeException("array offset argument \"dtdx_offset\" (" + dtdx_offset + ") equals or exceeds array length (" + dtdx.length + ")");
    if(dtdy != null && dtdy.length <= dtdy_offset)
      throw new RuntimeException("array offset argument \"dtdy_offset\" (" + dtdy_offset + ") equals or exceeds array length (" + dtdy.length + ")");
    if(qx != null && qx.length <= qx_offset)
      throw new RuntimeException("array offset argument \"qx_offset\" (" + qx_offset + ") equals or exceeds array length (" + qx.length + ")");
    if(qy != null && qy.length <= qy_offset)
      throw new RuntimeException("array offset argument \"qy_offset\" (" + qy_offset + ") equals or exceeds array length (" + qy.length + ")");
    if(fsdiv != null && fsdiv.length <= fsdiv_offset)
      throw new RuntimeException("array offset argument \"fsdiv_offset\" (" + fsdiv_offset + ") equals or exceeds array length (" + fsdiv.length + ")");
        fsdiverg1(zmid, BufferFactory.SIZEOF_FLOAT * zmid_offset, ztop, BufferFactory.SIZEOF_FLOAT * ztop_offset, zbot, BufferFactory.SIZEOF_FLOAT * zbot_offset, ptop, BufferFactory.SIZEOF_FLOAT * ptop_offset, pbot, BufferFactory.SIZEOF_FLOAT * pbot_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, f, BufferFactory.SIZEOF_FLOAT * f_offset, fsx, BufferFactory.SIZEOF_FLOAT * fsx_offset, fsy, BufferFactory.SIZEOF_FLOAT * fsy_offset, w1, BufferFactory.SIZEOF_FLOAT * w1_offset, dtdx, BufferFactory.SIZEOF_FLOAT * dtdx_offset, dtdy, BufferFactory.SIZEOF_FLOAT * dtdy_offset, qx, BufferFactory.SIZEOF_FLOAT * qx_offset, qy, BufferFactory.SIZEOF_FLOAT * qy_offset, fsdiv, BufferFactory.SIZEOF_FLOAT * fsdiv_offset);

  }

  /** Interface to C language function: <br> <code> void g2gkinematics(float *  Udx, float *  Vdy, float *  Par, float *  SpaX, float *  SpaY, int *  mnx, int *  mny, int *  nx, int *  ny, int *  choice, float *  Scalar); </code>    */
  public static void g2gkinematics(java.nio.FloatBuffer Udx, java.nio.FloatBuffer Vdy, java.nio.FloatBuffer Par, java.nio.FloatBuffer SpaX, java.nio.FloatBuffer SpaY, java.nio.IntBuffer mnx, java.nio.IntBuffer mny, java.nio.IntBuffer nx, java.nio.IntBuffer ny, java.nio.IntBuffer choice, java.nio.FloatBuffer Scalar)
  {
    boolean _direct = BufferFactory.isDirect(Udx);
    if (Vdy != null && _direct != BufferFactory.isDirect(Vdy))
      throw new RuntimeException("Argument \"Vdy\" : Buffers passed to this method must all be either direct or indirect");
    if (Par != null && _direct != BufferFactory.isDirect(Par))
      throw new RuntimeException("Argument \"Par\" : Buffers passed to this method must all be either direct or indirect");
    if (SpaX != null && _direct != BufferFactory.isDirect(SpaX))
      throw new RuntimeException("Argument \"SpaX\" : Buffers passed to this method must all be either direct or indirect");
    if (SpaY != null && _direct != BufferFactory.isDirect(SpaY))
      throw new RuntimeException("Argument \"SpaY\" : Buffers passed to this method must all be either direct or indirect");
    if (mnx != null && _direct != BufferFactory.isDirect(mnx))
      throw new RuntimeException("Argument \"mnx\" : Buffers passed to this method must all be either direct or indirect");
    if (mny != null && _direct != BufferFactory.isDirect(mny))
      throw new RuntimeException("Argument \"mny\" : Buffers passed to this method must all be either direct or indirect");
    if (nx != null && _direct != BufferFactory.isDirect(nx))
      throw new RuntimeException("Argument \"nx\" : Buffers passed to this method must all be either direct or indirect");
    if (ny != null && _direct != BufferFactory.isDirect(ny))
      throw new RuntimeException("Argument \"ny\" : Buffers passed to this method must all be either direct or indirect");
    if (choice != null && _direct != BufferFactory.isDirect(choice))
      throw new RuntimeException("Argument \"choice\" : Buffers passed to this method must all be either direct or indirect");
    if (Scalar != null && _direct != BufferFactory.isDirect(Scalar))
      throw new RuntimeException("Argument \"Scalar\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        g2gkinematics0(Udx, BufferFactory.getDirectBufferByteOffset(Udx), Vdy, BufferFactory.getDirectBufferByteOffset(Vdy), Par, BufferFactory.getDirectBufferByteOffset(Par), SpaX, BufferFactory.getDirectBufferByteOffset(SpaX), SpaY, BufferFactory.getDirectBufferByteOffset(SpaY), mnx, BufferFactory.getDirectBufferByteOffset(mnx), mny, BufferFactory.getDirectBufferByteOffset(mny), nx, BufferFactory.getDirectBufferByteOffset(nx), ny, BufferFactory.getDirectBufferByteOffset(ny), choice, BufferFactory.getDirectBufferByteOffset(choice), Scalar, BufferFactory.getDirectBufferByteOffset(Scalar));
    } else {
      g2gkinematics1(BufferFactory.getArray(Udx), BufferFactory.getIndirectBufferByteOffset(Udx), BufferFactory.getArray(Vdy), BufferFactory.getIndirectBufferByteOffset(Vdy), BufferFactory.getArray(Par), BufferFactory.getIndirectBufferByteOffset(Par), BufferFactory.getArray(SpaX), BufferFactory.getIndirectBufferByteOffset(SpaX), BufferFactory.getArray(SpaY), BufferFactory.getIndirectBufferByteOffset(SpaY), BufferFactory.getArray(mnx), BufferFactory.getIndirectBufferByteOffset(mnx), BufferFactory.getArray(mny), BufferFactory.getIndirectBufferByteOffset(mny), BufferFactory.getArray(nx), BufferFactory.getIndirectBufferByteOffset(nx), BufferFactory.getArray(ny), BufferFactory.getIndirectBufferByteOffset(ny), BufferFactory.getArray(choice), BufferFactory.getIndirectBufferByteOffset(choice), BufferFactory.getArray(Scalar), BufferFactory.getIndirectBufferByteOffset(Scalar));
    }
  }

  /** Entry point to C language function: <br> <code> void g2gkinematics(float *  Udx, float *  Vdy, float *  Par, float *  SpaX, float *  SpaY, int *  mnx, int *  mny, int *  nx, int *  ny, int *  choice, float *  Scalar); </code>    */
  private static native void g2gkinematics0(Object Udx, int Udx_byte_offset, Object Vdy, int Vdy_byte_offset, Object Par, int Par_byte_offset, Object SpaX, int SpaX_byte_offset, Object SpaY, int SpaY_byte_offset, Object mnx, int mnx_byte_offset, Object mny, int mny_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object choice, int choice_byte_offset, Object Scalar, int Scalar_byte_offset);

  /** Entry point to C language function: <br> <code> void g2gkinematics(float *  Udx, float *  Vdy, float *  Par, float *  SpaX, float *  SpaY, int *  mnx, int *  mny, int *  nx, int *  ny, int *  choice, float *  Scalar); </code>    */
  private static native void g2gkinematics1(Object Udx, int Udx_byte_offset, Object Vdy, int Vdy_byte_offset, Object Par, int Par_byte_offset, Object SpaX, int SpaX_byte_offset, Object SpaY, int SpaY_byte_offset, Object mnx, int mnx_byte_offset, Object mny, int mny_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object choice, int choice_byte_offset, Object Scalar, int Scalar_byte_offset);

  /** Interface to C language function: <br> <code> void g2gkinematics(float *  Udx, float *  Vdy, float *  Par, float *  SpaX, float *  SpaY, int *  mnx, int *  mny, int *  nx, int *  ny, int *  choice, float *  Scalar); </code>    */
  public static void g2gkinematics(float[] Udx, int Udx_offset, float[] Vdy, int Vdy_offset, float[] Par, int Par_offset, float[] SpaX, int SpaX_offset, float[] SpaY, int SpaY_offset, int[] mnx, int mnx_offset, int[] mny, int mny_offset, int[] nx, int nx_offset, int[] ny, int ny_offset, int[] choice, int choice_offset, float[] Scalar, int Scalar_offset)
  {
    if(Udx != null && Udx.length <= Udx_offset)
      throw new RuntimeException("array offset argument \"Udx_offset\" (" + Udx_offset + ") equals or exceeds array length (" + Udx.length + ")");
    if(Vdy != null && Vdy.length <= Vdy_offset)
      throw new RuntimeException("array offset argument \"Vdy_offset\" (" + Vdy_offset + ") equals or exceeds array length (" + Vdy.length + ")");
    if(Par != null && Par.length <= Par_offset)
      throw new RuntimeException("array offset argument \"Par_offset\" (" + Par_offset + ") equals or exceeds array length (" + Par.length + ")");
    if(SpaX != null && SpaX.length <= SpaX_offset)
      throw new RuntimeException("array offset argument \"SpaX_offset\" (" + SpaX_offset + ") equals or exceeds array length (" + SpaX.length + ")");
    if(SpaY != null && SpaY.length <= SpaY_offset)
      throw new RuntimeException("array offset argument \"SpaY_offset\" (" + SpaY_offset + ") equals or exceeds array length (" + SpaY.length + ")");
    if(mnx != null && mnx.length <= mnx_offset)
      throw new RuntimeException("array offset argument \"mnx_offset\" (" + mnx_offset + ") equals or exceeds array length (" + mnx.length + ")");
    if(mny != null && mny.length <= mny_offset)
      throw new RuntimeException("array offset argument \"mny_offset\" (" + mny_offset + ") equals or exceeds array length (" + mny.length + ")");
    if(nx != null && nx.length <= nx_offset)
      throw new RuntimeException("array offset argument \"nx_offset\" (" + nx_offset + ") equals or exceeds array length (" + nx.length + ")");
    if(ny != null && ny.length <= ny_offset)
      throw new RuntimeException("array offset argument \"ny_offset\" (" + ny_offset + ") equals or exceeds array length (" + ny.length + ")");
    if(choice != null && choice.length <= choice_offset)
      throw new RuntimeException("array offset argument \"choice_offset\" (" + choice_offset + ") equals or exceeds array length (" + choice.length + ")");
    if(Scalar != null && Scalar.length <= Scalar_offset)
      throw new RuntimeException("array offset argument \"Scalar_offset\" (" + Scalar_offset + ") equals or exceeds array length (" + Scalar.length + ")");
        g2gkinematics1(Udx, BufferFactory.SIZEOF_FLOAT * Udx_offset, Vdy, BufferFactory.SIZEOF_FLOAT * Vdy_offset, Par, BufferFactory.SIZEOF_FLOAT * Par_offset, SpaX, BufferFactory.SIZEOF_FLOAT * SpaX_offset, SpaY, BufferFactory.SIZEOF_FLOAT * SpaY_offset, mnx, BufferFactory.SIZEOF_INT * mnx_offset, mny, BufferFactory.SIZEOF_INT * mny_offset, nx, BufferFactory.SIZEOF_INT * nx_offset, ny, BufferFactory.SIZEOF_INT * ny_offset, choice, BufferFactory.SIZEOF_INT * choice_offset, Scalar, BufferFactory.SIZEOF_FLOAT * Scalar_offset);

  }

  /** Interface to C language function: <br> <code> void gusts(float *  p, float *  t, float *  td, int *  np, int *  gstpot); </code>    */
  public static void gusts(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer td, java.nio.IntBuffer np, java.nio.IntBuffer gstpot)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (np != null && _direct != BufferFactory.isDirect(np))
      throw new RuntimeException("Argument \"np\" : Buffers passed to this method must all be either direct or indirect");
    if (gstpot != null && _direct != BufferFactory.isDirect(gstpot))
      throw new RuntimeException("Argument \"gstpot\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        gusts0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), td, BufferFactory.getDirectBufferByteOffset(td), np, BufferFactory.getDirectBufferByteOffset(np), gstpot, BufferFactory.getDirectBufferByteOffset(gstpot));
    } else {
      gusts1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(np), BufferFactory.getIndirectBufferByteOffset(np), BufferFactory.getArray(gstpot), BufferFactory.getIndirectBufferByteOffset(gstpot));
    }
  }

  /** Entry point to C language function: <br> <code> void gusts(float *  p, float *  t, float *  td, int *  np, int *  gstpot); </code>    */
  private static native void gusts0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object td, int td_byte_offset, Object np, int np_byte_offset, Object gstpot, int gstpot_byte_offset);

  /** Entry point to C language function: <br> <code> void gusts(float *  p, float *  t, float *  td, int *  np, int *  gstpot); </code>    */
  private static native void gusts1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object td, int td_byte_offset, Object np, int np_byte_offset, Object gstpot, int gstpot_byte_offset);

  /** Interface to C language function: <br> <code> void gusts(float *  p, float *  t, float *  td, int *  np, int *  gstpot); </code>    */
  public static void gusts(float[] p, int p_offset, float[] t, int t_offset, float[] td, int td_offset, int[] np, int np_offset, int[] gstpot, int gstpot_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(np != null && np.length <= np_offset)
      throw new RuntimeException("array offset argument \"np_offset\" (" + np_offset + ") equals or exceeds array length (" + np.length + ")");
    if(gstpot != null && gstpot.length <= gstpot_offset)
      throw new RuntimeException("array offset argument \"gstpot_offset\" (" + gstpot_offset + ") equals or exceeds array length (" + gstpot.length + ")");
        gusts1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, np, BufferFactory.SIZEOF_INT * np_offset, gstpot, BufferFactory.SIZEOF_INT * gstpot_offset);

  }

  /** Interface to C language function: <br> <code> void hailsiz(float *  VVMAX, float *  HSIZE); </code>    */
  public static void hailsiz(java.nio.FloatBuffer VVMAX, java.nio.FloatBuffer HSIZE)
  {
    boolean _direct = BufferFactory.isDirect(VVMAX);
    if (HSIZE != null && _direct != BufferFactory.isDirect(HSIZE))
      throw new RuntimeException("Argument \"HSIZE\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        hailsiz0(VVMAX, BufferFactory.getDirectBufferByteOffset(VVMAX), HSIZE, BufferFactory.getDirectBufferByteOffset(HSIZE));
    } else {
      hailsiz1(BufferFactory.getArray(VVMAX), BufferFactory.getIndirectBufferByteOffset(VVMAX), BufferFactory.getArray(HSIZE), BufferFactory.getIndirectBufferByteOffset(HSIZE));
    }
  }

  /** Entry point to C language function: <br> <code> void hailsiz(float *  VVMAX, float *  HSIZE); </code>    */
  private static native void hailsiz0(Object VVMAX, int VVMAX_byte_offset, Object HSIZE, int HSIZE_byte_offset);

  /** Entry point to C language function: <br> <code> void hailsiz(float *  VVMAX, float *  HSIZE); </code>    */
  private static native void hailsiz1(Object VVMAX, int VVMAX_byte_offset, Object HSIZE, int HSIZE_byte_offset);

  /** Interface to C language function: <br> <code> void hailsiz(float *  VVMAX, float *  HSIZE); </code>    */
  public static void hailsiz(float[] VVMAX, int VVMAX_offset, float[] HSIZE, int HSIZE_offset)
  {
    if(VVMAX != null && VVMAX.length <= VVMAX_offset)
      throw new RuntimeException("array offset argument \"VVMAX_offset\" (" + VVMAX_offset + ") equals or exceeds array length (" + VVMAX.length + ")");
    if(HSIZE != null && HSIZE.length <= HSIZE_offset)
      throw new RuntimeException("array offset argument \"HSIZE_offset\" (" + HSIZE_offset + ") equals or exceeds array length (" + HSIZE.length + ")");
        hailsiz1(VVMAX, BufferFactory.SIZEOF_FLOAT * VVMAX_offset, HSIZE, BufferFactory.SIZEOF_FLOAT * HSIZE_offset);

  }

  /** Interface to C language function: <br> <code> void heliComp(const float *  *  u, const float *  *  v, float *  umot, float *  vmot, int mnx, int nx, int ny, int nz, float *  heli); </code>    */
  public static void heliComp(java.nio.FloatBuffer[] u, java.nio.FloatBuffer[] v, java.nio.FloatBuffer umot, java.nio.FloatBuffer vmot, int mnx, int nx, int ny, int nz, java.nio.FloatBuffer heli)
  {
    int[] u_byte_offset_array = new int[u.length];
    if (u != null) {
      for (int _ctr = 0; _ctr < u.length; _ctr++) {
        if (!BufferFactory.isDirect(u[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"u\" was not a direct buffer");
        }
        u_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(u[_ctr]);
      }
    }
    int[] v_byte_offset_array = new int[v.length];
    if (v != null) {
      for (int _ctr = 0; _ctr < v.length; _ctr++) {
        if (!BufferFactory.isDirect(v[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"v\" was not a direct buffer");
        }
        v_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(v[_ctr]);
      }
    }
    boolean _direct = BufferFactory.isDirect(umot);
    if (vmot != null && _direct != BufferFactory.isDirect(vmot))
      throw new RuntimeException("Argument \"vmot\" : Buffers passed to this method must all be either direct or indirect");
    if (heli != null && _direct != BufferFactory.isDirect(heli))
      throw new RuntimeException("Argument \"heli\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        heliComp0(u, u_byte_offset_array, v, v_byte_offset_array, umot, BufferFactory.getDirectBufferByteOffset(umot), vmot, BufferFactory.getDirectBufferByteOffset(vmot), mnx, nx, ny, nz, heli, BufferFactory.getDirectBufferByteOffset(heli));
    } else {
      heliComp1(u, u_byte_offset_array, v, v_byte_offset_array, BufferFactory.getArray(umot), BufferFactory.getIndirectBufferByteOffset(umot), BufferFactory.getArray(vmot), BufferFactory.getIndirectBufferByteOffset(vmot), mnx, nx, ny, nz, BufferFactory.getArray(heli), BufferFactory.getIndirectBufferByteOffset(heli));
    }
  }

  /** Entry point to C language function: <br> <code> void heliComp(const float *  *  u, const float *  *  v, float *  umot, float *  vmot, int mnx, int nx, int ny, int nz, float *  heli); </code>    */
  private static native void heliComp0(Object[] u, int[] u_byte_offset_array, Object[] v, int[] v_byte_offset_array, Object umot, int umot_byte_offset, Object vmot, int vmot_byte_offset, int mnx, int nx, int ny, int nz, Object heli, int heli_byte_offset);

  /** Entry point to C language function: <br> <code> void heliComp(const float *  *  u, const float *  *  v, float *  umot, float *  vmot, int mnx, int nx, int ny, int nz, float *  heli); </code>    */
  private static native void heliComp1(Object[] u, int[] u_byte_offset_array, Object[] v, int[] v_byte_offset_array, Object umot, int umot_byte_offset, Object vmot, int vmot_byte_offset, int mnx, int nx, int ny, int nz, Object heli, int heli_byte_offset);

  /** Interface to C language function: <br> <code> void heliComp(const float *  *  u, const float *  *  v, float *  umot, float *  vmot, int mnx, int nx, int ny, int nz, float *  heli); </code>    */
  public static void heliComp(java.nio.FloatBuffer[] u, java.nio.FloatBuffer[] v, float[] umot, int umot_offset, float[] vmot, int vmot_offset, int mnx, int nx, int ny, int nz, float[] heli, int heli_offset)
  {
    int[] u_byte_offset_array = new int[u.length];
    if (u != null) {
      for (int _ctr = 0; _ctr < u.length; _ctr++) {
        if (!BufferFactory.isDirect(u[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"u\" was not a direct buffer");
        }
        u_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(u[_ctr]);
      }
    }
    int[] v_byte_offset_array = new int[v.length];
    if (v != null) {
      for (int _ctr = 0; _ctr < v.length; _ctr++) {
        if (!BufferFactory.isDirect(v[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"v\" was not a direct buffer");
        }
        v_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(v[_ctr]);
      }
    }
    if(umot != null && umot.length <= umot_offset)
      throw new RuntimeException("array offset argument \"umot_offset\" (" + umot_offset + ") equals or exceeds array length (" + umot.length + ")");
    if(vmot != null && vmot.length <= vmot_offset)
      throw new RuntimeException("array offset argument \"vmot_offset\" (" + vmot_offset + ") equals or exceeds array length (" + vmot.length + ")");
    if(heli != null && heli.length <= heli_offset)
      throw new RuntimeException("array offset argument \"heli_offset\" (" + heli_offset + ") equals or exceeds array length (" + heli.length + ")");
        heliComp1(u, u_byte_offset_array, v, v_byte_offset_array, umot, BufferFactory.SIZEOF_FLOAT * umot_offset, vmot, BufferFactory.SIZEOF_FLOAT * vmot_offset, mnx, nx, ny, nz, heli, BufferFactory.SIZEOF_FLOAT * heli_offset);

  }

  /** Interface to C language function: <br> <code> void hgt2pres(float *  z, float *  p, int *  mni, int *  ni, int *  nj); </code>    */
  public static void hgt2pres(java.nio.FloatBuffer z, java.nio.FloatBuffer p, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(z);
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        hgt2pres0(z, BufferFactory.getDirectBufferByteOffset(z), p, BufferFactory.getDirectBufferByteOffset(p), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      hgt2pres1(BufferFactory.getArray(z), BufferFactory.getIndirectBufferByteOffset(z), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void hgt2pres(float *  z, float *  p, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void hgt2pres0(Object z, int z_byte_offset, Object p, int p_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void hgt2pres(float *  z, float *  p, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void hgt2pres1(Object z, int z_byte_offset, Object p, int p_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void hgt2pres(float *  z, float *  p, int *  mni, int *  ni, int *  nj); </code>    */
  public static void hgt2pres(float[] z, int z_offset, float[] p, int p_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(z != null && z.length <= z_offset)
      throw new RuntimeException("array offset argument \"z_offset\" (" + z_offset + ") equals or exceeds array length (" + z.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        hgt2pres1(z, BufferFactory.SIZEOF_FLOAT * z_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void interp(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, float *  interT, float *  interTd); </code>    */
  public static void interp(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, java.nio.FloatBuffer interT, java.nio.FloatBuffer interTd)
  {
    boolean _direct = BufferFactory.isDirect(interT);
    if (interTd != null && _direct != BufferFactory.isDirect(interTd))
      throw new RuntimeException("Argument \"interTd\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        interp0(p1, p2, temp1, temp2, td1, td2, levelP, interT, BufferFactory.getDirectBufferByteOffset(interT), interTd, BufferFactory.getDirectBufferByteOffset(interTd));
    } else {
      interp1(p1, p2, temp1, temp2, td1, td2, levelP, BufferFactory.getArray(interT), BufferFactory.getIndirectBufferByteOffset(interT), BufferFactory.getArray(interTd), BufferFactory.getIndirectBufferByteOffset(interTd));
    }
  }

  /** Entry point to C language function: <br> <code> void interp(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, float *  interT, float *  interTd); </code>    */
  private static native void interp0(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, Object interT, int interT_byte_offset, Object interTd, int interTd_byte_offset);

  /** Entry point to C language function: <br> <code> void interp(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, float *  interT, float *  interTd); </code>    */
  private static native void interp1(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, Object interT, int interT_byte_offset, Object interTd, int interTd_byte_offset);

  /** Interface to C language function: <br> <code> void interp(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, float *  interT, float *  interTd); </code>    */
  public static void interp(float p1, float p2, float temp1, float temp2, float td1, float td2, float levelP, float[] interT, int interT_offset, float[] interTd, int interTd_offset)
  {
    if(interT != null && interT.length <= interT_offset)
      throw new RuntimeException("array offset argument \"interT_offset\" (" + interT_offset + ") equals or exceeds array length (" + interT.length + ")");
    if(interTd != null && interTd.length <= interTd_offset)
      throw new RuntimeException("array offset argument \"interTd_offset\" (" + interTd_offset + ") equals or exceeds array length (" + interTd.length + ")");
        interp1(p1, p2, temp1, temp2, td1, td2, levelP, interT, BufferFactory.SIZEOF_FLOAT * interT_offset, interTd, BufferFactory.SIZEOF_FLOAT * interTd_offset);

  }

  /** Interface to C language function: <br> <code> float interp1(float * , float * , float * , float * , float * ); </code>    */
  public static float interp1(java.nio.FloatBuffer arg0, java.nio.FloatBuffer arg1, java.nio.FloatBuffer arg2, java.nio.FloatBuffer arg3, java.nio.FloatBuffer arg4)
  {
    boolean _direct = BufferFactory.isDirect(arg0);
    if (arg1 != null && _direct != BufferFactory.isDirect(arg1))
      throw new RuntimeException("Argument \"arg1\" : Buffers passed to this method must all be either direct or indirect");
    if (arg2 != null && _direct != BufferFactory.isDirect(arg2))
      throw new RuntimeException("Argument \"arg2\" : Buffers passed to this method must all be either direct or indirect");
    if (arg3 != null && _direct != BufferFactory.isDirect(arg3))
      throw new RuntimeException("Argument \"arg3\" : Buffers passed to this method must all be either direct or indirect");
    if (arg4 != null && _direct != BufferFactory.isDirect(arg4))
      throw new RuntimeException("Argument \"arg4\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return interp10(arg0, BufferFactory.getDirectBufferByteOffset(arg0), arg1, BufferFactory.getDirectBufferByteOffset(arg1), arg2, BufferFactory.getDirectBufferByteOffset(arg2), arg3, BufferFactory.getDirectBufferByteOffset(arg3), arg4, BufferFactory.getDirectBufferByteOffset(arg4));
    } else {
      return interp11(BufferFactory.getArray(arg0), BufferFactory.getIndirectBufferByteOffset(arg0), BufferFactory.getArray(arg1), BufferFactory.getIndirectBufferByteOffset(arg1), BufferFactory.getArray(arg2), BufferFactory.getIndirectBufferByteOffset(arg2), BufferFactory.getArray(arg3), BufferFactory.getIndirectBufferByteOffset(arg3), BufferFactory.getArray(arg4), BufferFactory.getIndirectBufferByteOffset(arg4));
    }
  }

  /** Entry point to C language function: <br> <code> float interp1(float * , float * , float * , float * , float * ); </code>    */
  private static native float interp10(Object arg0, int arg0_byte_offset, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset);

  /** Entry point to C language function: <br> <code> float interp1(float * , float * , float * , float * , float * ); </code>    */
  private static native float interp11(Object arg0, int arg0_byte_offset, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset);

  /** Interface to C language function: <br> <code> float interp1(float * , float * , float * , float * , float * ); </code>    */
  public static float interp1(float[] arg0, int arg0_offset, float[] arg1, int arg1_offset, float[] arg2, int arg2_offset, float[] arg3, int arg3_offset, float[] arg4, int arg4_offset)
  {
    if(arg0 != null && arg0.length <= arg0_offset)
      throw new RuntimeException("array offset argument \"arg0_offset\" (" + arg0_offset + ") equals or exceeds array length (" + arg0.length + ")");
    if(arg1 != null && arg1.length <= arg1_offset)
      throw new RuntimeException("array offset argument \"arg1_offset\" (" + arg1_offset + ") equals or exceeds array length (" + arg1.length + ")");
    if(arg2 != null && arg2.length <= arg2_offset)
      throw new RuntimeException("array offset argument \"arg2_offset\" (" + arg2_offset + ") equals or exceeds array length (" + arg2.length + ")");
    if(arg3 != null && arg3.length <= arg3_offset)
      throw new RuntimeException("array offset argument \"arg3_offset\" (" + arg3_offset + ") equals or exceeds array length (" + arg3.length + ")");
    if(arg4 != null && arg4.length <= arg4_offset)
      throw new RuntimeException("array offset argument \"arg4_offset\" (" + arg4_offset + ") equals or exceeds array length (" + arg4.length + ")");
        return interp11(arg0, BufferFactory.SIZEOF_FLOAT * arg0_offset, arg1, BufferFactory.SIZEOF_FLOAT * arg1_offset, arg2, BufferFactory.SIZEOF_FLOAT * arg2_offset, arg3, BufferFactory.SIZEOF_FLOAT * arg3_offset, arg4, BufferFactory.SIZEOF_FLOAT * arg4_offset);

  }

  /** Interface to C language function: <br> <code> void intpos(float *  VDIF, float *  HT, float *  P, float *  T, int *  NLVLS); </code>    */
  public static void intpos(java.nio.FloatBuffer VDIF, java.nio.FloatBuffer HT, java.nio.FloatBuffer P, java.nio.FloatBuffer T, java.nio.IntBuffer NLVLS)
  {
    boolean _direct = BufferFactory.isDirect(VDIF);
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        intpos0(VDIF, BufferFactory.getDirectBufferByteOffset(VDIF), HT, BufferFactory.getDirectBufferByteOffset(HT), P, BufferFactory.getDirectBufferByteOffset(P), T, BufferFactory.getDirectBufferByteOffset(T), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS));
    } else {
      intpos1(BufferFactory.getArray(VDIF), BufferFactory.getIndirectBufferByteOffset(VDIF), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS));
    }
  }

  /** Entry point to C language function: <br> <code> void intpos(float *  VDIF, float *  HT, float *  P, float *  T, int *  NLVLS); </code>    */
  private static native void intpos0(Object VDIF, int VDIF_byte_offset, Object HT, int HT_byte_offset, Object P, int P_byte_offset, Object T, int T_byte_offset, Object NLVLS, int NLVLS_byte_offset);

  /** Entry point to C language function: <br> <code> void intpos(float *  VDIF, float *  HT, float *  P, float *  T, int *  NLVLS); </code>    */
  private static native void intpos1(Object VDIF, int VDIF_byte_offset, Object HT, int HT_byte_offset, Object P, int P_byte_offset, Object T, int T_byte_offset, Object NLVLS, int NLVLS_byte_offset);

  /** Interface to C language function: <br> <code> void intpos(float *  VDIF, float *  HT, float *  P, float *  T, int *  NLVLS); </code>    */
  public static void intpos(float[] VDIF, int VDIF_offset, float[] HT, int HT_offset, float[] P, int P_offset, float[] T, int T_offset, int[] NLVLS, int NLVLS_offset)
  {
    if(VDIF != null && VDIF.length <= VDIF_offset)
      throw new RuntimeException("array offset argument \"VDIF_offset\" (" + VDIF_offset + ") equals or exceeds array length (" + VDIF.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
        intpos1(VDIF, BufferFactory.SIZEOF_FLOAT * VDIF_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset);

  }

  /** Interface to C language function: <br> <code> void lapserate(float *  tlo, float *  pzlo, float *  thi, float *  pzhi, int *  vc, int *  mnx, int *  nx, int *  ny, float *  lapse); </code>    */
  public static void lapserate(java.nio.FloatBuffer tlo, java.nio.FloatBuffer pzlo, java.nio.FloatBuffer thi, java.nio.FloatBuffer pzhi, java.nio.IntBuffer vc, java.nio.IntBuffer mnx, java.nio.IntBuffer nx, java.nio.IntBuffer ny, java.nio.FloatBuffer lapse)
  {
    boolean _direct = BufferFactory.isDirect(tlo);
    if (pzlo != null && _direct != BufferFactory.isDirect(pzlo))
      throw new RuntimeException("Argument \"pzlo\" : Buffers passed to this method must all be either direct or indirect");
    if (thi != null && _direct != BufferFactory.isDirect(thi))
      throw new RuntimeException("Argument \"thi\" : Buffers passed to this method must all be either direct or indirect");
    if (pzhi != null && _direct != BufferFactory.isDirect(pzhi))
      throw new RuntimeException("Argument \"pzhi\" : Buffers passed to this method must all be either direct or indirect");
    if (vc != null && _direct != BufferFactory.isDirect(vc))
      throw new RuntimeException("Argument \"vc\" : Buffers passed to this method must all be either direct or indirect");
    if (mnx != null && _direct != BufferFactory.isDirect(mnx))
      throw new RuntimeException("Argument \"mnx\" : Buffers passed to this method must all be either direct or indirect");
    if (nx != null && _direct != BufferFactory.isDirect(nx))
      throw new RuntimeException("Argument \"nx\" : Buffers passed to this method must all be either direct or indirect");
    if (ny != null && _direct != BufferFactory.isDirect(ny))
      throw new RuntimeException("Argument \"ny\" : Buffers passed to this method must all be either direct or indirect");
    if (lapse != null && _direct != BufferFactory.isDirect(lapse))
      throw new RuntimeException("Argument \"lapse\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        lapserate0(tlo, BufferFactory.getDirectBufferByteOffset(tlo), pzlo, BufferFactory.getDirectBufferByteOffset(pzlo), thi, BufferFactory.getDirectBufferByteOffset(thi), pzhi, BufferFactory.getDirectBufferByteOffset(pzhi), vc, BufferFactory.getDirectBufferByteOffset(vc), mnx, BufferFactory.getDirectBufferByteOffset(mnx), nx, BufferFactory.getDirectBufferByteOffset(nx), ny, BufferFactory.getDirectBufferByteOffset(ny), lapse, BufferFactory.getDirectBufferByteOffset(lapse));
    } else {
      lapserate1(BufferFactory.getArray(tlo), BufferFactory.getIndirectBufferByteOffset(tlo), BufferFactory.getArray(pzlo), BufferFactory.getIndirectBufferByteOffset(pzlo), BufferFactory.getArray(thi), BufferFactory.getIndirectBufferByteOffset(thi), BufferFactory.getArray(pzhi), BufferFactory.getIndirectBufferByteOffset(pzhi), BufferFactory.getArray(vc), BufferFactory.getIndirectBufferByteOffset(vc), BufferFactory.getArray(mnx), BufferFactory.getIndirectBufferByteOffset(mnx), BufferFactory.getArray(nx), BufferFactory.getIndirectBufferByteOffset(nx), BufferFactory.getArray(ny), BufferFactory.getIndirectBufferByteOffset(ny), BufferFactory.getArray(lapse), BufferFactory.getIndirectBufferByteOffset(lapse));
    }
  }

  /** Entry point to C language function: <br> <code> void lapserate(float *  tlo, float *  pzlo, float *  thi, float *  pzhi, int *  vc, int *  mnx, int *  nx, int *  ny, float *  lapse); </code>    */
  private static native void lapserate0(Object tlo, int tlo_byte_offset, Object pzlo, int pzlo_byte_offset, Object thi, int thi_byte_offset, Object pzhi, int pzhi_byte_offset, Object vc, int vc_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object lapse, int lapse_byte_offset);

  /** Entry point to C language function: <br> <code> void lapserate(float *  tlo, float *  pzlo, float *  thi, float *  pzhi, int *  vc, int *  mnx, int *  nx, int *  ny, float *  lapse); </code>    */
  private static native void lapserate1(Object tlo, int tlo_byte_offset, Object pzlo, int pzlo_byte_offset, Object thi, int thi_byte_offset, Object pzhi, int pzhi_byte_offset, Object vc, int vc_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object lapse, int lapse_byte_offset);

  /** Interface to C language function: <br> <code> void lapserate(float *  tlo, float *  pzlo, float *  thi, float *  pzhi, int *  vc, int *  mnx, int *  nx, int *  ny, float *  lapse); </code>    */
  public static void lapserate(float[] tlo, int tlo_offset, float[] pzlo, int pzlo_offset, float[] thi, int thi_offset, float[] pzhi, int pzhi_offset, int[] vc, int vc_offset, int[] mnx, int mnx_offset, int[] nx, int nx_offset, int[] ny, int ny_offset, float[] lapse, int lapse_offset)
  {
    if(tlo != null && tlo.length <= tlo_offset)
      throw new RuntimeException("array offset argument \"tlo_offset\" (" + tlo_offset + ") equals or exceeds array length (" + tlo.length + ")");
    if(pzlo != null && pzlo.length <= pzlo_offset)
      throw new RuntimeException("array offset argument \"pzlo_offset\" (" + pzlo_offset + ") equals or exceeds array length (" + pzlo.length + ")");
    if(thi != null && thi.length <= thi_offset)
      throw new RuntimeException("array offset argument \"thi_offset\" (" + thi_offset + ") equals or exceeds array length (" + thi.length + ")");
    if(pzhi != null && pzhi.length <= pzhi_offset)
      throw new RuntimeException("array offset argument \"pzhi_offset\" (" + pzhi_offset + ") equals or exceeds array length (" + pzhi.length + ")");
    if(vc != null && vc.length <= vc_offset)
      throw new RuntimeException("array offset argument \"vc_offset\" (" + vc_offset + ") equals or exceeds array length (" + vc.length + ")");
    if(mnx != null && mnx.length <= mnx_offset)
      throw new RuntimeException("array offset argument \"mnx_offset\" (" + mnx_offset + ") equals or exceeds array length (" + mnx.length + ")");
    if(nx != null && nx.length <= nx_offset)
      throw new RuntimeException("array offset argument \"nx_offset\" (" + nx_offset + ") equals or exceeds array length (" + nx.length + ")");
    if(ny != null && ny.length <= ny_offset)
      throw new RuntimeException("array offset argument \"ny_offset\" (" + ny_offset + ") equals or exceeds array length (" + ny.length + ")");
    if(lapse != null && lapse.length <= lapse_offset)
      throw new RuntimeException("array offset argument \"lapse_offset\" (" + lapse_offset + ") equals or exceeds array length (" + lapse.length + ")");
        lapserate1(tlo, BufferFactory.SIZEOF_FLOAT * tlo_offset, pzlo, BufferFactory.SIZEOF_FLOAT * pzlo_offset, thi, BufferFactory.SIZEOF_FLOAT * thi_offset, pzhi, BufferFactory.SIZEOF_FLOAT * pzhi_offset, vc, BufferFactory.SIZEOF_INT * vc_offset, mnx, BufferFactory.SIZEOF_INT * mnx_offset, nx, BufferFactory.SIZEOF_INT * nx_offset, ny, BufferFactory.SIZEOF_INT * ny_offset, lapse, BufferFactory.SIZEOF_FLOAT * lapse_offset);

  }

  /** Interface to C language function: <br> <code> void lclpar(float *  MIX, float *  TS, float *  P, float *  HT, float *  T, float *  TD, int *  NLVLS, float *  PLCL, float *  TLCL, float *  HLCL); </code>    */
  public static void lclpar(java.nio.FloatBuffer MIX, java.nio.FloatBuffer TS, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer T, java.nio.FloatBuffer TD, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer PLCL, java.nio.FloatBuffer TLCL, java.nio.FloatBuffer HLCL)
  {
    boolean _direct = BufferFactory.isDirect(MIX);
    if (TS != null && _direct != BufferFactory.isDirect(TS))
      throw new RuntimeException("Argument \"TS\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (TD != null && _direct != BufferFactory.isDirect(TD))
      throw new RuntimeException("Argument \"TD\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (PLCL != null && _direct != BufferFactory.isDirect(PLCL))
      throw new RuntimeException("Argument \"PLCL\" : Buffers passed to this method must all be either direct or indirect");
    if (TLCL != null && _direct != BufferFactory.isDirect(TLCL))
      throw new RuntimeException("Argument \"TLCL\" : Buffers passed to this method must all be either direct or indirect");
    if (HLCL != null && _direct != BufferFactory.isDirect(HLCL))
      throw new RuntimeException("Argument \"HLCL\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        lclpar0(MIX, BufferFactory.getDirectBufferByteOffset(MIX), TS, BufferFactory.getDirectBufferByteOffset(TS), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), T, BufferFactory.getDirectBufferByteOffset(T), TD, BufferFactory.getDirectBufferByteOffset(TD), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), PLCL, BufferFactory.getDirectBufferByteOffset(PLCL), TLCL, BufferFactory.getDirectBufferByteOffset(TLCL), HLCL, BufferFactory.getDirectBufferByteOffset(HLCL));
    } else {
      lclpar1(BufferFactory.getArray(MIX), BufferFactory.getIndirectBufferByteOffset(MIX), BufferFactory.getArray(TS), BufferFactory.getIndirectBufferByteOffset(TS), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(TD), BufferFactory.getIndirectBufferByteOffset(TD), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(PLCL), BufferFactory.getIndirectBufferByteOffset(PLCL), BufferFactory.getArray(TLCL), BufferFactory.getIndirectBufferByteOffset(TLCL), BufferFactory.getArray(HLCL), BufferFactory.getIndirectBufferByteOffset(HLCL));
    }
  }

  /** Entry point to C language function: <br> <code> void lclpar(float *  MIX, float *  TS, float *  P, float *  HT, float *  T, float *  TD, int *  NLVLS, float *  PLCL, float *  TLCL, float *  HLCL); </code>    */
  private static native void lclpar0(Object MIX, int MIX_byte_offset, Object TS, int TS_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PLCL, int PLCL_byte_offset, Object TLCL, int TLCL_byte_offset, Object HLCL, int HLCL_byte_offset);

  /** Entry point to C language function: <br> <code> void lclpar(float *  MIX, float *  TS, float *  P, float *  HT, float *  T, float *  TD, int *  NLVLS, float *  PLCL, float *  TLCL, float *  HLCL); </code>    */
  private static native void lclpar1(Object MIX, int MIX_byte_offset, Object TS, int TS_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PLCL, int PLCL_byte_offset, Object TLCL, int TLCL_byte_offset, Object HLCL, int HLCL_byte_offset);

  /** Interface to C language function: <br> <code> void lclpar(float *  MIX, float *  TS, float *  P, float *  HT, float *  T, float *  TD, int *  NLVLS, float *  PLCL, float *  TLCL, float *  HLCL); </code>    */
  public static void lclpar(float[] MIX, int MIX_offset, float[] TS, int TS_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] T, int T_offset, float[] TD, int TD_offset, int[] NLVLS, int NLVLS_offset, float[] PLCL, int PLCL_offset, float[] TLCL, int TLCL_offset, float[] HLCL, int HLCL_offset)
  {
    if(MIX != null && MIX.length <= MIX_offset)
      throw new RuntimeException("array offset argument \"MIX_offset\" (" + MIX_offset + ") equals or exceeds array length (" + MIX.length + ")");
    if(TS != null && TS.length <= TS_offset)
      throw new RuntimeException("array offset argument \"TS_offset\" (" + TS_offset + ") equals or exceeds array length (" + TS.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(TD != null && TD.length <= TD_offset)
      throw new RuntimeException("array offset argument \"TD_offset\" (" + TD_offset + ") equals or exceeds array length (" + TD.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(PLCL != null && PLCL.length <= PLCL_offset)
      throw new RuntimeException("array offset argument \"PLCL_offset\" (" + PLCL_offset + ") equals or exceeds array length (" + PLCL.length + ")");
    if(TLCL != null && TLCL.length <= TLCL_offset)
      throw new RuntimeException("array offset argument \"TLCL_offset\" (" + TLCL_offset + ") equals or exceeds array length (" + TLCL.length + ")");
    if(HLCL != null && HLCL.length <= HLCL_offset)
      throw new RuntimeException("array offset argument \"HLCL_offset\" (" + HLCL_offset + ") equals or exceeds array length (" + HLCL.length + ")");
        lclpar1(MIX, BufferFactory.SIZEOF_FLOAT * MIX_offset, TS, BufferFactory.SIZEOF_FLOAT * TS_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, TD, BufferFactory.SIZEOF_FLOAT * TD_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, PLCL, BufferFactory.SIZEOF_FLOAT * PLCL_offset, TLCL, BufferFactory.SIZEOF_FLOAT * TLCL_offset, HLCL, BufferFactory.SIZEOF_FLOAT * HLCL_offset);

  }

  /** Interface to C language function: <br> <code> void lfcpar(float *  EPTPAR, float *  PCB, float *  TCB, float *  HCB, float *  T1, float *  T2, float *  P1, float *  HT1, int *  NPAR, float *  PLFC1, float *  HLFC1, float *  TLFC1, float *  PLFC2, float *  HLFC2, float *  TLFC2); </code>    */
  public static void lfcpar(java.nio.FloatBuffer EPTPAR, java.nio.FloatBuffer PCB, java.nio.FloatBuffer TCB, java.nio.FloatBuffer HCB, java.nio.FloatBuffer T1, java.nio.FloatBuffer T2, java.nio.FloatBuffer P1, java.nio.FloatBuffer HT1, java.nio.IntBuffer NPAR, java.nio.FloatBuffer PLFC1, java.nio.FloatBuffer HLFC1, java.nio.FloatBuffer TLFC1, java.nio.FloatBuffer PLFC2, java.nio.FloatBuffer HLFC2, java.nio.FloatBuffer TLFC2)
  {
    boolean _direct = BufferFactory.isDirect(EPTPAR);
    if (PCB != null && _direct != BufferFactory.isDirect(PCB))
      throw new RuntimeException("Argument \"PCB\" : Buffers passed to this method must all be either direct or indirect");
    if (TCB != null && _direct != BufferFactory.isDirect(TCB))
      throw new RuntimeException("Argument \"TCB\" : Buffers passed to this method must all be either direct or indirect");
    if (HCB != null && _direct != BufferFactory.isDirect(HCB))
      throw new RuntimeException("Argument \"HCB\" : Buffers passed to this method must all be either direct or indirect");
    if (T1 != null && _direct != BufferFactory.isDirect(T1))
      throw new RuntimeException("Argument \"T1\" : Buffers passed to this method must all be either direct or indirect");
    if (T2 != null && _direct != BufferFactory.isDirect(T2))
      throw new RuntimeException("Argument \"T2\" : Buffers passed to this method must all be either direct or indirect");
    if (P1 != null && _direct != BufferFactory.isDirect(P1))
      throw new RuntimeException("Argument \"P1\" : Buffers passed to this method must all be either direct or indirect");
    if (HT1 != null && _direct != BufferFactory.isDirect(HT1))
      throw new RuntimeException("Argument \"HT1\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (PLFC1 != null && _direct != BufferFactory.isDirect(PLFC1))
      throw new RuntimeException("Argument \"PLFC1\" : Buffers passed to this method must all be either direct or indirect");
    if (HLFC1 != null && _direct != BufferFactory.isDirect(HLFC1))
      throw new RuntimeException("Argument \"HLFC1\" : Buffers passed to this method must all be either direct or indirect");
    if (TLFC1 != null && _direct != BufferFactory.isDirect(TLFC1))
      throw new RuntimeException("Argument \"TLFC1\" : Buffers passed to this method must all be either direct or indirect");
    if (PLFC2 != null && _direct != BufferFactory.isDirect(PLFC2))
      throw new RuntimeException("Argument \"PLFC2\" : Buffers passed to this method must all be either direct or indirect");
    if (HLFC2 != null && _direct != BufferFactory.isDirect(HLFC2))
      throw new RuntimeException("Argument \"HLFC2\" : Buffers passed to this method must all be either direct or indirect");
    if (TLFC2 != null && _direct != BufferFactory.isDirect(TLFC2))
      throw new RuntimeException("Argument \"TLFC2\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        lfcpar0(EPTPAR, BufferFactory.getDirectBufferByteOffset(EPTPAR), PCB, BufferFactory.getDirectBufferByteOffset(PCB), TCB, BufferFactory.getDirectBufferByteOffset(TCB), HCB, BufferFactory.getDirectBufferByteOffset(HCB), T1, BufferFactory.getDirectBufferByteOffset(T1), T2, BufferFactory.getDirectBufferByteOffset(T2), P1, BufferFactory.getDirectBufferByteOffset(P1), HT1, BufferFactory.getDirectBufferByteOffset(HT1), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), PLFC1, BufferFactory.getDirectBufferByteOffset(PLFC1), HLFC1, BufferFactory.getDirectBufferByteOffset(HLFC1), TLFC1, BufferFactory.getDirectBufferByteOffset(TLFC1), PLFC2, BufferFactory.getDirectBufferByteOffset(PLFC2), HLFC2, BufferFactory.getDirectBufferByteOffset(HLFC2), TLFC2, BufferFactory.getDirectBufferByteOffset(TLFC2));
    } else {
      lfcpar1(BufferFactory.getArray(EPTPAR), BufferFactory.getIndirectBufferByteOffset(EPTPAR), BufferFactory.getArray(PCB), BufferFactory.getIndirectBufferByteOffset(PCB), BufferFactory.getArray(TCB), BufferFactory.getIndirectBufferByteOffset(TCB), BufferFactory.getArray(HCB), BufferFactory.getIndirectBufferByteOffset(HCB), BufferFactory.getArray(T1), BufferFactory.getIndirectBufferByteOffset(T1), BufferFactory.getArray(T2), BufferFactory.getIndirectBufferByteOffset(T2), BufferFactory.getArray(P1), BufferFactory.getIndirectBufferByteOffset(P1), BufferFactory.getArray(HT1), BufferFactory.getIndirectBufferByteOffset(HT1), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(PLFC1), BufferFactory.getIndirectBufferByteOffset(PLFC1), BufferFactory.getArray(HLFC1), BufferFactory.getIndirectBufferByteOffset(HLFC1), BufferFactory.getArray(TLFC1), BufferFactory.getIndirectBufferByteOffset(TLFC1), BufferFactory.getArray(PLFC2), BufferFactory.getIndirectBufferByteOffset(PLFC2), BufferFactory.getArray(HLFC2), BufferFactory.getIndirectBufferByteOffset(HLFC2), BufferFactory.getArray(TLFC2), BufferFactory.getIndirectBufferByteOffset(TLFC2));
    }
  }

  /** Entry point to C language function: <br> <code> void lfcpar(float *  EPTPAR, float *  PCB, float *  TCB, float *  HCB, float *  T1, float *  T2, float *  P1, float *  HT1, int *  NPAR, float *  PLFC1, float *  HLFC1, float *  TLFC1, float *  PLFC2, float *  HLFC2, float *  TLFC2); </code>    */
  private static native void lfcpar0(Object EPTPAR, int EPTPAR_byte_offset, Object PCB, int PCB_byte_offset, Object TCB, int TCB_byte_offset, Object HCB, int HCB_byte_offset, Object T1, int T1_byte_offset, Object T2, int T2_byte_offset, Object P1, int P1_byte_offset, Object HT1, int HT1_byte_offset, Object NPAR, int NPAR_byte_offset, Object PLFC1, int PLFC1_byte_offset, Object HLFC1, int HLFC1_byte_offset, Object TLFC1, int TLFC1_byte_offset, Object PLFC2, int PLFC2_byte_offset, Object HLFC2, int HLFC2_byte_offset, Object TLFC2, int TLFC2_byte_offset);

  /** Entry point to C language function: <br> <code> void lfcpar(float *  EPTPAR, float *  PCB, float *  TCB, float *  HCB, float *  T1, float *  T2, float *  P1, float *  HT1, int *  NPAR, float *  PLFC1, float *  HLFC1, float *  TLFC1, float *  PLFC2, float *  HLFC2, float *  TLFC2); </code>    */
  private static native void lfcpar1(Object EPTPAR, int EPTPAR_byte_offset, Object PCB, int PCB_byte_offset, Object TCB, int TCB_byte_offset, Object HCB, int HCB_byte_offset, Object T1, int T1_byte_offset, Object T2, int T2_byte_offset, Object P1, int P1_byte_offset, Object HT1, int HT1_byte_offset, Object NPAR, int NPAR_byte_offset, Object PLFC1, int PLFC1_byte_offset, Object HLFC1, int HLFC1_byte_offset, Object TLFC1, int TLFC1_byte_offset, Object PLFC2, int PLFC2_byte_offset, Object HLFC2, int HLFC2_byte_offset, Object TLFC2, int TLFC2_byte_offset);

  /** Interface to C language function: <br> <code> void lfcpar(float *  EPTPAR, float *  PCB, float *  TCB, float *  HCB, float *  T1, float *  T2, float *  P1, float *  HT1, int *  NPAR, float *  PLFC1, float *  HLFC1, float *  TLFC1, float *  PLFC2, float *  HLFC2, float *  TLFC2); </code>    */
  public static void lfcpar(float[] EPTPAR, int EPTPAR_offset, float[] PCB, int PCB_offset, float[] TCB, int TCB_offset, float[] HCB, int HCB_offset, float[] T1, int T1_offset, float[] T2, int T2_offset, float[] P1, int P1_offset, float[] HT1, int HT1_offset, int[] NPAR, int NPAR_offset, float[] PLFC1, int PLFC1_offset, float[] HLFC1, int HLFC1_offset, float[] TLFC1, int TLFC1_offset, float[] PLFC2, int PLFC2_offset, float[] HLFC2, int HLFC2_offset, float[] TLFC2, int TLFC2_offset)
  {
    if(EPTPAR != null && EPTPAR.length <= EPTPAR_offset)
      throw new RuntimeException("array offset argument \"EPTPAR_offset\" (" + EPTPAR_offset + ") equals or exceeds array length (" + EPTPAR.length + ")");
    if(PCB != null && PCB.length <= PCB_offset)
      throw new RuntimeException("array offset argument \"PCB_offset\" (" + PCB_offset + ") equals or exceeds array length (" + PCB.length + ")");
    if(TCB != null && TCB.length <= TCB_offset)
      throw new RuntimeException("array offset argument \"TCB_offset\" (" + TCB_offset + ") equals or exceeds array length (" + TCB.length + ")");
    if(HCB != null && HCB.length <= HCB_offset)
      throw new RuntimeException("array offset argument \"HCB_offset\" (" + HCB_offset + ") equals or exceeds array length (" + HCB.length + ")");
    if(T1 != null && T1.length <= T1_offset)
      throw new RuntimeException("array offset argument \"T1_offset\" (" + T1_offset + ") equals or exceeds array length (" + T1.length + ")");
    if(T2 != null && T2.length <= T2_offset)
      throw new RuntimeException("array offset argument \"T2_offset\" (" + T2_offset + ") equals or exceeds array length (" + T2.length + ")");
    if(P1 != null && P1.length <= P1_offset)
      throw new RuntimeException("array offset argument \"P1_offset\" (" + P1_offset + ") equals or exceeds array length (" + P1.length + ")");
    if(HT1 != null && HT1.length <= HT1_offset)
      throw new RuntimeException("array offset argument \"HT1_offset\" (" + HT1_offset + ") equals or exceeds array length (" + HT1.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(PLFC1 != null && PLFC1.length <= PLFC1_offset)
      throw new RuntimeException("array offset argument \"PLFC1_offset\" (" + PLFC1_offset + ") equals or exceeds array length (" + PLFC1.length + ")");
    if(HLFC1 != null && HLFC1.length <= HLFC1_offset)
      throw new RuntimeException("array offset argument \"HLFC1_offset\" (" + HLFC1_offset + ") equals or exceeds array length (" + HLFC1.length + ")");
    if(TLFC1 != null && TLFC1.length <= TLFC1_offset)
      throw new RuntimeException("array offset argument \"TLFC1_offset\" (" + TLFC1_offset + ") equals or exceeds array length (" + TLFC1.length + ")");
    if(PLFC2 != null && PLFC2.length <= PLFC2_offset)
      throw new RuntimeException("array offset argument \"PLFC2_offset\" (" + PLFC2_offset + ") equals or exceeds array length (" + PLFC2.length + ")");
    if(HLFC2 != null && HLFC2.length <= HLFC2_offset)
      throw new RuntimeException("array offset argument \"HLFC2_offset\" (" + HLFC2_offset + ") equals or exceeds array length (" + HLFC2.length + ")");
    if(TLFC2 != null && TLFC2.length <= TLFC2_offset)
      throw new RuntimeException("array offset argument \"TLFC2_offset\" (" + TLFC2_offset + ") equals or exceeds array length (" + TLFC2.length + ")");
        lfcpar1(EPTPAR, BufferFactory.SIZEOF_FLOAT * EPTPAR_offset, PCB, BufferFactory.SIZEOF_FLOAT * PCB_offset, TCB, BufferFactory.SIZEOF_FLOAT * TCB_offset, HCB, BufferFactory.SIZEOF_FLOAT * HCB_offset, T1, BufferFactory.SIZEOF_FLOAT * T1_offset, T2, BufferFactory.SIZEOF_FLOAT * T2_offset, P1, BufferFactory.SIZEOF_FLOAT * P1_offset, HT1, BufferFactory.SIZEOF_FLOAT * HT1_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, PLFC1, BufferFactory.SIZEOF_FLOAT * PLFC1_offset, HLFC1, BufferFactory.SIZEOF_FLOAT * HLFC1_offset, TLFC1, BufferFactory.SIZEOF_FLOAT * TLFC1_offset, PLFC2, BufferFactory.SIZEOF_FLOAT * PLFC2_offset, HLFC2, BufferFactory.SIZEOF_FLOAT * HLFC2_offset, TLFC2, BufferFactory.SIZEOF_FLOAT * TLFC2_offset);

  }

  /** Interface to C language function: <br> <code> void liftedp(float *  P, float *  T, float *  HT, float *  TVIR, int *  NLVLS, int *  NPAR, float *  PCB, float *  HCB, float *  TCB, float *  WCB, float *  THDPAR, float *  EPTPAR, float *  PL, float *  TL, float *  PP, float *  HTP, float *  TP, float *  TVIRP, float *  TE, float *  TVIRE, int *  NPARCEL); </code>    */
  public static void liftedp(java.nio.FloatBuffer P, java.nio.FloatBuffer T, java.nio.FloatBuffer HT, java.nio.FloatBuffer TVIR, java.nio.IntBuffer NLVLS, java.nio.IntBuffer NPAR, java.nio.FloatBuffer PCB, java.nio.FloatBuffer HCB, java.nio.FloatBuffer TCB, java.nio.FloatBuffer WCB, java.nio.FloatBuffer THDPAR, java.nio.FloatBuffer EPTPAR, java.nio.FloatBuffer PL, java.nio.FloatBuffer TL, java.nio.FloatBuffer PP, java.nio.FloatBuffer HTP, java.nio.FloatBuffer TP, java.nio.FloatBuffer TVIRP, java.nio.FloatBuffer TE, java.nio.FloatBuffer TVIRE, java.nio.IntBuffer NPARCEL)
  {
    boolean _direct = BufferFactory.isDirect(P);
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (TVIR != null && _direct != BufferFactory.isDirect(TVIR))
      throw new RuntimeException("Argument \"TVIR\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (PCB != null && _direct != BufferFactory.isDirect(PCB))
      throw new RuntimeException("Argument \"PCB\" : Buffers passed to this method must all be either direct or indirect");
    if (HCB != null && _direct != BufferFactory.isDirect(HCB))
      throw new RuntimeException("Argument \"HCB\" : Buffers passed to this method must all be either direct or indirect");
    if (TCB != null && _direct != BufferFactory.isDirect(TCB))
      throw new RuntimeException("Argument \"TCB\" : Buffers passed to this method must all be either direct or indirect");
    if (WCB != null && _direct != BufferFactory.isDirect(WCB))
      throw new RuntimeException("Argument \"WCB\" : Buffers passed to this method must all be either direct or indirect");
    if (THDPAR != null && _direct != BufferFactory.isDirect(THDPAR))
      throw new RuntimeException("Argument \"THDPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (EPTPAR != null && _direct != BufferFactory.isDirect(EPTPAR))
      throw new RuntimeException("Argument \"EPTPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (PL != null && _direct != BufferFactory.isDirect(PL))
      throw new RuntimeException("Argument \"PL\" : Buffers passed to this method must all be either direct or indirect");
    if (TL != null && _direct != BufferFactory.isDirect(TL))
      throw new RuntimeException("Argument \"TL\" : Buffers passed to this method must all be either direct or indirect");
    if (PP != null && _direct != BufferFactory.isDirect(PP))
      throw new RuntimeException("Argument \"PP\" : Buffers passed to this method must all be either direct or indirect");
    if (HTP != null && _direct != BufferFactory.isDirect(HTP))
      throw new RuntimeException("Argument \"HTP\" : Buffers passed to this method must all be either direct or indirect");
    if (TP != null && _direct != BufferFactory.isDirect(TP))
      throw new RuntimeException("Argument \"TP\" : Buffers passed to this method must all be either direct or indirect");
    if (TVIRP != null && _direct != BufferFactory.isDirect(TVIRP))
      throw new RuntimeException("Argument \"TVIRP\" : Buffers passed to this method must all be either direct or indirect");
    if (TE != null && _direct != BufferFactory.isDirect(TE))
      throw new RuntimeException("Argument \"TE\" : Buffers passed to this method must all be either direct or indirect");
    if (TVIRE != null && _direct != BufferFactory.isDirect(TVIRE))
      throw new RuntimeException("Argument \"TVIRE\" : Buffers passed to this method must all be either direct or indirect");
    if (NPARCEL != null && _direct != BufferFactory.isDirect(NPARCEL))
      throw new RuntimeException("Argument \"NPARCEL\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        liftedp0(P, BufferFactory.getDirectBufferByteOffset(P), T, BufferFactory.getDirectBufferByteOffset(T), HT, BufferFactory.getDirectBufferByteOffset(HT), TVIR, BufferFactory.getDirectBufferByteOffset(TVIR), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), PCB, BufferFactory.getDirectBufferByteOffset(PCB), HCB, BufferFactory.getDirectBufferByteOffset(HCB), TCB, BufferFactory.getDirectBufferByteOffset(TCB), WCB, BufferFactory.getDirectBufferByteOffset(WCB), THDPAR, BufferFactory.getDirectBufferByteOffset(THDPAR), EPTPAR, BufferFactory.getDirectBufferByteOffset(EPTPAR), PL, BufferFactory.getDirectBufferByteOffset(PL), TL, BufferFactory.getDirectBufferByteOffset(TL), PP, BufferFactory.getDirectBufferByteOffset(PP), HTP, BufferFactory.getDirectBufferByteOffset(HTP), TP, BufferFactory.getDirectBufferByteOffset(TP), TVIRP, BufferFactory.getDirectBufferByteOffset(TVIRP), TE, BufferFactory.getDirectBufferByteOffset(TE), TVIRE, BufferFactory.getDirectBufferByteOffset(TVIRE), NPARCEL, BufferFactory.getDirectBufferByteOffset(NPARCEL));
    } else {
      liftedp1(BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(TVIR), BufferFactory.getIndirectBufferByteOffset(TVIR), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(PCB), BufferFactory.getIndirectBufferByteOffset(PCB), BufferFactory.getArray(HCB), BufferFactory.getIndirectBufferByteOffset(HCB), BufferFactory.getArray(TCB), BufferFactory.getIndirectBufferByteOffset(TCB), BufferFactory.getArray(WCB), BufferFactory.getIndirectBufferByteOffset(WCB), BufferFactory.getArray(THDPAR), BufferFactory.getIndirectBufferByteOffset(THDPAR), BufferFactory.getArray(EPTPAR), BufferFactory.getIndirectBufferByteOffset(EPTPAR), BufferFactory.getArray(PL), BufferFactory.getIndirectBufferByteOffset(PL), BufferFactory.getArray(TL), BufferFactory.getIndirectBufferByteOffset(TL), BufferFactory.getArray(PP), BufferFactory.getIndirectBufferByteOffset(PP), BufferFactory.getArray(HTP), BufferFactory.getIndirectBufferByteOffset(HTP), BufferFactory.getArray(TP), BufferFactory.getIndirectBufferByteOffset(TP), BufferFactory.getArray(TVIRP), BufferFactory.getIndirectBufferByteOffset(TVIRP), BufferFactory.getArray(TE), BufferFactory.getIndirectBufferByteOffset(TE), BufferFactory.getArray(TVIRE), BufferFactory.getIndirectBufferByteOffset(TVIRE), BufferFactory.getArray(NPARCEL), BufferFactory.getIndirectBufferByteOffset(NPARCEL));
    }
  }

  /** Entry point to C language function: <br> <code> void liftedp(float *  P, float *  T, float *  HT, float *  TVIR, int *  NLVLS, int *  NPAR, float *  PCB, float *  HCB, float *  TCB, float *  WCB, float *  THDPAR, float *  EPTPAR, float *  PL, float *  TL, float *  PP, float *  HTP, float *  TP, float *  TVIRP, float *  TE, float *  TVIRE, int *  NPARCEL); </code>    */
  private static native void liftedp0(Object P, int P_byte_offset, Object T, int T_byte_offset, Object HT, int HT_byte_offset, Object TVIR, int TVIR_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object NPAR, int NPAR_byte_offset, Object PCB, int PCB_byte_offset, Object HCB, int HCB_byte_offset, Object TCB, int TCB_byte_offset, Object WCB, int WCB_byte_offset, Object THDPAR, int THDPAR_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object PL, int PL_byte_offset, Object TL, int TL_byte_offset, Object PP, int PP_byte_offset, Object HTP, int HTP_byte_offset, Object TP, int TP_byte_offset, Object TVIRP, int TVIRP_byte_offset, Object TE, int TE_byte_offset, Object TVIRE, int TVIRE_byte_offset, Object NPARCEL, int NPARCEL_byte_offset);

  /** Entry point to C language function: <br> <code> void liftedp(float *  P, float *  T, float *  HT, float *  TVIR, int *  NLVLS, int *  NPAR, float *  PCB, float *  HCB, float *  TCB, float *  WCB, float *  THDPAR, float *  EPTPAR, float *  PL, float *  TL, float *  PP, float *  HTP, float *  TP, float *  TVIRP, float *  TE, float *  TVIRE, int *  NPARCEL); </code>    */
  private static native void liftedp1(Object P, int P_byte_offset, Object T, int T_byte_offset, Object HT, int HT_byte_offset, Object TVIR, int TVIR_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object NPAR, int NPAR_byte_offset, Object PCB, int PCB_byte_offset, Object HCB, int HCB_byte_offset, Object TCB, int TCB_byte_offset, Object WCB, int WCB_byte_offset, Object THDPAR, int THDPAR_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object PL, int PL_byte_offset, Object TL, int TL_byte_offset, Object PP, int PP_byte_offset, Object HTP, int HTP_byte_offset, Object TP, int TP_byte_offset, Object TVIRP, int TVIRP_byte_offset, Object TE, int TE_byte_offset, Object TVIRE, int TVIRE_byte_offset, Object NPARCEL, int NPARCEL_byte_offset);

  /** Interface to C language function: <br> <code> void liftedp(float *  P, float *  T, float *  HT, float *  TVIR, int *  NLVLS, int *  NPAR, float *  PCB, float *  HCB, float *  TCB, float *  WCB, float *  THDPAR, float *  EPTPAR, float *  PL, float *  TL, float *  PP, float *  HTP, float *  TP, float *  TVIRP, float *  TE, float *  TVIRE, int *  NPARCEL); </code>    */
  public static void liftedp(float[] P, int P_offset, float[] T, int T_offset, float[] HT, int HT_offset, float[] TVIR, int TVIR_offset, int[] NLVLS, int NLVLS_offset, int[] NPAR, int NPAR_offset, float[] PCB, int PCB_offset, float[] HCB, int HCB_offset, float[] TCB, int TCB_offset, float[] WCB, int WCB_offset, float[] THDPAR, int THDPAR_offset, float[] EPTPAR, int EPTPAR_offset, float[] PL, int PL_offset, float[] TL, int TL_offset, float[] PP, int PP_offset, float[] HTP, int HTP_offset, float[] TP, int TP_offset, float[] TVIRP, int TVIRP_offset, float[] TE, int TE_offset, float[] TVIRE, int TVIRE_offset, int[] NPARCEL, int NPARCEL_offset)
  {
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(TVIR != null && TVIR.length <= TVIR_offset)
      throw new RuntimeException("array offset argument \"TVIR_offset\" (" + TVIR_offset + ") equals or exceeds array length (" + TVIR.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(PCB != null && PCB.length <= PCB_offset)
      throw new RuntimeException("array offset argument \"PCB_offset\" (" + PCB_offset + ") equals or exceeds array length (" + PCB.length + ")");
    if(HCB != null && HCB.length <= HCB_offset)
      throw new RuntimeException("array offset argument \"HCB_offset\" (" + HCB_offset + ") equals or exceeds array length (" + HCB.length + ")");
    if(TCB != null && TCB.length <= TCB_offset)
      throw new RuntimeException("array offset argument \"TCB_offset\" (" + TCB_offset + ") equals or exceeds array length (" + TCB.length + ")");
    if(WCB != null && WCB.length <= WCB_offset)
      throw new RuntimeException("array offset argument \"WCB_offset\" (" + WCB_offset + ") equals or exceeds array length (" + WCB.length + ")");
    if(THDPAR != null && THDPAR.length <= THDPAR_offset)
      throw new RuntimeException("array offset argument \"THDPAR_offset\" (" + THDPAR_offset + ") equals or exceeds array length (" + THDPAR.length + ")");
    if(EPTPAR != null && EPTPAR.length <= EPTPAR_offset)
      throw new RuntimeException("array offset argument \"EPTPAR_offset\" (" + EPTPAR_offset + ") equals or exceeds array length (" + EPTPAR.length + ")");
    if(PL != null && PL.length <= PL_offset)
      throw new RuntimeException("array offset argument \"PL_offset\" (" + PL_offset + ") equals or exceeds array length (" + PL.length + ")");
    if(TL != null && TL.length <= TL_offset)
      throw new RuntimeException("array offset argument \"TL_offset\" (" + TL_offset + ") equals or exceeds array length (" + TL.length + ")");
    if(PP != null && PP.length <= PP_offset)
      throw new RuntimeException("array offset argument \"PP_offset\" (" + PP_offset + ") equals or exceeds array length (" + PP.length + ")");
    if(HTP != null && HTP.length <= HTP_offset)
      throw new RuntimeException("array offset argument \"HTP_offset\" (" + HTP_offset + ") equals or exceeds array length (" + HTP.length + ")");
    if(TP != null && TP.length <= TP_offset)
      throw new RuntimeException("array offset argument \"TP_offset\" (" + TP_offset + ") equals or exceeds array length (" + TP.length + ")");
    if(TVIRP != null && TVIRP.length <= TVIRP_offset)
      throw new RuntimeException("array offset argument \"TVIRP_offset\" (" + TVIRP_offset + ") equals or exceeds array length (" + TVIRP.length + ")");
    if(TE != null && TE.length <= TE_offset)
      throw new RuntimeException("array offset argument \"TE_offset\" (" + TE_offset + ") equals or exceeds array length (" + TE.length + ")");
    if(TVIRE != null && TVIRE.length <= TVIRE_offset)
      throw new RuntimeException("array offset argument \"TVIRE_offset\" (" + TVIRE_offset + ") equals or exceeds array length (" + TVIRE.length + ")");
    if(NPARCEL != null && NPARCEL.length <= NPARCEL_offset)
      throw new RuntimeException("array offset argument \"NPARCEL_offset\" (" + NPARCEL_offset + ") equals or exceeds array length (" + NPARCEL.length + ")");
        liftedp1(P, BufferFactory.SIZEOF_FLOAT * P_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, TVIR, BufferFactory.SIZEOF_FLOAT * TVIR_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, PCB, BufferFactory.SIZEOF_FLOAT * PCB_offset, HCB, BufferFactory.SIZEOF_FLOAT * HCB_offset, TCB, BufferFactory.SIZEOF_FLOAT * TCB_offset, WCB, BufferFactory.SIZEOF_FLOAT * WCB_offset, THDPAR, BufferFactory.SIZEOF_FLOAT * THDPAR_offset, EPTPAR, BufferFactory.SIZEOF_FLOAT * EPTPAR_offset, PL, BufferFactory.SIZEOF_FLOAT * PL_offset, TL, BufferFactory.SIZEOF_FLOAT * TL_offset, PP, BufferFactory.SIZEOF_FLOAT * PP_offset, HTP, BufferFactory.SIZEOF_FLOAT * HTP_offset, TP, BufferFactory.SIZEOF_FLOAT * TP_offset, TVIRP, BufferFactory.SIZEOF_FLOAT * TVIRP_offset, TE, BufferFactory.SIZEOF_FLOAT * TE_offset, TVIRE, BufferFactory.SIZEOF_FLOAT * TVIRE_offset, NPARCEL, BufferFactory.SIZEOF_INT * NPARCEL_offset);

  }

  /** Interface to C language function: <br> <code> void lintrans(float *  a, float *  mult, float *  add, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void lintrans(java.nio.FloatBuffer a, java.nio.FloatBuffer mult, java.nio.FloatBuffer add, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (mult != null && _direct != BufferFactory.isDirect(mult))
      throw new RuntimeException("Argument \"mult\" : Buffers passed to this method must all be either direct or indirect");
    if (add != null && _direct != BufferFactory.isDirect(add))
      throw new RuntimeException("Argument \"add\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        lintrans0(a, BufferFactory.getDirectBufferByteOffset(a), mult, BufferFactory.getDirectBufferByteOffset(mult), add, BufferFactory.getDirectBufferByteOffset(add), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      lintrans1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(mult), BufferFactory.getIndirectBufferByteOffset(mult), BufferFactory.getArray(add), BufferFactory.getIndirectBufferByteOffset(add), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void lintrans(float *  a, float *  mult, float *  add, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void lintrans0(Object a, int a_byte_offset, Object mult, int mult_byte_offset, Object add, int add_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void lintrans(float *  a, float *  mult, float *  add, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void lintrans1(Object a, int a_byte_offset, Object mult, int mult_byte_offset, Object add, int add_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void lintrans(float *  a, float *  mult, float *  add, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void lintrans(float[] a, int a_offset, float[] mult, int mult_offset, float[] add, int add_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(mult != null && mult.length <= mult_offset)
      throw new RuntimeException("array offset argument \"mult_offset\" (" + mult_offset + ") equals or exceeds array length (" + mult.length + ")");
    if(add != null && add.length <= add_offset)
      throw new RuntimeException("array offset argument \"add_offset\" (" + add_offset + ") equals or exceeds array length (" + add.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        lintrans1(a, BufferFactory.SIZEOF_FLOAT * a_offset, mult, BufferFactory.SIZEOF_FLOAT * mult_offset, add, BufferFactory.SIZEOF_FLOAT * add_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void matsln(float *  Array, float *  yVector, int *  work, float *  soln, int *  mn, int *  n, int *  ok); </code>    */
  public static void matsln(java.nio.FloatBuffer Array, java.nio.FloatBuffer yVector, java.nio.IntBuffer work, java.nio.FloatBuffer soln, java.nio.IntBuffer mn, java.nio.IntBuffer n, java.nio.IntBuffer ok)
  {
    boolean _direct = BufferFactory.isDirect(Array);
    if (yVector != null && _direct != BufferFactory.isDirect(yVector))
      throw new RuntimeException("Argument \"yVector\" : Buffers passed to this method must all be either direct or indirect");
    if (work != null && _direct != BufferFactory.isDirect(work))
      throw new RuntimeException("Argument \"work\" : Buffers passed to this method must all be either direct or indirect");
    if (soln != null && _direct != BufferFactory.isDirect(soln))
      throw new RuntimeException("Argument \"soln\" : Buffers passed to this method must all be either direct or indirect");
    if (mn != null && _direct != BufferFactory.isDirect(mn))
      throw new RuntimeException("Argument \"mn\" : Buffers passed to this method must all be either direct or indirect");
    if (n != null && _direct != BufferFactory.isDirect(n))
      throw new RuntimeException("Argument \"n\" : Buffers passed to this method must all be either direct or indirect");
    if (ok != null && _direct != BufferFactory.isDirect(ok))
      throw new RuntimeException("Argument \"ok\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        matsln0(Array, BufferFactory.getDirectBufferByteOffset(Array), yVector, BufferFactory.getDirectBufferByteOffset(yVector), work, BufferFactory.getDirectBufferByteOffset(work), soln, BufferFactory.getDirectBufferByteOffset(soln), mn, BufferFactory.getDirectBufferByteOffset(mn), n, BufferFactory.getDirectBufferByteOffset(n), ok, BufferFactory.getDirectBufferByteOffset(ok));
    } else {
      matsln1(BufferFactory.getArray(Array), BufferFactory.getIndirectBufferByteOffset(Array), BufferFactory.getArray(yVector), BufferFactory.getIndirectBufferByteOffset(yVector), BufferFactory.getArray(work), BufferFactory.getIndirectBufferByteOffset(work), BufferFactory.getArray(soln), BufferFactory.getIndirectBufferByteOffset(soln), BufferFactory.getArray(mn), BufferFactory.getIndirectBufferByteOffset(mn), BufferFactory.getArray(n), BufferFactory.getIndirectBufferByteOffset(n), BufferFactory.getArray(ok), BufferFactory.getIndirectBufferByteOffset(ok));
    }
  }

  /** Entry point to C language function: <br> <code> void matsln(float *  Array, float *  yVector, int *  work, float *  soln, int *  mn, int *  n, int *  ok); </code>    */
  private static native void matsln0(Object Array, int Array_byte_offset, Object yVector, int yVector_byte_offset, Object work, int work_byte_offset, Object soln, int soln_byte_offset, Object mn, int mn_byte_offset, Object n, int n_byte_offset, Object ok, int ok_byte_offset);

  /** Entry point to C language function: <br> <code> void matsln(float *  Array, float *  yVector, int *  work, float *  soln, int *  mn, int *  n, int *  ok); </code>    */
  private static native void matsln1(Object Array, int Array_byte_offset, Object yVector, int yVector_byte_offset, Object work, int work_byte_offset, Object soln, int soln_byte_offset, Object mn, int mn_byte_offset, Object n, int n_byte_offset, Object ok, int ok_byte_offset);

  /** Interface to C language function: <br> <code> void matsln(float *  Array, float *  yVector, int *  work, float *  soln, int *  mn, int *  n, int *  ok); </code>    */
  public static void matsln(float[] Array, int Array_offset, float[] yVector, int yVector_offset, int[] work, int work_offset, float[] soln, int soln_offset, int[] mn, int mn_offset, int[] n, int n_offset, int[] ok, int ok_offset)
  {
    if(Array != null && Array.length <= Array_offset)
      throw new RuntimeException("array offset argument \"Array_offset\" (" + Array_offset + ") equals or exceeds array length (" + Array.length + ")");
    if(yVector != null && yVector.length <= yVector_offset)
      throw new RuntimeException("array offset argument \"yVector_offset\" (" + yVector_offset + ") equals or exceeds array length (" + yVector.length + ")");
    if(work != null && work.length <= work_offset)
      throw new RuntimeException("array offset argument \"work_offset\" (" + work_offset + ") equals or exceeds array length (" + work.length + ")");
    if(soln != null && soln.length <= soln_offset)
      throw new RuntimeException("array offset argument \"soln_offset\" (" + soln_offset + ") equals or exceeds array length (" + soln.length + ")");
    if(mn != null && mn.length <= mn_offset)
      throw new RuntimeException("array offset argument \"mn_offset\" (" + mn_offset + ") equals or exceeds array length (" + mn.length + ")");
    if(n != null && n.length <= n_offset)
      throw new RuntimeException("array offset argument \"n_offset\" (" + n_offset + ") equals or exceeds array length (" + n.length + ")");
    if(ok != null && ok.length <= ok_offset)
      throw new RuntimeException("array offset argument \"ok_offset\" (" + ok_offset + ") equals or exceeds array length (" + ok.length + ")");
        matsln1(Array, BufferFactory.SIZEOF_FLOAT * Array_offset, yVector, BufferFactory.SIZEOF_FLOAT * yVector_offset, work, BufferFactory.SIZEOF_INT * work_offset, soln, BufferFactory.SIZEOF_FLOAT * soln_offset, mn, BufferFactory.SIZEOF_INT * mn_offset, n, BufferFactory.SIZEOF_INT * n_offset, ok, BufferFactory.SIZEOF_INT * ok_offset);

  }

  /** Interface to C language function: <br> <code> void max_min(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  public static void max_min(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.IntBuffer mode)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (mode != null && _direct != BufferFactory.isDirect(mode))
      throw new RuntimeException("Argument \"mode\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        max_min0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), mode, BufferFactory.getDirectBufferByteOffset(mode));
    } else {
      max_min1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(mode), BufferFactory.getIndirectBufferByteOffset(mode));
    }
  }

  /** Entry point to C language function: <br> <code> void max_min(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  private static native void max_min0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object mode, int mode_byte_offset);

  /** Entry point to C language function: <br> <code> void max_min(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  private static native void max_min1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object mode, int mode_byte_offset);

  /** Interface to C language function: <br> <code> void max_min(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj, int *  mode); </code>    */
  public static void max_min(float[] a, int a_offset, float[] b, int b_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, int[] mode, int mode_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(mode != null && mode.length <= mode_offset)
      throw new RuntimeException("array offset argument \"mode_offset\" (" + mode_offset + ") equals or exceeds array length (" + mode.length + ")");
        max_min1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, mode, BufferFactory.SIZEOF_INT * mode_offset);

  }

  /** Interface to C language function: <br> <code> void mixrat(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void mixrat(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        mixrat0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      mixrat1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void mixrat(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void mixrat0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void mixrat(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void mixrat1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void mixrat(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void mixrat(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        mixrat1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void mslp2thkns(float *  mslp, float *  hgt, float *  thkns, int *  mni, int *  ni, int *  nj); </code>    */
  public static void mslp2thkns(java.nio.FloatBuffer mslp, java.nio.FloatBuffer hgt, java.nio.FloatBuffer thkns, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(mslp);
    if (hgt != null && _direct != BufferFactory.isDirect(hgt))
      throw new RuntimeException("Argument \"hgt\" : Buffers passed to this method must all be either direct or indirect");
    if (thkns != null && _direct != BufferFactory.isDirect(thkns))
      throw new RuntimeException("Argument \"thkns\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        mslp2thkns0(mslp, BufferFactory.getDirectBufferByteOffset(mslp), hgt, BufferFactory.getDirectBufferByteOffset(hgt), thkns, BufferFactory.getDirectBufferByteOffset(thkns), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      mslp2thkns1(BufferFactory.getArray(mslp), BufferFactory.getIndirectBufferByteOffset(mslp), BufferFactory.getArray(hgt), BufferFactory.getIndirectBufferByteOffset(hgt), BufferFactory.getArray(thkns), BufferFactory.getIndirectBufferByteOffset(thkns), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void mslp2thkns(float *  mslp, float *  hgt, float *  thkns, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void mslp2thkns0(Object mslp, int mslp_byte_offset, Object hgt, int hgt_byte_offset, Object thkns, int thkns_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void mslp2thkns(float *  mslp, float *  hgt, float *  thkns, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void mslp2thkns1(Object mslp, int mslp_byte_offset, Object hgt, int hgt_byte_offset, Object thkns, int thkns_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void mslp2thkns(float *  mslp, float *  hgt, float *  thkns, int *  mni, int *  ni, int *  nj); </code>    */
  public static void mslp2thkns(float[] mslp, int mslp_offset, float[] hgt, int hgt_offset, float[] thkns, int thkns_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(mslp != null && mslp.length <= mslp_offset)
      throw new RuntimeException("array offset argument \"mslp_offset\" (" + mslp_offset + ") equals or exceeds array length (" + mslp.length + ")");
    if(hgt != null && hgt.length <= hgt_offset)
      throw new RuntimeException("array offset argument \"hgt_offset\" (" + hgt_offset + ") equals or exceeds array length (" + hgt.length + ")");
    if(thkns != null && thkns.length <= thkns_offset)
      throw new RuntimeException("array offset argument \"thkns_offset\" (" + thkns_offset + ") equals or exceeds array length (" + thkns.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        mslp2thkns1(mslp, BufferFactory.SIZEOF_FLOAT * mslp_offset, hgt, BufferFactory.SIZEOF_FLOAT * hgt_offset, thkns, BufferFactory.SIZEOF_FLOAT * thkns_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void mult_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void mult_aray(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        mult_aray0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      mult_aray1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void mult_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void mult_aray0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void mult_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void mult_aray1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void mult_aray(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void mult_aray(float[] a, int a_offset, float[] b, int b_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        mult_aray1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void mult_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void mult_by_cnst(java.nio.FloatBuffer a, java.nio.FloatBuffer cnst, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (cnst != null && _direct != BufferFactory.isDirect(cnst))
      throw new RuntimeException("Argument \"cnst\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        mult_by_cnst0(a, BufferFactory.getDirectBufferByteOffset(a), cnst, BufferFactory.getDirectBufferByteOffset(cnst), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      mult_by_cnst1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(cnst), BufferFactory.getIndirectBufferByteOffset(cnst), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void mult_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void mult_by_cnst0(Object a, int a_byte_offset, Object cnst, int cnst_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void mult_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void mult_by_cnst1(Object a, int a_byte_offset, Object cnst, int cnst_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void mult_by_cnst(float *  a, float *  cnst, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void mult_by_cnst(float[] a, int a_offset, float[] cnst, int cnst_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(cnst != null && cnst.length <= cnst_offset)
      throw new RuntimeException("array offset argument \"cnst_offset\" (" + cnst_offset + ") equals or exceeds array length (" + cnst.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        mult_by_cnst1(a, BufferFactory.SIZEOF_FLOAT * a_offset, cnst, BufferFactory.SIZEOF_FLOAT * cnst_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void mxtp(float *  ANSOL, float *  DELTAP, float *  SFCP, float *  P2, float *  TL, float *  DELTAZ, int *  LVL, float *  CTMAX); </code>    */
  public static void mxtp(java.nio.FloatBuffer ANSOL, java.nio.FloatBuffer DELTAP, java.nio.FloatBuffer SFCP, java.nio.FloatBuffer P2, java.nio.FloatBuffer TL, java.nio.FloatBuffer DELTAZ, java.nio.IntBuffer LVL, java.nio.FloatBuffer CTMAX)
  {
    boolean _direct = BufferFactory.isDirect(ANSOL);
    if (DELTAP != null && _direct != BufferFactory.isDirect(DELTAP))
      throw new RuntimeException("Argument \"DELTAP\" : Buffers passed to this method must all be either direct or indirect");
    if (SFCP != null && _direct != BufferFactory.isDirect(SFCP))
      throw new RuntimeException("Argument \"SFCP\" : Buffers passed to this method must all be either direct or indirect");
    if (P2 != null && _direct != BufferFactory.isDirect(P2))
      throw new RuntimeException("Argument \"P2\" : Buffers passed to this method must all be either direct or indirect");
    if (TL != null && _direct != BufferFactory.isDirect(TL))
      throw new RuntimeException("Argument \"TL\" : Buffers passed to this method must all be either direct or indirect");
    if (DELTAZ != null && _direct != BufferFactory.isDirect(DELTAZ))
      throw new RuntimeException("Argument \"DELTAZ\" : Buffers passed to this method must all be either direct or indirect");
    if (LVL != null && _direct != BufferFactory.isDirect(LVL))
      throw new RuntimeException("Argument \"LVL\" : Buffers passed to this method must all be either direct or indirect");
    if (CTMAX != null && _direct != BufferFactory.isDirect(CTMAX))
      throw new RuntimeException("Argument \"CTMAX\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        mxtp0(ANSOL, BufferFactory.getDirectBufferByteOffset(ANSOL), DELTAP, BufferFactory.getDirectBufferByteOffset(DELTAP), SFCP, BufferFactory.getDirectBufferByteOffset(SFCP), P2, BufferFactory.getDirectBufferByteOffset(P2), TL, BufferFactory.getDirectBufferByteOffset(TL), DELTAZ, BufferFactory.getDirectBufferByteOffset(DELTAZ), LVL, BufferFactory.getDirectBufferByteOffset(LVL), CTMAX, BufferFactory.getDirectBufferByteOffset(CTMAX));
    } else {
      mxtp1(BufferFactory.getArray(ANSOL), BufferFactory.getIndirectBufferByteOffset(ANSOL), BufferFactory.getArray(DELTAP), BufferFactory.getIndirectBufferByteOffset(DELTAP), BufferFactory.getArray(SFCP), BufferFactory.getIndirectBufferByteOffset(SFCP), BufferFactory.getArray(P2), BufferFactory.getIndirectBufferByteOffset(P2), BufferFactory.getArray(TL), BufferFactory.getIndirectBufferByteOffset(TL), BufferFactory.getArray(DELTAZ), BufferFactory.getIndirectBufferByteOffset(DELTAZ), BufferFactory.getArray(LVL), BufferFactory.getIndirectBufferByteOffset(LVL), BufferFactory.getArray(CTMAX), BufferFactory.getIndirectBufferByteOffset(CTMAX));
    }
  }

  /** Entry point to C language function: <br> <code> void mxtp(float *  ANSOL, float *  DELTAP, float *  SFCP, float *  P2, float *  TL, float *  DELTAZ, int *  LVL, float *  CTMAX); </code>    */
  private static native void mxtp0(Object ANSOL, int ANSOL_byte_offset, Object DELTAP, int DELTAP_byte_offset, Object SFCP, int SFCP_byte_offset, Object P2, int P2_byte_offset, Object TL, int TL_byte_offset, Object DELTAZ, int DELTAZ_byte_offset, Object LVL, int LVL_byte_offset, Object CTMAX, int CTMAX_byte_offset);

  /** Entry point to C language function: <br> <code> void mxtp(float *  ANSOL, float *  DELTAP, float *  SFCP, float *  P2, float *  TL, float *  DELTAZ, int *  LVL, float *  CTMAX); </code>    */
  private static native void mxtp1(Object ANSOL, int ANSOL_byte_offset, Object DELTAP, int DELTAP_byte_offset, Object SFCP, int SFCP_byte_offset, Object P2, int P2_byte_offset, Object TL, int TL_byte_offset, Object DELTAZ, int DELTAZ_byte_offset, Object LVL, int LVL_byte_offset, Object CTMAX, int CTMAX_byte_offset);

  /** Interface to C language function: <br> <code> void mxtp(float *  ANSOL, float *  DELTAP, float *  SFCP, float *  P2, float *  TL, float *  DELTAZ, int *  LVL, float *  CTMAX); </code>    */
  public static void mxtp(float[] ANSOL, int ANSOL_offset, float[] DELTAP, int DELTAP_offset, float[] SFCP, int SFCP_offset, float[] P2, int P2_offset, float[] TL, int TL_offset, float[] DELTAZ, int DELTAZ_offset, int[] LVL, int LVL_offset, float[] CTMAX, int CTMAX_offset)
  {
    if(ANSOL != null && ANSOL.length <= ANSOL_offset)
      throw new RuntimeException("array offset argument \"ANSOL_offset\" (" + ANSOL_offset + ") equals or exceeds array length (" + ANSOL.length + ")");
    if(DELTAP != null && DELTAP.length <= DELTAP_offset)
      throw new RuntimeException("array offset argument \"DELTAP_offset\" (" + DELTAP_offset + ") equals or exceeds array length (" + DELTAP.length + ")");
    if(SFCP != null && SFCP.length <= SFCP_offset)
      throw new RuntimeException("array offset argument \"SFCP_offset\" (" + SFCP_offset + ") equals or exceeds array length (" + SFCP.length + ")");
    if(P2 != null && P2.length <= P2_offset)
      throw new RuntimeException("array offset argument \"P2_offset\" (" + P2_offset + ") equals or exceeds array length (" + P2.length + ")");
    if(TL != null && TL.length <= TL_offset)
      throw new RuntimeException("array offset argument \"TL_offset\" (" + TL_offset + ") equals or exceeds array length (" + TL.length + ")");
    if(DELTAZ != null && DELTAZ.length <= DELTAZ_offset)
      throw new RuntimeException("array offset argument \"DELTAZ_offset\" (" + DELTAZ_offset + ") equals or exceeds array length (" + DELTAZ.length + ")");
    if(LVL != null && LVL.length <= LVL_offset)
      throw new RuntimeException("array offset argument \"LVL_offset\" (" + LVL_offset + ") equals or exceeds array length (" + LVL.length + ")");
    if(CTMAX != null && CTMAX.length <= CTMAX_offset)
      throw new RuntimeException("array offset argument \"CTMAX_offset\" (" + CTMAX_offset + ") equals or exceeds array length (" + CTMAX.length + ")");
        mxtp1(ANSOL, BufferFactory.SIZEOF_FLOAT * ANSOL_offset, DELTAP, BufferFactory.SIZEOF_FLOAT * DELTAP_offset, SFCP, BufferFactory.SIZEOF_FLOAT * SFCP_offset, P2, BufferFactory.SIZEOF_FLOAT * P2_offset, TL, BufferFactory.SIZEOF_FLOAT * TL_offset, DELTAZ, BufferFactory.SIZEOF_FLOAT * DELTAZ_offset, LVL, BufferFactory.SIZEOF_INT * LVL_offset, CTMAX, BufferFactory.SIZEOF_FLOAT * CTMAX_offset);

  }

  /** Interface to C language function: <br> <code> float mytw(float *  t, float *  td, float *  p); </code>    */
  public static float mytw(java.nio.FloatBuffer t, java.nio.FloatBuffer td, java.nio.FloatBuffer p)
  {
    boolean _direct = BufferFactory.isDirect(t);
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return mytw0(t, BufferFactory.getDirectBufferByteOffset(t), td, BufferFactory.getDirectBufferByteOffset(td), p, BufferFactory.getDirectBufferByteOffset(p));
    } else {
      return mytw1(BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p));
    }
  }

  /** Entry point to C language function: <br> <code> float mytw(float *  t, float *  td, float *  p); </code>    */
  private static native float mytw0(Object t, int t_byte_offset, Object td, int td_byte_offset, Object p, int p_byte_offset);

  /** Entry point to C language function: <br> <code> float mytw(float *  t, float *  td, float *  p); </code>    */
  private static native float mytw1(Object t, int t_byte_offset, Object td, int td_byte_offset, Object p, int p_byte_offset);

  /** Interface to C language function: <br> <code> float mytw(float *  t, float *  td, float *  p); </code>    */
  public static float mytw(float[] t, int t_offset, float[] td, int td_offset, float[] p, int p_offset)
  {
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
        return mytw1(t, BufferFactory.SIZEOF_FLOAT * t_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset);

  }

  /** Interface to C language function: <br> <code> void nadgdt(float *  u, float *  v, float *  a, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  dadxdt, float *  dadydt); </code>    */
  public static void nadgdt(java.nio.FloatBuffer u, java.nio.FloatBuffer v, java.nio.FloatBuffer a, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer dadxdt, java.nio.FloatBuffer dadydt)
  {
    boolean _direct = BufferFactory.isDirect(u);
    if (v != null && _direct != BufferFactory.isDirect(v))
      throw new RuntimeException("Argument \"v\" : Buffers passed to this method must all be either direct or indirect");
    if (a != null && _direct != BufferFactory.isDirect(a))
      throw new RuntimeException("Argument \"a\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (dadxdt != null && _direct != BufferFactory.isDirect(dadxdt))
      throw new RuntimeException("Argument \"dadxdt\" : Buffers passed to this method must all be either direct or indirect");
    if (dadydt != null && _direct != BufferFactory.isDirect(dadydt))
      throw new RuntimeException("Argument \"dadydt\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        nadgdt0(u, BufferFactory.getDirectBufferByteOffset(u), v, BufferFactory.getDirectBufferByteOffset(v), a, BufferFactory.getDirectBufferByteOffset(a), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), dadxdt, BufferFactory.getDirectBufferByteOffset(dadxdt), dadydt, BufferFactory.getDirectBufferByteOffset(dadydt));
    } else {
      nadgdt1(BufferFactory.getArray(u), BufferFactory.getIndirectBufferByteOffset(u), BufferFactory.getArray(v), BufferFactory.getIndirectBufferByteOffset(v), BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(dadxdt), BufferFactory.getIndirectBufferByteOffset(dadxdt), BufferFactory.getArray(dadydt), BufferFactory.getIndirectBufferByteOffset(dadydt));
    }
  }

  /** Entry point to C language function: <br> <code> void nadgdt(float *  u, float *  v, float *  a, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  dadxdt, float *  dadydt); </code>    */
  private static native void nadgdt0(Object u, int u_byte_offset, Object v, int v_byte_offset, Object a, int a_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object dadxdt, int dadxdt_byte_offset, Object dadydt, int dadydt_byte_offset);

  /** Entry point to C language function: <br> <code> void nadgdt(float *  u, float *  v, float *  a, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  dadxdt, float *  dadydt); </code>    */
  private static native void nadgdt1(Object u, int u_byte_offset, Object v, int v_byte_offset, Object a, int a_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object dadxdt, int dadxdt_byte_offset, Object dadydt, int dadydt_byte_offset);

  /** Interface to C language function: <br> <code> void nadgdt(float *  u, float *  v, float *  a, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  dadxdt, float *  dadydt); </code>    */
  public static void nadgdt(float[] u, int u_offset, float[] v, int v_offset, float[] a, int a_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] dadxdt, int dadxdt_offset, float[] dadydt, int dadydt_offset)
  {
    if(u != null && u.length <= u_offset)
      throw new RuntimeException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(dadxdt != null && dadxdt.length <= dadxdt_offset)
      throw new RuntimeException("array offset argument \"dadxdt_offset\" (" + dadxdt_offset + ") equals or exceeds array length (" + dadxdt.length + ")");
    if(dadydt != null && dadydt.length <= dadydt_offset)
      throw new RuntimeException("array offset argument \"dadydt_offset\" (" + dadydt_offset + ") equals or exceeds array length (" + dadydt.length + ")");
        nadgdt1(u, BufferFactory.SIZEOF_FLOAT * u_offset, v, BufferFactory.SIZEOF_FLOAT * v_offset, a, BufferFactory.SIZEOF_FLOAT * a_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, dadxdt, BufferFactory.SIZEOF_FLOAT * dadxdt_offset, dadydt, BufferFactory.SIZEOF_FLOAT * dadydt_offset);

  }

  /** Interface to C language function: <br> <code> void natlog(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  public static void natlog(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        natlog0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      natlog1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void natlog(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void natlog0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void natlog(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void natlog1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void natlog(float *  a, float *  b, int *  mni, int *  ni, int *  nj); </code>    */
  public static void natlog(float[] a, int a_offset, float[] b, int b_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        natlog1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void negarea(float *  PCB, float *  TCB, float *  HCB, float *  PLFC, float *  HLFC, float *  TLFC, float *  THDPAR, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  CINFRMCAPE, float *  NEGBUOY); </code>    */
  public static void negarea(java.nio.FloatBuffer PCB, java.nio.FloatBuffer TCB, java.nio.FloatBuffer HCB, java.nio.FloatBuffer PLFC, java.nio.FloatBuffer HLFC, java.nio.FloatBuffer TLFC, java.nio.FloatBuffer THDPAR, java.nio.FloatBuffer EPTPAR, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer TE, java.nio.FloatBuffer TP, java.nio.IntBuffer NPAR, java.nio.FloatBuffer CINFRMCAPE, java.nio.FloatBuffer NEGBUOY)
  {
    boolean _direct = BufferFactory.isDirect(PCB);
    if (TCB != null && _direct != BufferFactory.isDirect(TCB))
      throw new RuntimeException("Argument \"TCB\" : Buffers passed to this method must all be either direct or indirect");
    if (HCB != null && _direct != BufferFactory.isDirect(HCB))
      throw new RuntimeException("Argument \"HCB\" : Buffers passed to this method must all be either direct or indirect");
    if (PLFC != null && _direct != BufferFactory.isDirect(PLFC))
      throw new RuntimeException("Argument \"PLFC\" : Buffers passed to this method must all be either direct or indirect");
    if (HLFC != null && _direct != BufferFactory.isDirect(HLFC))
      throw new RuntimeException("Argument \"HLFC\" : Buffers passed to this method must all be either direct or indirect");
    if (TLFC != null && _direct != BufferFactory.isDirect(TLFC))
      throw new RuntimeException("Argument \"TLFC\" : Buffers passed to this method must all be either direct or indirect");
    if (THDPAR != null && _direct != BufferFactory.isDirect(THDPAR))
      throw new RuntimeException("Argument \"THDPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (EPTPAR != null && _direct != BufferFactory.isDirect(EPTPAR))
      throw new RuntimeException("Argument \"EPTPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (TE != null && _direct != BufferFactory.isDirect(TE))
      throw new RuntimeException("Argument \"TE\" : Buffers passed to this method must all be either direct or indirect");
    if (TP != null && _direct != BufferFactory.isDirect(TP))
      throw new RuntimeException("Argument \"TP\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (CINFRMCAPE != null && _direct != BufferFactory.isDirect(CINFRMCAPE))
      throw new RuntimeException("Argument \"CINFRMCAPE\" : Buffers passed to this method must all be either direct or indirect");
    if (NEGBUOY != null && _direct != BufferFactory.isDirect(NEGBUOY))
      throw new RuntimeException("Argument \"NEGBUOY\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        negarea0(PCB, BufferFactory.getDirectBufferByteOffset(PCB), TCB, BufferFactory.getDirectBufferByteOffset(TCB), HCB, BufferFactory.getDirectBufferByteOffset(HCB), PLFC, BufferFactory.getDirectBufferByteOffset(PLFC), HLFC, BufferFactory.getDirectBufferByteOffset(HLFC), TLFC, BufferFactory.getDirectBufferByteOffset(TLFC), THDPAR, BufferFactory.getDirectBufferByteOffset(THDPAR), EPTPAR, BufferFactory.getDirectBufferByteOffset(EPTPAR), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), TE, BufferFactory.getDirectBufferByteOffset(TE), TP, BufferFactory.getDirectBufferByteOffset(TP), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), CINFRMCAPE, BufferFactory.getDirectBufferByteOffset(CINFRMCAPE), NEGBUOY, BufferFactory.getDirectBufferByteOffset(NEGBUOY));
    } else {
      negarea1(BufferFactory.getArray(PCB), BufferFactory.getIndirectBufferByteOffset(PCB), BufferFactory.getArray(TCB), BufferFactory.getIndirectBufferByteOffset(TCB), BufferFactory.getArray(HCB), BufferFactory.getIndirectBufferByteOffset(HCB), BufferFactory.getArray(PLFC), BufferFactory.getIndirectBufferByteOffset(PLFC), BufferFactory.getArray(HLFC), BufferFactory.getIndirectBufferByteOffset(HLFC), BufferFactory.getArray(TLFC), BufferFactory.getIndirectBufferByteOffset(TLFC), BufferFactory.getArray(THDPAR), BufferFactory.getIndirectBufferByteOffset(THDPAR), BufferFactory.getArray(EPTPAR), BufferFactory.getIndirectBufferByteOffset(EPTPAR), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(TE), BufferFactory.getIndirectBufferByteOffset(TE), BufferFactory.getArray(TP), BufferFactory.getIndirectBufferByteOffset(TP), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(CINFRMCAPE), BufferFactory.getIndirectBufferByteOffset(CINFRMCAPE), BufferFactory.getArray(NEGBUOY), BufferFactory.getIndirectBufferByteOffset(NEGBUOY));
    }
  }

  /** Entry point to C language function: <br> <code> void negarea(float *  PCB, float *  TCB, float *  HCB, float *  PLFC, float *  HLFC, float *  TLFC, float *  THDPAR, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  CINFRMCAPE, float *  NEGBUOY); </code>    */
  private static native void negarea0(Object PCB, int PCB_byte_offset, Object TCB, int TCB_byte_offset, Object HCB, int HCB_byte_offset, Object PLFC, int PLFC_byte_offset, Object HLFC, int HLFC_byte_offset, Object TLFC, int TLFC_byte_offset, Object THDPAR, int THDPAR_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TE, int TE_byte_offset, Object TP, int TP_byte_offset, Object NPAR, int NPAR_byte_offset, Object CINFRMCAPE, int CINFRMCAPE_byte_offset, Object NEGBUOY, int NEGBUOY_byte_offset);

  /** Entry point to C language function: <br> <code> void negarea(float *  PCB, float *  TCB, float *  HCB, float *  PLFC, float *  HLFC, float *  TLFC, float *  THDPAR, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  CINFRMCAPE, float *  NEGBUOY); </code>    */
  private static native void negarea1(Object PCB, int PCB_byte_offset, Object TCB, int TCB_byte_offset, Object HCB, int HCB_byte_offset, Object PLFC, int PLFC_byte_offset, Object HLFC, int HLFC_byte_offset, Object TLFC, int TLFC_byte_offset, Object THDPAR, int THDPAR_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TE, int TE_byte_offset, Object TP, int TP_byte_offset, Object NPAR, int NPAR_byte_offset, Object CINFRMCAPE, int CINFRMCAPE_byte_offset, Object NEGBUOY, int NEGBUOY_byte_offset);

  /** Interface to C language function: <br> <code> void negarea(float *  PCB, float *  TCB, float *  HCB, float *  PLFC, float *  HLFC, float *  TLFC, float *  THDPAR, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  CINFRMCAPE, float *  NEGBUOY); </code>    */
  public static void negarea(float[] PCB, int PCB_offset, float[] TCB, int TCB_offset, float[] HCB, int HCB_offset, float[] PLFC, int PLFC_offset, float[] HLFC, int HLFC_offset, float[] TLFC, int TLFC_offset, float[] THDPAR, int THDPAR_offset, float[] EPTPAR, int EPTPAR_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] TE, int TE_offset, float[] TP, int TP_offset, int[] NPAR, int NPAR_offset, float[] CINFRMCAPE, int CINFRMCAPE_offset, float[] NEGBUOY, int NEGBUOY_offset)
  {
    if(PCB != null && PCB.length <= PCB_offset)
      throw new RuntimeException("array offset argument \"PCB_offset\" (" + PCB_offset + ") equals or exceeds array length (" + PCB.length + ")");
    if(TCB != null && TCB.length <= TCB_offset)
      throw new RuntimeException("array offset argument \"TCB_offset\" (" + TCB_offset + ") equals or exceeds array length (" + TCB.length + ")");
    if(HCB != null && HCB.length <= HCB_offset)
      throw new RuntimeException("array offset argument \"HCB_offset\" (" + HCB_offset + ") equals or exceeds array length (" + HCB.length + ")");
    if(PLFC != null && PLFC.length <= PLFC_offset)
      throw new RuntimeException("array offset argument \"PLFC_offset\" (" + PLFC_offset + ") equals or exceeds array length (" + PLFC.length + ")");
    if(HLFC != null && HLFC.length <= HLFC_offset)
      throw new RuntimeException("array offset argument \"HLFC_offset\" (" + HLFC_offset + ") equals or exceeds array length (" + HLFC.length + ")");
    if(TLFC != null && TLFC.length <= TLFC_offset)
      throw new RuntimeException("array offset argument \"TLFC_offset\" (" + TLFC_offset + ") equals or exceeds array length (" + TLFC.length + ")");
    if(THDPAR != null && THDPAR.length <= THDPAR_offset)
      throw new RuntimeException("array offset argument \"THDPAR_offset\" (" + THDPAR_offset + ") equals or exceeds array length (" + THDPAR.length + ")");
    if(EPTPAR != null && EPTPAR.length <= EPTPAR_offset)
      throw new RuntimeException("array offset argument \"EPTPAR_offset\" (" + EPTPAR_offset + ") equals or exceeds array length (" + EPTPAR.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(TE != null && TE.length <= TE_offset)
      throw new RuntimeException("array offset argument \"TE_offset\" (" + TE_offset + ") equals or exceeds array length (" + TE.length + ")");
    if(TP != null && TP.length <= TP_offset)
      throw new RuntimeException("array offset argument \"TP_offset\" (" + TP_offset + ") equals or exceeds array length (" + TP.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(CINFRMCAPE != null && CINFRMCAPE.length <= CINFRMCAPE_offset)
      throw new RuntimeException("array offset argument \"CINFRMCAPE_offset\" (" + CINFRMCAPE_offset + ") equals or exceeds array length (" + CINFRMCAPE.length + ")");
    if(NEGBUOY != null && NEGBUOY.length <= NEGBUOY_offset)
      throw new RuntimeException("array offset argument \"NEGBUOY_offset\" (" + NEGBUOY_offset + ") equals or exceeds array length (" + NEGBUOY.length + ")");
        negarea1(PCB, BufferFactory.SIZEOF_FLOAT * PCB_offset, TCB, BufferFactory.SIZEOF_FLOAT * TCB_offset, HCB, BufferFactory.SIZEOF_FLOAT * HCB_offset, PLFC, BufferFactory.SIZEOF_FLOAT * PLFC_offset, HLFC, BufferFactory.SIZEOF_FLOAT * HLFC_offset, TLFC, BufferFactory.SIZEOF_FLOAT * TLFC_offset, THDPAR, BufferFactory.SIZEOF_FLOAT * THDPAR_offset, EPTPAR, BufferFactory.SIZEOF_FLOAT * EPTPAR_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, TE, BufferFactory.SIZEOF_FLOAT * TE_offset, TP, BufferFactory.SIZEOF_FLOAT * TP_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, CINFRMCAPE, BufferFactory.SIZEOF_FLOAT * CINFRMCAPE_offset, NEGBUOY, BufferFactory.SIZEOF_FLOAT * NEGBUOY_offset);

  }

  /** Interface to C language function: <br> <code> void posarea(float *  PLFC, float *  PEQLEV, float *  TLFC, float *  TEQLEV, float *  HLFC, float *  HEQLEV, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  BUOY, float *  CIN); </code>    */
  public static void posarea(java.nio.FloatBuffer PLFC, java.nio.FloatBuffer PEQLEV, java.nio.FloatBuffer TLFC, java.nio.FloatBuffer TEQLEV, java.nio.FloatBuffer HLFC, java.nio.FloatBuffer HEQLEV, java.nio.FloatBuffer EPTPAR, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer TE, java.nio.FloatBuffer TP, java.nio.IntBuffer NPAR, java.nio.FloatBuffer BUOY, java.nio.FloatBuffer CIN)
  {
    boolean _direct = BufferFactory.isDirect(PLFC);
    if (PEQLEV != null && _direct != BufferFactory.isDirect(PEQLEV))
      throw new RuntimeException("Argument \"PEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (TLFC != null && _direct != BufferFactory.isDirect(TLFC))
      throw new RuntimeException("Argument \"TLFC\" : Buffers passed to this method must all be either direct or indirect");
    if (TEQLEV != null && _direct != BufferFactory.isDirect(TEQLEV))
      throw new RuntimeException("Argument \"TEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (HLFC != null && _direct != BufferFactory.isDirect(HLFC))
      throw new RuntimeException("Argument \"HLFC\" : Buffers passed to this method must all be either direct or indirect");
    if (HEQLEV != null && _direct != BufferFactory.isDirect(HEQLEV))
      throw new RuntimeException("Argument \"HEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (EPTPAR != null && _direct != BufferFactory.isDirect(EPTPAR))
      throw new RuntimeException("Argument \"EPTPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (TE != null && _direct != BufferFactory.isDirect(TE))
      throw new RuntimeException("Argument \"TE\" : Buffers passed to this method must all be either direct or indirect");
    if (TP != null && _direct != BufferFactory.isDirect(TP))
      throw new RuntimeException("Argument \"TP\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (BUOY != null && _direct != BufferFactory.isDirect(BUOY))
      throw new RuntimeException("Argument \"BUOY\" : Buffers passed to this method must all be either direct or indirect");
    if (CIN != null && _direct != BufferFactory.isDirect(CIN))
      throw new RuntimeException("Argument \"CIN\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        posarea0(PLFC, BufferFactory.getDirectBufferByteOffset(PLFC), PEQLEV, BufferFactory.getDirectBufferByteOffset(PEQLEV), TLFC, BufferFactory.getDirectBufferByteOffset(TLFC), TEQLEV, BufferFactory.getDirectBufferByteOffset(TEQLEV), HLFC, BufferFactory.getDirectBufferByteOffset(HLFC), HEQLEV, BufferFactory.getDirectBufferByteOffset(HEQLEV), EPTPAR, BufferFactory.getDirectBufferByteOffset(EPTPAR), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), TE, BufferFactory.getDirectBufferByteOffset(TE), TP, BufferFactory.getDirectBufferByteOffset(TP), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), BUOY, BufferFactory.getDirectBufferByteOffset(BUOY), CIN, BufferFactory.getDirectBufferByteOffset(CIN));
    } else {
      posarea1(BufferFactory.getArray(PLFC), BufferFactory.getIndirectBufferByteOffset(PLFC), BufferFactory.getArray(PEQLEV), BufferFactory.getIndirectBufferByteOffset(PEQLEV), BufferFactory.getArray(TLFC), BufferFactory.getIndirectBufferByteOffset(TLFC), BufferFactory.getArray(TEQLEV), BufferFactory.getIndirectBufferByteOffset(TEQLEV), BufferFactory.getArray(HLFC), BufferFactory.getIndirectBufferByteOffset(HLFC), BufferFactory.getArray(HEQLEV), BufferFactory.getIndirectBufferByteOffset(HEQLEV), BufferFactory.getArray(EPTPAR), BufferFactory.getIndirectBufferByteOffset(EPTPAR), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(TE), BufferFactory.getIndirectBufferByteOffset(TE), BufferFactory.getArray(TP), BufferFactory.getIndirectBufferByteOffset(TP), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(BUOY), BufferFactory.getIndirectBufferByteOffset(BUOY), BufferFactory.getArray(CIN), BufferFactory.getIndirectBufferByteOffset(CIN));
    }
  }

  /** Entry point to C language function: <br> <code> void posarea(float *  PLFC, float *  PEQLEV, float *  TLFC, float *  TEQLEV, float *  HLFC, float *  HEQLEV, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  BUOY, float *  CIN); </code>    */
  private static native void posarea0(Object PLFC, int PLFC_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object TLFC, int TLFC_byte_offset, Object TEQLEV, int TEQLEV_byte_offset, Object HLFC, int HLFC_byte_offset, Object HEQLEV, int HEQLEV_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TE, int TE_byte_offset, Object TP, int TP_byte_offset, Object NPAR, int NPAR_byte_offset, Object BUOY, int BUOY_byte_offset, Object CIN, int CIN_byte_offset);

  /** Entry point to C language function: <br> <code> void posarea(float *  PLFC, float *  PEQLEV, float *  TLFC, float *  TEQLEV, float *  HLFC, float *  HEQLEV, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  BUOY, float *  CIN); </code>    */
  private static native void posarea1(Object PLFC, int PLFC_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object TLFC, int TLFC_byte_offset, Object TEQLEV, int TEQLEV_byte_offset, Object HLFC, int HLFC_byte_offset, Object HEQLEV, int HEQLEV_byte_offset, Object EPTPAR, int EPTPAR_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TE, int TE_byte_offset, Object TP, int TP_byte_offset, Object NPAR, int NPAR_byte_offset, Object BUOY, int BUOY_byte_offset, Object CIN, int CIN_byte_offset);

  /** Interface to C language function: <br> <code> void posarea(float *  PLFC, float *  PEQLEV, float *  TLFC, float *  TEQLEV, float *  HLFC, float *  HEQLEV, float *  EPTPAR, float *  P, float *  HT, float *  TE, float *  TP, int *  NPAR, float *  BUOY, float *  CIN); </code>    */
  public static void posarea(float[] PLFC, int PLFC_offset, float[] PEQLEV, int PEQLEV_offset, float[] TLFC, int TLFC_offset, float[] TEQLEV, int TEQLEV_offset, float[] HLFC, int HLFC_offset, float[] HEQLEV, int HEQLEV_offset, float[] EPTPAR, int EPTPAR_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] TE, int TE_offset, float[] TP, int TP_offset, int[] NPAR, int NPAR_offset, float[] BUOY, int BUOY_offset, float[] CIN, int CIN_offset)
  {
    if(PLFC != null && PLFC.length <= PLFC_offset)
      throw new RuntimeException("array offset argument \"PLFC_offset\" (" + PLFC_offset + ") equals or exceeds array length (" + PLFC.length + ")");
    if(PEQLEV != null && PEQLEV.length <= PEQLEV_offset)
      throw new RuntimeException("array offset argument \"PEQLEV_offset\" (" + PEQLEV_offset + ") equals or exceeds array length (" + PEQLEV.length + ")");
    if(TLFC != null && TLFC.length <= TLFC_offset)
      throw new RuntimeException("array offset argument \"TLFC_offset\" (" + TLFC_offset + ") equals or exceeds array length (" + TLFC.length + ")");
    if(TEQLEV != null && TEQLEV.length <= TEQLEV_offset)
      throw new RuntimeException("array offset argument \"TEQLEV_offset\" (" + TEQLEV_offset + ") equals or exceeds array length (" + TEQLEV.length + ")");
    if(HLFC != null && HLFC.length <= HLFC_offset)
      throw new RuntimeException("array offset argument \"HLFC_offset\" (" + HLFC_offset + ") equals or exceeds array length (" + HLFC.length + ")");
    if(HEQLEV != null && HEQLEV.length <= HEQLEV_offset)
      throw new RuntimeException("array offset argument \"HEQLEV_offset\" (" + HEQLEV_offset + ") equals or exceeds array length (" + HEQLEV.length + ")");
    if(EPTPAR != null && EPTPAR.length <= EPTPAR_offset)
      throw new RuntimeException("array offset argument \"EPTPAR_offset\" (" + EPTPAR_offset + ") equals or exceeds array length (" + EPTPAR.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(TE != null && TE.length <= TE_offset)
      throw new RuntimeException("array offset argument \"TE_offset\" (" + TE_offset + ") equals or exceeds array length (" + TE.length + ")");
    if(TP != null && TP.length <= TP_offset)
      throw new RuntimeException("array offset argument \"TP_offset\" (" + TP_offset + ") equals or exceeds array length (" + TP.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(BUOY != null && BUOY.length <= BUOY_offset)
      throw new RuntimeException("array offset argument \"BUOY_offset\" (" + BUOY_offset + ") equals or exceeds array length (" + BUOY.length + ")");
    if(CIN != null && CIN.length <= CIN_offset)
      throw new RuntimeException("array offset argument \"CIN_offset\" (" + CIN_offset + ") equals or exceeds array length (" + CIN.length + ")");
        posarea1(PLFC, BufferFactory.SIZEOF_FLOAT * PLFC_offset, PEQLEV, BufferFactory.SIZEOF_FLOAT * PEQLEV_offset, TLFC, BufferFactory.SIZEOF_FLOAT * TLFC_offset, TEQLEV, BufferFactory.SIZEOF_FLOAT * TEQLEV_offset, HLFC, BufferFactory.SIZEOF_FLOAT * HLFC_offset, HEQLEV, BufferFactory.SIZEOF_FLOAT * HEQLEV_offset, EPTPAR, BufferFactory.SIZEOF_FLOAT * EPTPAR_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, TE, BufferFactory.SIZEOF_FLOAT * TE_offset, TP, BufferFactory.SIZEOF_FLOAT * TP_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, BUOY, BufferFactory.SIZEOF_FLOAT * BUOY_offset, CIN, BufferFactory.SIZEOF_FLOAT * CIN_offset);

  }

  /** Interface to C language function: <br> <code> float pottemp(float *  temp, float *  dwpt, float *  pres, int *  iw); </code>    */
  public static float pottemp(java.nio.FloatBuffer temp, java.nio.FloatBuffer dwpt, java.nio.FloatBuffer pres, java.nio.IntBuffer iw)
  {
    boolean _direct = BufferFactory.isDirect(temp);
    if (dwpt != null && _direct != BufferFactory.isDirect(dwpt))
      throw new RuntimeException("Argument \"dwpt\" : Buffers passed to this method must all be either direct or indirect");
    if (pres != null && _direct != BufferFactory.isDirect(pres))
      throw new RuntimeException("Argument \"pres\" : Buffers passed to this method must all be either direct or indirect");
    if (iw != null && _direct != BufferFactory.isDirect(iw))
      throw new RuntimeException("Argument \"iw\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return pottemp0(temp, BufferFactory.getDirectBufferByteOffset(temp), dwpt, BufferFactory.getDirectBufferByteOffset(dwpt), pres, BufferFactory.getDirectBufferByteOffset(pres), iw, BufferFactory.getDirectBufferByteOffset(iw));
    } else {
      return pottemp1(BufferFactory.getArray(temp), BufferFactory.getIndirectBufferByteOffset(temp), BufferFactory.getArray(dwpt), BufferFactory.getIndirectBufferByteOffset(dwpt), BufferFactory.getArray(pres), BufferFactory.getIndirectBufferByteOffset(pres), BufferFactory.getArray(iw), BufferFactory.getIndirectBufferByteOffset(iw));
    }
  }

  /** Entry point to C language function: <br> <code> float pottemp(float *  temp, float *  dwpt, float *  pres, int *  iw); </code>    */
  private static native float pottemp0(Object temp, int temp_byte_offset, Object dwpt, int dwpt_byte_offset, Object pres, int pres_byte_offset, Object iw, int iw_byte_offset);

  /** Entry point to C language function: <br> <code> float pottemp(float *  temp, float *  dwpt, float *  pres, int *  iw); </code>    */
  private static native float pottemp1(Object temp, int temp_byte_offset, Object dwpt, int dwpt_byte_offset, Object pres, int pres_byte_offset, Object iw, int iw_byte_offset);

  /** Interface to C language function: <br> <code> float pottemp(float *  temp, float *  dwpt, float *  pres, int *  iw); </code>    */
  public static float pottemp(float[] temp, int temp_offset, float[] dwpt, int dwpt_offset, float[] pres, int pres_offset, int[] iw, int iw_offset)
  {
    if(temp != null && temp.length <= temp_offset)
      throw new RuntimeException("array offset argument \"temp_offset\" (" + temp_offset + ") equals or exceeds array length (" + temp.length + ")");
    if(dwpt != null && dwpt.length <= dwpt_offset)
      throw new RuntimeException("array offset argument \"dwpt_offset\" (" + dwpt_offset + ") equals or exceeds array length (" + dwpt.length + ")");
    if(pres != null && pres.length <= pres_offset)
      throw new RuntimeException("array offset argument \"pres_offset\" (" + pres_offset + ") equals or exceeds array length (" + pres.length + ")");
    if(iw != null && iw.length <= iw_offset)
      throw new RuntimeException("array offset argument \"iw_offset\" (" + iw_offset + ") equals or exceeds array length (" + iw.length + ")");
        return pottemp1(temp, BufferFactory.SIZEOF_FLOAT * temp_offset, dwpt, BufferFactory.SIZEOF_FLOAT * dwpt_offset, pres, BufferFactory.SIZEOF_FLOAT * pres_offset, iw, BufferFactory.SIZEOF_INT * iw_offset);

  }

  /** Interface to C language function: <br> <code> void powercalc(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void powercalc(java.nio.FloatBuffer a, java.nio.FloatBuffer b, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        powercalc0(a, BufferFactory.getDirectBufferByteOffset(a), b, BufferFactory.getDirectBufferByteOffset(b), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      powercalc1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void powercalc(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void powercalc0(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void powercalc(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void powercalc1(Object a, int a_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void powercalc(float *  a, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void powercalc(float[] a, int a_offset, float[] b, int b_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        powercalc1(a, BufferFactory.SIZEOF_FLOAT * a_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void pseudolift(int *  n, float *  pstart, float *  pfinish, float *  soln); </code>    */
  public static void pseudolift(java.nio.IntBuffer n, java.nio.FloatBuffer pstart, java.nio.FloatBuffer pfinish, java.nio.FloatBuffer soln)
  {
    boolean _direct = BufferFactory.isDirect(n);
    if (pstart != null && _direct != BufferFactory.isDirect(pstart))
      throw new RuntimeException("Argument \"pstart\" : Buffers passed to this method must all be either direct or indirect");
    if (pfinish != null && _direct != BufferFactory.isDirect(pfinish))
      throw new RuntimeException("Argument \"pfinish\" : Buffers passed to this method must all be either direct or indirect");
    if (soln != null && _direct != BufferFactory.isDirect(soln))
      throw new RuntimeException("Argument \"soln\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        pseudolift0(n, BufferFactory.getDirectBufferByteOffset(n), pstart, BufferFactory.getDirectBufferByteOffset(pstart), pfinish, BufferFactory.getDirectBufferByteOffset(pfinish), soln, BufferFactory.getDirectBufferByteOffset(soln));
    } else {
      pseudolift1(BufferFactory.getArray(n), BufferFactory.getIndirectBufferByteOffset(n), BufferFactory.getArray(pstart), BufferFactory.getIndirectBufferByteOffset(pstart), BufferFactory.getArray(pfinish), BufferFactory.getIndirectBufferByteOffset(pfinish), BufferFactory.getArray(soln), BufferFactory.getIndirectBufferByteOffset(soln));
    }
  }

  /** Entry point to C language function: <br> <code> void pseudolift(int *  n, float *  pstart, float *  pfinish, float *  soln); </code>    */
  private static native void pseudolift0(Object n, int n_byte_offset, Object pstart, int pstart_byte_offset, Object pfinish, int pfinish_byte_offset, Object soln, int soln_byte_offset);

  /** Entry point to C language function: <br> <code> void pseudolift(int *  n, float *  pstart, float *  pfinish, float *  soln); </code>    */
  private static native void pseudolift1(Object n, int n_byte_offset, Object pstart, int pstart_byte_offset, Object pfinish, int pfinish_byte_offset, Object soln, int soln_byte_offset);

  /** Interface to C language function: <br> <code> void pseudolift(int *  n, float *  pstart, float *  pfinish, float *  soln); </code>    */
  public static void pseudolift(int[] n, int n_offset, float[] pstart, int pstart_offset, float[] pfinish, int pfinish_offset, float[] soln, int soln_offset)
  {
    if(n != null && n.length <= n_offset)
      throw new RuntimeException("array offset argument \"n_offset\" (" + n_offset + ") equals or exceeds array length (" + n.length + ")");
    if(pstart != null && pstart.length <= pstart_offset)
      throw new RuntimeException("array offset argument \"pstart_offset\" (" + pstart_offset + ") equals or exceeds array length (" + pstart.length + ")");
    if(pfinish != null && pfinish.length <= pfinish_offset)
      throw new RuntimeException("array offset argument \"pfinish_offset\" (" + pfinish_offset + ") equals or exceeds array length (" + pfinish.length + ")");
    if(soln != null && soln.length <= soln_offset)
      throw new RuntimeException("array offset argument \"soln_offset\" (" + soln_offset + ") equals or exceeds array length (" + soln.length + ")");
        pseudolift1(n, BufferFactory.SIZEOF_INT * n_offset, pstart, BufferFactory.SIZEOF_FLOAT * pstart_offset, pfinish, BufferFactory.SIZEOF_FLOAT * pfinish_offset, soln, BufferFactory.SIZEOF_FLOAT * soln_offset);

  }

  /** Interface to C language function: <br> <code> float ptozsa(float * ); </code>    */
  public static float ptozsa(java.nio.FloatBuffer arg0)
  {
    boolean _direct = BufferFactory.isDirect(arg0);
    if (_direct) {
        return ptozsa0(arg0, BufferFactory.getDirectBufferByteOffset(arg0));
    } else {
      return ptozsa1(BufferFactory.getArray(arg0), BufferFactory.getIndirectBufferByteOffset(arg0));
    }
  }

  /** Entry point to C language function: <br> <code> float ptozsa(float * ); </code>    */
  private static native float ptozsa0(Object arg0, int arg0_byte_offset);

  /** Entry point to C language function: <br> <code> float ptozsa(float * ); </code>    */
  private static native float ptozsa1(Object arg0, int arg0_byte_offset);

  /** Interface to C language function: <br> <code> float ptozsa(float * ); </code>    */
  public static float ptozsa(float[] arg0, int arg0_offset)
  {
    if(arg0 != null && arg0.length <= arg0_offset)
      throw new RuntimeException("array offset argument \"arg0_offset\" (" + arg0_offset + ") equals or exceeds array length (" + arg0.length + ")");
        return ptozsa1(arg0, BufferFactory.SIZEOF_FLOAT * arg0_offset);

  }

  /** Interface to C language function: <br> <code> void pvalue(float *  pres, float *  p, int *  np, float *  param, float *  value); </code>    */
  public static void pvalue(java.nio.FloatBuffer pres, java.nio.FloatBuffer p, java.nio.IntBuffer np, java.nio.FloatBuffer param, java.nio.FloatBuffer value)
  {
    boolean _direct = BufferFactory.isDirect(pres);
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (np != null && _direct != BufferFactory.isDirect(np))
      throw new RuntimeException("Argument \"np\" : Buffers passed to this method must all be either direct or indirect");
    if (param != null && _direct != BufferFactory.isDirect(param))
      throw new RuntimeException("Argument \"param\" : Buffers passed to this method must all be either direct or indirect");
    if (value != null && _direct != BufferFactory.isDirect(value))
      throw new RuntimeException("Argument \"value\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        pvalue0(pres, BufferFactory.getDirectBufferByteOffset(pres), p, BufferFactory.getDirectBufferByteOffset(p), np, BufferFactory.getDirectBufferByteOffset(np), param, BufferFactory.getDirectBufferByteOffset(param), value, BufferFactory.getDirectBufferByteOffset(value));
    } else {
      pvalue1(BufferFactory.getArray(pres), BufferFactory.getIndirectBufferByteOffset(pres), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(np), BufferFactory.getIndirectBufferByteOffset(np), BufferFactory.getArray(param), BufferFactory.getIndirectBufferByteOffset(param), BufferFactory.getArray(value), BufferFactory.getIndirectBufferByteOffset(value));
    }
  }

  /** Entry point to C language function: <br> <code> void pvalue(float *  pres, float *  p, int *  np, float *  param, float *  value); </code>    */
  private static native void pvalue0(Object pres, int pres_byte_offset, Object p, int p_byte_offset, Object np, int np_byte_offset, Object param, int param_byte_offset, Object value, int value_byte_offset);

  /** Entry point to C language function: <br> <code> void pvalue(float *  pres, float *  p, int *  np, float *  param, float *  value); </code>    */
  private static native void pvalue1(Object pres, int pres_byte_offset, Object p, int p_byte_offset, Object np, int np_byte_offset, Object param, int param_byte_offset, Object value, int value_byte_offset);

  /** Interface to C language function: <br> <code> void pvalue(float *  pres, float *  p, int *  np, float *  param, float *  value); </code>    */
  public static void pvalue(float[] pres, int pres_offset, float[] p, int p_offset, int[] np, int np_offset, float[] param, int param_offset, float[] value, int value_offset)
  {
    if(pres != null && pres.length <= pres_offset)
      throw new RuntimeException("array offset argument \"pres_offset\" (" + pres_offset + ") equals or exceeds array length (" + pres.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(np != null && np.length <= np_offset)
      throw new RuntimeException("array offset argument \"np_offset\" (" + np_offset + ") equals or exceeds array length (" + np.length + ")");
    if(param != null && param.length <= param_offset)
      throw new RuntimeException("array offset argument \"param_offset\" (" + param_offset + ") equals or exceeds array length (" + param.length + ")");
    if(value != null && value.length <= value_offset)
      throw new RuntimeException("array offset argument \"value_offset\" (" + value_offset + ") equals or exceeds array length (" + value.length + ")");
        pvalue1(pres, BufferFactory.SIZEOF_FLOAT * pres_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset, np, BufferFactory.SIZEOF_INT * np_offset, param, BufferFactory.SIZEOF_FLOAT * param_offset, value, BufferFactory.SIZEOF_FLOAT * value_offset);

  }

  /** Interface to C language function: <br> <code> void pvpres(float *  t_up, float *  t_low, float *  p_up, float *  p_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dtdx1, float *  dtdy1, float *  dtdx2, float *  dtdy2, float *  dx, float *  dy, float *  coriolis); </code>    */
  public static void pvpres(java.nio.FloatBuffer t_up, java.nio.FloatBuffer t_low, java.nio.FloatBuffer p_up, java.nio.FloatBuffer p_low, java.nio.FloatBuffer pvort, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer u_up, java.nio.FloatBuffer v_up, java.nio.FloatBuffer u_low, java.nio.FloatBuffer v_low, java.nio.FloatBuffer avort1, java.nio.FloatBuffer avort2, java.nio.FloatBuffer dtdx1, java.nio.FloatBuffer dtdy1, java.nio.FloatBuffer dtdx2, java.nio.FloatBuffer dtdy2, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer coriolis)
  {
    boolean _direct = BufferFactory.isDirect(t_up);
    if (t_low != null && _direct != BufferFactory.isDirect(t_low))
      throw new RuntimeException("Argument \"t_low\" : Buffers passed to this method must all be either direct or indirect");
    if (p_up != null && _direct != BufferFactory.isDirect(p_up))
      throw new RuntimeException("Argument \"p_up\" : Buffers passed to this method must all be either direct or indirect");
    if (p_low != null && _direct != BufferFactory.isDirect(p_low))
      throw new RuntimeException("Argument \"p_low\" : Buffers passed to this method must all be either direct or indirect");
    if (pvort != null && _direct != BufferFactory.isDirect(pvort))
      throw new RuntimeException("Argument \"pvort\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (u_up != null && _direct != BufferFactory.isDirect(u_up))
      throw new RuntimeException("Argument \"u_up\" : Buffers passed to this method must all be either direct or indirect");
    if (v_up != null && _direct != BufferFactory.isDirect(v_up))
      throw new RuntimeException("Argument \"v_up\" : Buffers passed to this method must all be either direct or indirect");
    if (u_low != null && _direct != BufferFactory.isDirect(u_low))
      throw new RuntimeException("Argument \"u_low\" : Buffers passed to this method must all be either direct or indirect");
    if (v_low != null && _direct != BufferFactory.isDirect(v_low))
      throw new RuntimeException("Argument \"v_low\" : Buffers passed to this method must all be either direct or indirect");
    if (avort1 != null && _direct != BufferFactory.isDirect(avort1))
      throw new RuntimeException("Argument \"avort1\" : Buffers passed to this method must all be either direct or indirect");
    if (avort2 != null && _direct != BufferFactory.isDirect(avort2))
      throw new RuntimeException("Argument \"avort2\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx1 != null && _direct != BufferFactory.isDirect(dtdx1))
      throw new RuntimeException("Argument \"dtdx1\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy1 != null && _direct != BufferFactory.isDirect(dtdy1))
      throw new RuntimeException("Argument \"dtdy1\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx2 != null && _direct != BufferFactory.isDirect(dtdx2))
      throw new RuntimeException("Argument \"dtdx2\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy2 != null && _direct != BufferFactory.isDirect(dtdy2))
      throw new RuntimeException("Argument \"dtdy2\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (coriolis != null && _direct != BufferFactory.isDirect(coriolis))
      throw new RuntimeException("Argument \"coriolis\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        pvpres0(t_up, BufferFactory.getDirectBufferByteOffset(t_up), t_low, BufferFactory.getDirectBufferByteOffset(t_low), p_up, BufferFactory.getDirectBufferByteOffset(p_up), p_low, BufferFactory.getDirectBufferByteOffset(p_low), pvort, BufferFactory.getDirectBufferByteOffset(pvort), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), u_up, BufferFactory.getDirectBufferByteOffset(u_up), v_up, BufferFactory.getDirectBufferByteOffset(v_up), u_low, BufferFactory.getDirectBufferByteOffset(u_low), v_low, BufferFactory.getDirectBufferByteOffset(v_low), avort1, BufferFactory.getDirectBufferByteOffset(avort1), avort2, BufferFactory.getDirectBufferByteOffset(avort2), dtdx1, BufferFactory.getDirectBufferByteOffset(dtdx1), dtdy1, BufferFactory.getDirectBufferByteOffset(dtdy1), dtdx2, BufferFactory.getDirectBufferByteOffset(dtdx2), dtdy2, BufferFactory.getDirectBufferByteOffset(dtdy2), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), coriolis, BufferFactory.getDirectBufferByteOffset(coriolis));
    } else {
      pvpres1(BufferFactory.getArray(t_up), BufferFactory.getIndirectBufferByteOffset(t_up), BufferFactory.getArray(t_low), BufferFactory.getIndirectBufferByteOffset(t_low), BufferFactory.getArray(p_up), BufferFactory.getIndirectBufferByteOffset(p_up), BufferFactory.getArray(p_low), BufferFactory.getIndirectBufferByteOffset(p_low), BufferFactory.getArray(pvort), BufferFactory.getIndirectBufferByteOffset(pvort), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(u_up), BufferFactory.getIndirectBufferByteOffset(u_up), BufferFactory.getArray(v_up), BufferFactory.getIndirectBufferByteOffset(v_up), BufferFactory.getArray(u_low), BufferFactory.getIndirectBufferByteOffset(u_low), BufferFactory.getArray(v_low), BufferFactory.getIndirectBufferByteOffset(v_low), BufferFactory.getArray(avort1), BufferFactory.getIndirectBufferByteOffset(avort1), BufferFactory.getArray(avort2), BufferFactory.getIndirectBufferByteOffset(avort2), BufferFactory.getArray(dtdx1), BufferFactory.getIndirectBufferByteOffset(dtdx1), BufferFactory.getArray(dtdy1), BufferFactory.getIndirectBufferByteOffset(dtdy1), BufferFactory.getArray(dtdx2), BufferFactory.getIndirectBufferByteOffset(dtdx2), BufferFactory.getArray(dtdy2), BufferFactory.getIndirectBufferByteOffset(dtdy2), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(coriolis), BufferFactory.getIndirectBufferByteOffset(coriolis));
    }
  }

  /** Entry point to C language function: <br> <code> void pvpres(float *  t_up, float *  t_low, float *  p_up, float *  p_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dtdx1, float *  dtdy1, float *  dtdx2, float *  dtdy2, float *  dx, float *  dy, float *  coriolis); </code>    */
  private static native void pvpres0(Object t_up, int t_up_byte_offset, Object t_low, int t_low_byte_offset, Object p_up, int p_up_byte_offset, Object p_low, int p_low_byte_offset, Object pvort, int pvort_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object u_up, int u_up_byte_offset, Object v_up, int v_up_byte_offset, Object u_low, int u_low_byte_offset, Object v_low, int v_low_byte_offset, Object avort1, int avort1_byte_offset, Object avort2, int avort2_byte_offset, Object dtdx1, int dtdx1_byte_offset, Object dtdy1, int dtdy1_byte_offset, Object dtdx2, int dtdx2_byte_offset, Object dtdy2, int dtdy2_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset);

  /** Entry point to C language function: <br> <code> void pvpres(float *  t_up, float *  t_low, float *  p_up, float *  p_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dtdx1, float *  dtdy1, float *  dtdx2, float *  dtdy2, float *  dx, float *  dy, float *  coriolis); </code>    */
  private static native void pvpres1(Object t_up, int t_up_byte_offset, Object t_low, int t_low_byte_offset, Object p_up, int p_up_byte_offset, Object p_low, int p_low_byte_offset, Object pvort, int pvort_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object u_up, int u_up_byte_offset, Object v_up, int v_up_byte_offset, Object u_low, int u_low_byte_offset, Object v_low, int v_low_byte_offset, Object avort1, int avort1_byte_offset, Object avort2, int avort2_byte_offset, Object dtdx1, int dtdx1_byte_offset, Object dtdy1, int dtdy1_byte_offset, Object dtdx2, int dtdx2_byte_offset, Object dtdy2, int dtdy2_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset);

  /** Interface to C language function: <br> <code> void pvpres(float *  t_up, float *  t_low, float *  p_up, float *  p_low, float *  pvort, int *  mni, int *  ni, int *  nj, float *  u_up, float *  v_up, float *  u_low, float *  v_low, float *  avort1, float *  avort2, float *  dtdx1, float *  dtdy1, float *  dtdx2, float *  dtdy2, float *  dx, float *  dy, float *  coriolis); </code>    */
  public static void pvpres(float[] t_up, int t_up_offset, float[] t_low, int t_low_offset, float[] p_up, int p_up_offset, float[] p_low, int p_low_offset, float[] pvort, int pvort_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] u_up, int u_up_offset, float[] v_up, int v_up_offset, float[] u_low, int u_low_offset, float[] v_low, int v_low_offset, float[] avort1, int avort1_offset, float[] avort2, int avort2_offset, float[] dtdx1, int dtdx1_offset, float[] dtdy1, int dtdy1_offset, float[] dtdx2, int dtdx2_offset, float[] dtdy2, int dtdy2_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] coriolis, int coriolis_offset)
  {
    if(t_up != null && t_up.length <= t_up_offset)
      throw new RuntimeException("array offset argument \"t_up_offset\" (" + t_up_offset + ") equals or exceeds array length (" + t_up.length + ")");
    if(t_low != null && t_low.length <= t_low_offset)
      throw new RuntimeException("array offset argument \"t_low_offset\" (" + t_low_offset + ") equals or exceeds array length (" + t_low.length + ")");
    if(p_up != null && p_up.length <= p_up_offset)
      throw new RuntimeException("array offset argument \"p_up_offset\" (" + p_up_offset + ") equals or exceeds array length (" + p_up.length + ")");
    if(p_low != null && p_low.length <= p_low_offset)
      throw new RuntimeException("array offset argument \"p_low_offset\" (" + p_low_offset + ") equals or exceeds array length (" + p_low.length + ")");
    if(pvort != null && pvort.length <= pvort_offset)
      throw new RuntimeException("array offset argument \"pvort_offset\" (" + pvort_offset + ") equals or exceeds array length (" + pvort.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(u_up != null && u_up.length <= u_up_offset)
      throw new RuntimeException("array offset argument \"u_up_offset\" (" + u_up_offset + ") equals or exceeds array length (" + u_up.length + ")");
    if(v_up != null && v_up.length <= v_up_offset)
      throw new RuntimeException("array offset argument \"v_up_offset\" (" + v_up_offset + ") equals or exceeds array length (" + v_up.length + ")");
    if(u_low != null && u_low.length <= u_low_offset)
      throw new RuntimeException("array offset argument \"u_low_offset\" (" + u_low_offset + ") equals or exceeds array length (" + u_low.length + ")");
    if(v_low != null && v_low.length <= v_low_offset)
      throw new RuntimeException("array offset argument \"v_low_offset\" (" + v_low_offset + ") equals or exceeds array length (" + v_low.length + ")");
    if(avort1 != null && avort1.length <= avort1_offset)
      throw new RuntimeException("array offset argument \"avort1_offset\" (" + avort1_offset + ") equals or exceeds array length (" + avort1.length + ")");
    if(avort2 != null && avort2.length <= avort2_offset)
      throw new RuntimeException("array offset argument \"avort2_offset\" (" + avort2_offset + ") equals or exceeds array length (" + avort2.length + ")");
    if(dtdx1 != null && dtdx1.length <= dtdx1_offset)
      throw new RuntimeException("array offset argument \"dtdx1_offset\" (" + dtdx1_offset + ") equals or exceeds array length (" + dtdx1.length + ")");
    if(dtdy1 != null && dtdy1.length <= dtdy1_offset)
      throw new RuntimeException("array offset argument \"dtdy1_offset\" (" + dtdy1_offset + ") equals or exceeds array length (" + dtdy1.length + ")");
    if(dtdx2 != null && dtdx2.length <= dtdx2_offset)
      throw new RuntimeException("array offset argument \"dtdx2_offset\" (" + dtdx2_offset + ") equals or exceeds array length (" + dtdx2.length + ")");
    if(dtdy2 != null && dtdy2.length <= dtdy2_offset)
      throw new RuntimeException("array offset argument \"dtdy2_offset\" (" + dtdy2_offset + ") equals or exceeds array length (" + dtdy2.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(coriolis != null && coriolis.length <= coriolis_offset)
      throw new RuntimeException("array offset argument \"coriolis_offset\" (" + coriolis_offset + ") equals or exceeds array length (" + coriolis.length + ")");
        pvpres1(t_up, BufferFactory.SIZEOF_FLOAT * t_up_offset, t_low, BufferFactory.SIZEOF_FLOAT * t_low_offset, p_up, BufferFactory.SIZEOF_FLOAT * p_up_offset, p_low, BufferFactory.SIZEOF_FLOAT * p_low_offset, pvort, BufferFactory.SIZEOF_FLOAT * pvort_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, u_up, BufferFactory.SIZEOF_FLOAT * u_up_offset, v_up, BufferFactory.SIZEOF_FLOAT * v_up_offset, u_low, BufferFactory.SIZEOF_FLOAT * u_low_offset, v_low, BufferFactory.SIZEOF_FLOAT * v_low_offset, avort1, BufferFactory.SIZEOF_FLOAT * avort1_offset, avort2, BufferFactory.SIZEOF_FLOAT * avort2_offset, dtdx1, BufferFactory.SIZEOF_FLOAT * dtdx1_offset, dtdy1, BufferFactory.SIZEOF_FLOAT * dtdy1_offset, dtdx2, BufferFactory.SIZEOF_FLOAT * dtdx2_offset, dtdy2, BufferFactory.SIZEOF_FLOAT * dtdy2_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, coriolis, BufferFactory.SIZEOF_FLOAT * coriolis_offset);

  }

  /** Interface to C language function: <br> <code> void qvector(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  dugdx, float *  dvgdx, float *  dugdy, float *  dvgdy, float *  dtdx, float *  dtdy, float *  qx, float *  qy); </code>    */
  public static void qvector(java.nio.FloatBuffer zmid, java.nio.FloatBuffer ztop, java.nio.FloatBuffer zbot, java.nio.FloatBuffer ptop, java.nio.FloatBuffer pbot, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer f, java.nio.FloatBuffer dugdx, java.nio.FloatBuffer dvgdx, java.nio.FloatBuffer dugdy, java.nio.FloatBuffer dvgdy, java.nio.FloatBuffer dtdx, java.nio.FloatBuffer dtdy, java.nio.FloatBuffer qx, java.nio.FloatBuffer qy)
  {
    boolean _direct = BufferFactory.isDirect(zmid);
    if (ztop != null && _direct != BufferFactory.isDirect(ztop))
      throw new RuntimeException("Argument \"ztop\" : Buffers passed to this method must all be either direct or indirect");
    if (zbot != null && _direct != BufferFactory.isDirect(zbot))
      throw new RuntimeException("Argument \"zbot\" : Buffers passed to this method must all be either direct or indirect");
    if (ptop != null && _direct != BufferFactory.isDirect(ptop))
      throw new RuntimeException("Argument \"ptop\" : Buffers passed to this method must all be either direct or indirect");
    if (pbot != null && _direct != BufferFactory.isDirect(pbot))
      throw new RuntimeException("Argument \"pbot\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (f != null && _direct != BufferFactory.isDirect(f))
      throw new RuntimeException("Argument \"f\" : Buffers passed to this method must all be either direct or indirect");
    if (dugdx != null && _direct != BufferFactory.isDirect(dugdx))
      throw new RuntimeException("Argument \"dugdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dvgdx != null && _direct != BufferFactory.isDirect(dvgdx))
      throw new RuntimeException("Argument \"dvgdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dugdy != null && _direct != BufferFactory.isDirect(dugdy))
      throw new RuntimeException("Argument \"dugdy\" : Buffers passed to this method must all be either direct or indirect");
    if (dvgdy != null && _direct != BufferFactory.isDirect(dvgdy))
      throw new RuntimeException("Argument \"dvgdy\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx != null && _direct != BufferFactory.isDirect(dtdx))
      throw new RuntimeException("Argument \"dtdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy != null && _direct != BufferFactory.isDirect(dtdy))
      throw new RuntimeException("Argument \"dtdy\" : Buffers passed to this method must all be either direct or indirect");
    if (qx != null && _direct != BufferFactory.isDirect(qx))
      throw new RuntimeException("Argument \"qx\" : Buffers passed to this method must all be either direct or indirect");
    if (qy != null && _direct != BufferFactory.isDirect(qy))
      throw new RuntimeException("Argument \"qy\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        qvector0(zmid, BufferFactory.getDirectBufferByteOffset(zmid), ztop, BufferFactory.getDirectBufferByteOffset(ztop), zbot, BufferFactory.getDirectBufferByteOffset(zbot), ptop, BufferFactory.getDirectBufferByteOffset(ptop), pbot, BufferFactory.getDirectBufferByteOffset(pbot), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), f, BufferFactory.getDirectBufferByteOffset(f), dugdx, BufferFactory.getDirectBufferByteOffset(dugdx), dvgdx, BufferFactory.getDirectBufferByteOffset(dvgdx), dugdy, BufferFactory.getDirectBufferByteOffset(dugdy), dvgdy, BufferFactory.getDirectBufferByteOffset(dvgdy), dtdx, BufferFactory.getDirectBufferByteOffset(dtdx), dtdy, BufferFactory.getDirectBufferByteOffset(dtdy), qx, BufferFactory.getDirectBufferByteOffset(qx), qy, BufferFactory.getDirectBufferByteOffset(qy));
    } else {
      qvector1(BufferFactory.getArray(zmid), BufferFactory.getIndirectBufferByteOffset(zmid), BufferFactory.getArray(ztop), BufferFactory.getIndirectBufferByteOffset(ztop), BufferFactory.getArray(zbot), BufferFactory.getIndirectBufferByteOffset(zbot), BufferFactory.getArray(ptop), BufferFactory.getIndirectBufferByteOffset(ptop), BufferFactory.getArray(pbot), BufferFactory.getIndirectBufferByteOffset(pbot), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(f), BufferFactory.getIndirectBufferByteOffset(f), BufferFactory.getArray(dugdx), BufferFactory.getIndirectBufferByteOffset(dugdx), BufferFactory.getArray(dvgdx), BufferFactory.getIndirectBufferByteOffset(dvgdx), BufferFactory.getArray(dugdy), BufferFactory.getIndirectBufferByteOffset(dugdy), BufferFactory.getArray(dvgdy), BufferFactory.getIndirectBufferByteOffset(dvgdy), BufferFactory.getArray(dtdx), BufferFactory.getIndirectBufferByteOffset(dtdx), BufferFactory.getArray(dtdy), BufferFactory.getIndirectBufferByteOffset(dtdy), BufferFactory.getArray(qx), BufferFactory.getIndirectBufferByteOffset(qx), BufferFactory.getArray(qy), BufferFactory.getIndirectBufferByteOffset(qy));
    }
  }

  /** Entry point to C language function: <br> <code> void qvector(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  dugdx, float *  dvgdx, float *  dugdy, float *  dvgdy, float *  dtdx, float *  dtdy, float *  qx, float *  qy); </code>    */
  private static native void qvector0(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object dugdx, int dugdx_byte_offset, Object dvgdx, int dvgdx_byte_offset, Object dugdy, int dugdy_byte_offset, Object dvgdy, int dvgdy_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset);

  /** Entry point to C language function: <br> <code> void qvector(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  dugdx, float *  dvgdx, float *  dugdy, float *  dvgdy, float *  dtdx, float *  dtdy, float *  qx, float *  qy); </code>    */
  private static native void qvector1(Object zmid, int zmid_byte_offset, Object ztop, int ztop_byte_offset, Object zbot, int zbot_byte_offset, Object ptop, int ptop_byte_offset, Object pbot, int pbot_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object f, int f_byte_offset, Object dugdx, int dugdx_byte_offset, Object dvgdx, int dvgdx_byte_offset, Object dugdy, int dugdy_byte_offset, Object dvgdy, int dvgdy_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset, Object qx, int qx_byte_offset, Object qy, int qy_byte_offset);

  /** Interface to C language function: <br> <code> void qvector(float *  zmid, float *  ztop, float *  zbot, float *  ptop, float *  pbot, int *  mni, int *  ni, int *  nj, float *  dx, float *  dy, float *  f, float *  dugdx, float *  dvgdx, float *  dugdy, float *  dvgdy, float *  dtdx, float *  dtdy, float *  qx, float *  qy); </code>    */
  public static void qvector(float[] zmid, int zmid_offset, float[] ztop, int ztop_offset, float[] zbot, int zbot_offset, float[] ptop, int ptop_offset, float[] pbot, int pbot_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] f, int f_offset, float[] dugdx, int dugdx_offset, float[] dvgdx, int dvgdx_offset, float[] dugdy, int dugdy_offset, float[] dvgdy, int dvgdy_offset, float[] dtdx, int dtdx_offset, float[] dtdy, int dtdy_offset, float[] qx, int qx_offset, float[] qy, int qy_offset)
  {
    if(zmid != null && zmid.length <= zmid_offset)
      throw new RuntimeException("array offset argument \"zmid_offset\" (" + zmid_offset + ") equals or exceeds array length (" + zmid.length + ")");
    if(ztop != null && ztop.length <= ztop_offset)
      throw new RuntimeException("array offset argument \"ztop_offset\" (" + ztop_offset + ") equals or exceeds array length (" + ztop.length + ")");
    if(zbot != null && zbot.length <= zbot_offset)
      throw new RuntimeException("array offset argument \"zbot_offset\" (" + zbot_offset + ") equals or exceeds array length (" + zbot.length + ")");
    if(ptop != null && ptop.length <= ptop_offset)
      throw new RuntimeException("array offset argument \"ptop_offset\" (" + ptop_offset + ") equals or exceeds array length (" + ptop.length + ")");
    if(pbot != null && pbot.length <= pbot_offset)
      throw new RuntimeException("array offset argument \"pbot_offset\" (" + pbot_offset + ") equals or exceeds array length (" + pbot.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(f != null && f.length <= f_offset)
      throw new RuntimeException("array offset argument \"f_offset\" (" + f_offset + ") equals or exceeds array length (" + f.length + ")");
    if(dugdx != null && dugdx.length <= dugdx_offset)
      throw new RuntimeException("array offset argument \"dugdx_offset\" (" + dugdx_offset + ") equals or exceeds array length (" + dugdx.length + ")");
    if(dvgdx != null && dvgdx.length <= dvgdx_offset)
      throw new RuntimeException("array offset argument \"dvgdx_offset\" (" + dvgdx_offset + ") equals or exceeds array length (" + dvgdx.length + ")");
    if(dugdy != null && dugdy.length <= dugdy_offset)
      throw new RuntimeException("array offset argument \"dugdy_offset\" (" + dugdy_offset + ") equals or exceeds array length (" + dugdy.length + ")");
    if(dvgdy != null && dvgdy.length <= dvgdy_offset)
      throw new RuntimeException("array offset argument \"dvgdy_offset\" (" + dvgdy_offset + ") equals or exceeds array length (" + dvgdy.length + ")");
    if(dtdx != null && dtdx.length <= dtdx_offset)
      throw new RuntimeException("array offset argument \"dtdx_offset\" (" + dtdx_offset + ") equals or exceeds array length (" + dtdx.length + ")");
    if(dtdy != null && dtdy.length <= dtdy_offset)
      throw new RuntimeException("array offset argument \"dtdy_offset\" (" + dtdy_offset + ") equals or exceeds array length (" + dtdy.length + ")");
    if(qx != null && qx.length <= qx_offset)
      throw new RuntimeException("array offset argument \"qx_offset\" (" + qx_offset + ") equals or exceeds array length (" + qx.length + ")");
    if(qy != null && qy.length <= qy_offset)
      throw new RuntimeException("array offset argument \"qy_offset\" (" + qy_offset + ") equals or exceeds array length (" + qy.length + ")");
        qvector1(zmid, BufferFactory.SIZEOF_FLOAT * zmid_offset, ztop, BufferFactory.SIZEOF_FLOAT * ztop_offset, zbot, BufferFactory.SIZEOF_FLOAT * zbot_offset, ptop, BufferFactory.SIZEOF_FLOAT * ptop_offset, pbot, BufferFactory.SIZEOF_FLOAT * pbot_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, f, BufferFactory.SIZEOF_FLOAT * f_offset, dugdx, BufferFactory.SIZEOF_FLOAT * dugdx_offset, dvgdx, BufferFactory.SIZEOF_FLOAT * dvgdx_offset, dugdy, BufferFactory.SIZEOF_FLOAT * dugdy_offset, dvgdy, BufferFactory.SIZEOF_FLOAT * dvgdy_offset, dtdx, BufferFactory.SIZEOF_FLOAT * dtdx_offset, dtdy, BufferFactory.SIZEOF_FLOAT * dtdy_offset, qx, BufferFactory.SIZEOF_FLOAT * qx_offset, qy, BufferFactory.SIZEOF_FLOAT * qy_offset);

  }

  /** Interface to C language function: <br> <code> void radiation(float *  lat, float *  lng, float *  lsm, int *  jd, float *  hr, float *  bext, float *  od, float *  solrad); </code>    */
  public static void radiation(java.nio.FloatBuffer lat, java.nio.FloatBuffer lng, java.nio.FloatBuffer lsm, java.nio.IntBuffer jd, java.nio.FloatBuffer hr, java.nio.FloatBuffer bext, java.nio.FloatBuffer od, java.nio.FloatBuffer solrad)
  {
    boolean _direct = BufferFactory.isDirect(lat);
    if (lng != null && _direct != BufferFactory.isDirect(lng))
      throw new RuntimeException("Argument \"lng\" : Buffers passed to this method must all be either direct or indirect");
    if (lsm != null && _direct != BufferFactory.isDirect(lsm))
      throw new RuntimeException("Argument \"lsm\" : Buffers passed to this method must all be either direct or indirect");
    if (jd != null && _direct != BufferFactory.isDirect(jd))
      throw new RuntimeException("Argument \"jd\" : Buffers passed to this method must all be either direct or indirect");
    if (hr != null && _direct != BufferFactory.isDirect(hr))
      throw new RuntimeException("Argument \"hr\" : Buffers passed to this method must all be either direct or indirect");
    if (bext != null && _direct != BufferFactory.isDirect(bext))
      throw new RuntimeException("Argument \"bext\" : Buffers passed to this method must all be either direct or indirect");
    if (od != null && _direct != BufferFactory.isDirect(od))
      throw new RuntimeException("Argument \"od\" : Buffers passed to this method must all be either direct or indirect");
    if (solrad != null && _direct != BufferFactory.isDirect(solrad))
      throw new RuntimeException("Argument \"solrad\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        radiation0(lat, BufferFactory.getDirectBufferByteOffset(lat), lng, BufferFactory.getDirectBufferByteOffset(lng), lsm, BufferFactory.getDirectBufferByteOffset(lsm), jd, BufferFactory.getDirectBufferByteOffset(jd), hr, BufferFactory.getDirectBufferByteOffset(hr), bext, BufferFactory.getDirectBufferByteOffset(bext), od, BufferFactory.getDirectBufferByteOffset(od), solrad, BufferFactory.getDirectBufferByteOffset(solrad));
    } else {
      radiation1(BufferFactory.getArray(lat), BufferFactory.getIndirectBufferByteOffset(lat), BufferFactory.getArray(lng), BufferFactory.getIndirectBufferByteOffset(lng), BufferFactory.getArray(lsm), BufferFactory.getIndirectBufferByteOffset(lsm), BufferFactory.getArray(jd), BufferFactory.getIndirectBufferByteOffset(jd), BufferFactory.getArray(hr), BufferFactory.getIndirectBufferByteOffset(hr), BufferFactory.getArray(bext), BufferFactory.getIndirectBufferByteOffset(bext), BufferFactory.getArray(od), BufferFactory.getIndirectBufferByteOffset(od), BufferFactory.getArray(solrad), BufferFactory.getIndirectBufferByteOffset(solrad));
    }
  }

  /** Entry point to C language function: <br> <code> void radiation(float *  lat, float *  lng, float *  lsm, int *  jd, float *  hr, float *  bext, float *  od, float *  solrad); </code>    */
  private static native void radiation0(Object lat, int lat_byte_offset, Object lng, int lng_byte_offset, Object lsm, int lsm_byte_offset, Object jd, int jd_byte_offset, Object hr, int hr_byte_offset, Object bext, int bext_byte_offset, Object od, int od_byte_offset, Object solrad, int solrad_byte_offset);

  /** Entry point to C language function: <br> <code> void radiation(float *  lat, float *  lng, float *  lsm, int *  jd, float *  hr, float *  bext, float *  od, float *  solrad); </code>    */
  private static native void radiation1(Object lat, int lat_byte_offset, Object lng, int lng_byte_offset, Object lsm, int lsm_byte_offset, Object jd, int jd_byte_offset, Object hr, int hr_byte_offset, Object bext, int bext_byte_offset, Object od, int od_byte_offset, Object solrad, int solrad_byte_offset);

  /** Interface to C language function: <br> <code> void radiation(float *  lat, float *  lng, float *  lsm, int *  jd, float *  hr, float *  bext, float *  od, float *  solrad); </code>    */
  public static void radiation(float[] lat, int lat_offset, float[] lng, int lng_offset, float[] lsm, int lsm_offset, int[] jd, int jd_offset, float[] hr, int hr_offset, float[] bext, int bext_offset, float[] od, int od_offset, float[] solrad, int solrad_offset)
  {
    if(lat != null && lat.length <= lat_offset)
      throw new RuntimeException("array offset argument \"lat_offset\" (" + lat_offset + ") equals or exceeds array length (" + lat.length + ")");
    if(lng != null && lng.length <= lng_offset)
      throw new RuntimeException("array offset argument \"lng_offset\" (" + lng_offset + ") equals or exceeds array length (" + lng.length + ")");
    if(lsm != null && lsm.length <= lsm_offset)
      throw new RuntimeException("array offset argument \"lsm_offset\" (" + lsm_offset + ") equals or exceeds array length (" + lsm.length + ")");
    if(jd != null && jd.length <= jd_offset)
      throw new RuntimeException("array offset argument \"jd_offset\" (" + jd_offset + ") equals or exceeds array length (" + jd.length + ")");
    if(hr != null && hr.length <= hr_offset)
      throw new RuntimeException("array offset argument \"hr_offset\" (" + hr_offset + ") equals or exceeds array length (" + hr.length + ")");
    if(bext != null && bext.length <= bext_offset)
      throw new RuntimeException("array offset argument \"bext_offset\" (" + bext_offset + ") equals or exceeds array length (" + bext.length + ")");
    if(od != null && od.length <= od_offset)
      throw new RuntimeException("array offset argument \"od_offset\" (" + od_offset + ") equals or exceeds array length (" + od.length + ")");
    if(solrad != null && solrad.length <= solrad_offset)
      throw new RuntimeException("array offset argument \"solrad_offset\" (" + solrad_offset + ") equals or exceeds array length (" + solrad.length + ")");
        radiation1(lat, BufferFactory.SIZEOF_FLOAT * lat_offset, lng, BufferFactory.SIZEOF_FLOAT * lng_offset, lsm, BufferFactory.SIZEOF_FLOAT * lsm_offset, jd, BufferFactory.SIZEOF_INT * jd_offset, hr, BufferFactory.SIZEOF_FLOAT * hr_offset, bext, BufferFactory.SIZEOF_FLOAT * bext_offset, od, BufferFactory.SIZEOF_FLOAT * od_offset, solrad, BufferFactory.SIZEOF_FLOAT * solrad_offset);

  }

  /** Interface to C language function: <br> <code> float rang2d(const float *  data, int *  mnx, int *  nx, int *  ny, float *  minData, float *  maxData); </code>    */
  public static float rang2d(java.nio.FloatBuffer data, java.nio.IntBuffer mnx, java.nio.IntBuffer nx, java.nio.IntBuffer ny, java.nio.FloatBuffer minData, java.nio.FloatBuffer maxData)
  {
    boolean _direct = BufferFactory.isDirect(data);
    if (mnx != null && _direct != BufferFactory.isDirect(mnx))
      throw new RuntimeException("Argument \"mnx\" : Buffers passed to this method must all be either direct or indirect");
    if (nx != null && _direct != BufferFactory.isDirect(nx))
      throw new RuntimeException("Argument \"nx\" : Buffers passed to this method must all be either direct or indirect");
    if (ny != null && _direct != BufferFactory.isDirect(ny))
      throw new RuntimeException("Argument \"ny\" : Buffers passed to this method must all be either direct or indirect");
    if (minData != null && _direct != BufferFactory.isDirect(minData))
      throw new RuntimeException("Argument \"minData\" : Buffers passed to this method must all be either direct or indirect");
    if (maxData != null && _direct != BufferFactory.isDirect(maxData))
      throw new RuntimeException("Argument \"maxData\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return rang2d0(data, BufferFactory.getDirectBufferByteOffset(data), mnx, BufferFactory.getDirectBufferByteOffset(mnx), nx, BufferFactory.getDirectBufferByteOffset(nx), ny, BufferFactory.getDirectBufferByteOffset(ny), minData, BufferFactory.getDirectBufferByteOffset(minData), maxData, BufferFactory.getDirectBufferByteOffset(maxData));
    } else {
      return rang2d1(BufferFactory.getArray(data), BufferFactory.getIndirectBufferByteOffset(data), BufferFactory.getArray(mnx), BufferFactory.getIndirectBufferByteOffset(mnx), BufferFactory.getArray(nx), BufferFactory.getIndirectBufferByteOffset(nx), BufferFactory.getArray(ny), BufferFactory.getIndirectBufferByteOffset(ny), BufferFactory.getArray(minData), BufferFactory.getIndirectBufferByteOffset(minData), BufferFactory.getArray(maxData), BufferFactory.getIndirectBufferByteOffset(maxData));
    }
  }

  /** Entry point to C language function: <br> <code> float rang2d(const float *  data, int *  mnx, int *  nx, int *  ny, float *  minData, float *  maxData); </code>    */
  private static native float rang2d0(Object data, int data_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object minData, int minData_byte_offset, Object maxData, int maxData_byte_offset);

  /** Entry point to C language function: <br> <code> float rang2d(const float *  data, int *  mnx, int *  nx, int *  ny, float *  minData, float *  maxData); </code>    */
  private static native float rang2d1(Object data, int data_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object minData, int minData_byte_offset, Object maxData, int maxData_byte_offset);

  /** Interface to C language function: <br> <code> float rang2d(const float *  data, int *  mnx, int *  nx, int *  ny, float *  minData, float *  maxData); </code>    */
  public static float rang2d(float[] data, int data_offset, int[] mnx, int mnx_offset, int[] nx, int nx_offset, int[] ny, int ny_offset, float[] minData, int minData_offset, float[] maxData, int maxData_offset)
  {
    if(data != null && data.length <= data_offset)
      throw new RuntimeException("array offset argument \"data_offset\" (" + data_offset + ") equals or exceeds array length (" + data.length + ")");
    if(mnx != null && mnx.length <= mnx_offset)
      throw new RuntimeException("array offset argument \"mnx_offset\" (" + mnx_offset + ") equals or exceeds array length (" + mnx.length + ")");
    if(nx != null && nx.length <= nx_offset)
      throw new RuntimeException("array offset argument \"nx_offset\" (" + nx_offset + ") equals or exceeds array length (" + nx.length + ")");
    if(ny != null && ny.length <= ny_offset)
      throw new RuntimeException("array offset argument \"ny_offset\" (" + ny_offset + ") equals or exceeds array length (" + ny.length + ")");
    if(minData != null && minData.length <= minData_offset)
      throw new RuntimeException("array offset argument \"minData_offset\" (" + minData_offset + ") equals or exceeds array length (" + minData.length + ")");
    if(maxData != null && maxData.length <= maxData_offset)
      throw new RuntimeException("array offset argument \"maxData_offset\" (" + maxData_offset + ") equals or exceeds array length (" + maxData.length + ")");
        return rang2d1(data, BufferFactory.SIZEOF_FLOAT * data_offset, mnx, BufferFactory.SIZEOF_INT * mnx_offset, nx, BufferFactory.SIZEOF_INT * nx_offset, ny, BufferFactory.SIZEOF_INT * ny_offset, minData, BufferFactory.SIZEOF_FLOAT * minData_offset, maxData, BufferFactory.SIZEOF_FLOAT * maxData_offset);

  }

  /** Interface to C language function: <br> <code> void replinrange(float *  a, int *  tsttyp, float *  lo, float *  hi, float *  repl, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void replinrange(java.nio.FloatBuffer a, java.nio.IntBuffer tsttyp, java.nio.FloatBuffer lo, java.nio.FloatBuffer hi, java.nio.FloatBuffer repl, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (tsttyp != null && _direct != BufferFactory.isDirect(tsttyp))
      throw new RuntimeException("Argument \"tsttyp\" : Buffers passed to this method must all be either direct or indirect");
    if (lo != null && _direct != BufferFactory.isDirect(lo))
      throw new RuntimeException("Argument \"lo\" : Buffers passed to this method must all be either direct or indirect");
    if (hi != null && _direct != BufferFactory.isDirect(hi))
      throw new RuntimeException("Argument \"hi\" : Buffers passed to this method must all be either direct or indirect");
    if (repl != null && _direct != BufferFactory.isDirect(repl))
      throw new RuntimeException("Argument \"repl\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        replinrange0(a, BufferFactory.getDirectBufferByteOffset(a), tsttyp, BufferFactory.getDirectBufferByteOffset(tsttyp), lo, BufferFactory.getDirectBufferByteOffset(lo), hi, BufferFactory.getDirectBufferByteOffset(hi), repl, BufferFactory.getDirectBufferByteOffset(repl), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      replinrange1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(tsttyp), BufferFactory.getIndirectBufferByteOffset(tsttyp), BufferFactory.getArray(lo), BufferFactory.getIndirectBufferByteOffset(lo), BufferFactory.getArray(hi), BufferFactory.getIndirectBufferByteOffset(hi), BufferFactory.getArray(repl), BufferFactory.getIndirectBufferByteOffset(repl), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void replinrange(float *  a, int *  tsttyp, float *  lo, float *  hi, float *  repl, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void replinrange0(Object a, int a_byte_offset, Object tsttyp, int tsttyp_byte_offset, Object lo, int lo_byte_offset, Object hi, int hi_byte_offset, Object repl, int repl_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void replinrange(float *  a, int *  tsttyp, float *  lo, float *  hi, float *  repl, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void replinrange1(Object a, int a_byte_offset, Object tsttyp, int tsttyp_byte_offset, Object lo, int lo_byte_offset, Object hi, int hi_byte_offset, Object repl, int repl_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void replinrange(float *  a, int *  tsttyp, float *  lo, float *  hi, float *  repl, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void replinrange(float[] a, int a_offset, int[] tsttyp, int tsttyp_offset, float[] lo, int lo_offset, float[] hi, int hi_offset, float[] repl, int repl_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(tsttyp != null && tsttyp.length <= tsttyp_offset)
      throw new RuntimeException("array offset argument \"tsttyp_offset\" (" + tsttyp_offset + ") equals or exceeds array length (" + tsttyp.length + ")");
    if(lo != null && lo.length <= lo_offset)
      throw new RuntimeException("array offset argument \"lo_offset\" (" + lo_offset + ") equals or exceeds array length (" + lo.length + ")");
    if(hi != null && hi.length <= hi_offset)
      throw new RuntimeException("array offset argument \"hi_offset\" (" + hi_offset + ") equals or exceeds array length (" + hi.length + ")");
    if(repl != null && repl.length <= repl_offset)
      throw new RuntimeException("array offset argument \"repl_offset\" (" + repl_offset + ") equals or exceeds array length (" + repl.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        replinrange1(a, BufferFactory.SIZEOF_FLOAT * a_offset, tsttyp, BufferFactory.SIZEOF_INT * tsttyp_offset, lo, BufferFactory.SIZEOF_FLOAT * lo_offset, hi, BufferFactory.SIZEOF_FLOAT * hi_offset, repl, BufferFactory.SIZEOF_FLOAT * repl_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void rhbar(float *  ENDLVL, int *  MRH, int *  NCLYR, float *  SFCP, float *  P, float *  TL, float *  TDL); </code>    */
  public static void rhbar(java.nio.FloatBuffer ENDLVL, java.nio.IntBuffer MRH, java.nio.IntBuffer NCLYR, java.nio.FloatBuffer SFCP, java.nio.FloatBuffer P, java.nio.FloatBuffer TL, java.nio.FloatBuffer TDL)
  {
    boolean _direct = BufferFactory.isDirect(ENDLVL);
    if (MRH != null && _direct != BufferFactory.isDirect(MRH))
      throw new RuntimeException("Argument \"MRH\" : Buffers passed to this method must all be either direct or indirect");
    if (NCLYR != null && _direct != BufferFactory.isDirect(NCLYR))
      throw new RuntimeException("Argument \"NCLYR\" : Buffers passed to this method must all be either direct or indirect");
    if (SFCP != null && _direct != BufferFactory.isDirect(SFCP))
      throw new RuntimeException("Argument \"SFCP\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (TL != null && _direct != BufferFactory.isDirect(TL))
      throw new RuntimeException("Argument \"TL\" : Buffers passed to this method must all be either direct or indirect");
    if (TDL != null && _direct != BufferFactory.isDirect(TDL))
      throw new RuntimeException("Argument \"TDL\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        rhbar0(ENDLVL, BufferFactory.getDirectBufferByteOffset(ENDLVL), MRH, BufferFactory.getDirectBufferByteOffset(MRH), NCLYR, BufferFactory.getDirectBufferByteOffset(NCLYR), SFCP, BufferFactory.getDirectBufferByteOffset(SFCP), P, BufferFactory.getDirectBufferByteOffset(P), TL, BufferFactory.getDirectBufferByteOffset(TL), TDL, BufferFactory.getDirectBufferByteOffset(TDL));
    } else {
      rhbar1(BufferFactory.getArray(ENDLVL), BufferFactory.getIndirectBufferByteOffset(ENDLVL), BufferFactory.getArray(MRH), BufferFactory.getIndirectBufferByteOffset(MRH), BufferFactory.getArray(NCLYR), BufferFactory.getIndirectBufferByteOffset(NCLYR), BufferFactory.getArray(SFCP), BufferFactory.getIndirectBufferByteOffset(SFCP), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(TL), BufferFactory.getIndirectBufferByteOffset(TL), BufferFactory.getArray(TDL), BufferFactory.getIndirectBufferByteOffset(TDL));
    }
  }

  /** Entry point to C language function: <br> <code> void rhbar(float *  ENDLVL, int *  MRH, int *  NCLYR, float *  SFCP, float *  P, float *  TL, float *  TDL); </code>    */
  private static native void rhbar0(Object ENDLVL, int ENDLVL_byte_offset, Object MRH, int MRH_byte_offset, Object NCLYR, int NCLYR_byte_offset, Object SFCP, int SFCP_byte_offset, Object P, int P_byte_offset, Object TL, int TL_byte_offset, Object TDL, int TDL_byte_offset);

  /** Entry point to C language function: <br> <code> void rhbar(float *  ENDLVL, int *  MRH, int *  NCLYR, float *  SFCP, float *  P, float *  TL, float *  TDL); </code>    */
  private static native void rhbar1(Object ENDLVL, int ENDLVL_byte_offset, Object MRH, int MRH_byte_offset, Object NCLYR, int NCLYR_byte_offset, Object SFCP, int SFCP_byte_offset, Object P, int P_byte_offset, Object TL, int TL_byte_offset, Object TDL, int TDL_byte_offset);

  /** Interface to C language function: <br> <code> void rhbar(float *  ENDLVL, int *  MRH, int *  NCLYR, float *  SFCP, float *  P, float *  TL, float *  TDL); </code>    */
  public static void rhbar(float[] ENDLVL, int ENDLVL_offset, int[] MRH, int MRH_offset, int[] NCLYR, int NCLYR_offset, float[] SFCP, int SFCP_offset, float[] P, int P_offset, float[] TL, int TL_offset, float[] TDL, int TDL_offset)
  {
    if(ENDLVL != null && ENDLVL.length <= ENDLVL_offset)
      throw new RuntimeException("array offset argument \"ENDLVL_offset\" (" + ENDLVL_offset + ") equals or exceeds array length (" + ENDLVL.length + ")");
    if(MRH != null && MRH.length <= MRH_offset)
      throw new RuntimeException("array offset argument \"MRH_offset\" (" + MRH_offset + ") equals or exceeds array length (" + MRH.length + ")");
    if(NCLYR != null && NCLYR.length <= NCLYR_offset)
      throw new RuntimeException("array offset argument \"NCLYR_offset\" (" + NCLYR_offset + ") equals or exceeds array length (" + NCLYR.length + ")");
    if(SFCP != null && SFCP.length <= SFCP_offset)
      throw new RuntimeException("array offset argument \"SFCP_offset\" (" + SFCP_offset + ") equals or exceeds array length (" + SFCP.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(TL != null && TL.length <= TL_offset)
      throw new RuntimeException("array offset argument \"TL_offset\" (" + TL_offset + ") equals or exceeds array length (" + TL.length + ")");
    if(TDL != null && TDL.length <= TDL_offset)
      throw new RuntimeException("array offset argument \"TDL_offset\" (" + TDL_offset + ") equals or exceeds array length (" + TDL.length + ")");
        rhbar1(ENDLVL, BufferFactory.SIZEOF_FLOAT * ENDLVL_offset, MRH, BufferFactory.SIZEOF_INT * MRH_offset, NCLYR, BufferFactory.SIZEOF_INT * NCLYR_offset, SFCP, BufferFactory.SIZEOF_FLOAT * SFCP_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, TL, BufferFactory.SIZEOF_FLOAT * TL_offset, TDL, BufferFactory.SIZEOF_FLOAT * TDL_offset);

  }

  /** Interface to C language function: <br> <code> void richno(float *  HT, float *  HW, float *  UW, float *  VW, float *  RHO, int *  NLVLS, int *  NW, float *  BUOY, float *  RICHNUM); </code>    */
  public static void richno(java.nio.FloatBuffer HT, java.nio.FloatBuffer HW, java.nio.FloatBuffer UW, java.nio.FloatBuffer VW, java.nio.FloatBuffer RHO, java.nio.IntBuffer NLVLS, java.nio.IntBuffer NW, java.nio.FloatBuffer BUOY, java.nio.FloatBuffer RICHNUM)
  {
    boolean _direct = BufferFactory.isDirect(HT);
    if (HW != null && _direct != BufferFactory.isDirect(HW))
      throw new RuntimeException("Argument \"HW\" : Buffers passed to this method must all be either direct or indirect");
    if (UW != null && _direct != BufferFactory.isDirect(UW))
      throw new RuntimeException("Argument \"UW\" : Buffers passed to this method must all be either direct or indirect");
    if (VW != null && _direct != BufferFactory.isDirect(VW))
      throw new RuntimeException("Argument \"VW\" : Buffers passed to this method must all be either direct or indirect");
    if (RHO != null && _direct != BufferFactory.isDirect(RHO))
      throw new RuntimeException("Argument \"RHO\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (NW != null && _direct != BufferFactory.isDirect(NW))
      throw new RuntimeException("Argument \"NW\" : Buffers passed to this method must all be either direct or indirect");
    if (BUOY != null && _direct != BufferFactory.isDirect(BUOY))
      throw new RuntimeException("Argument \"BUOY\" : Buffers passed to this method must all be either direct or indirect");
    if (RICHNUM != null && _direct != BufferFactory.isDirect(RICHNUM))
      throw new RuntimeException("Argument \"RICHNUM\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        richno0(HT, BufferFactory.getDirectBufferByteOffset(HT), HW, BufferFactory.getDirectBufferByteOffset(HW), UW, BufferFactory.getDirectBufferByteOffset(UW), VW, BufferFactory.getDirectBufferByteOffset(VW), RHO, BufferFactory.getDirectBufferByteOffset(RHO), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), NW, BufferFactory.getDirectBufferByteOffset(NW), BUOY, BufferFactory.getDirectBufferByteOffset(BUOY), RICHNUM, BufferFactory.getDirectBufferByteOffset(RICHNUM));
    } else {
      richno1(BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(HW), BufferFactory.getIndirectBufferByteOffset(HW), BufferFactory.getArray(UW), BufferFactory.getIndirectBufferByteOffset(UW), BufferFactory.getArray(VW), BufferFactory.getIndirectBufferByteOffset(VW), BufferFactory.getArray(RHO), BufferFactory.getIndirectBufferByteOffset(RHO), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(NW), BufferFactory.getIndirectBufferByteOffset(NW), BufferFactory.getArray(BUOY), BufferFactory.getIndirectBufferByteOffset(BUOY), BufferFactory.getArray(RICHNUM), BufferFactory.getIndirectBufferByteOffset(RICHNUM));
    }
  }

  /** Entry point to C language function: <br> <code> void richno(float *  HT, float *  HW, float *  UW, float *  VW, float *  RHO, int *  NLVLS, int *  NW, float *  BUOY, float *  RICHNUM); </code>    */
  private static native void richno0(Object HT, int HT_byte_offset, Object HW, int HW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object RHO, int RHO_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object NW, int NW_byte_offset, Object BUOY, int BUOY_byte_offset, Object RICHNUM, int RICHNUM_byte_offset);

  /** Entry point to C language function: <br> <code> void richno(float *  HT, float *  HW, float *  UW, float *  VW, float *  RHO, int *  NLVLS, int *  NW, float *  BUOY, float *  RICHNUM); </code>    */
  private static native void richno1(Object HT, int HT_byte_offset, Object HW, int HW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object RHO, int RHO_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object NW, int NW_byte_offset, Object BUOY, int BUOY_byte_offset, Object RICHNUM, int RICHNUM_byte_offset);

  /** Interface to C language function: <br> <code> void richno(float *  HT, float *  HW, float *  UW, float *  VW, float *  RHO, int *  NLVLS, int *  NW, float *  BUOY, float *  RICHNUM); </code>    */
  public static void richno(float[] HT, int HT_offset, float[] HW, int HW_offset, float[] UW, int UW_offset, float[] VW, int VW_offset, float[] RHO, int RHO_offset, int[] NLVLS, int NLVLS_offset, int[] NW, int NW_offset, float[] BUOY, int BUOY_offset, float[] RICHNUM, int RICHNUM_offset)
  {
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(HW != null && HW.length <= HW_offset)
      throw new RuntimeException("array offset argument \"HW_offset\" (" + HW_offset + ") equals or exceeds array length (" + HW.length + ")");
    if(UW != null && UW.length <= UW_offset)
      throw new RuntimeException("array offset argument \"UW_offset\" (" + UW_offset + ") equals or exceeds array length (" + UW.length + ")");
    if(VW != null && VW.length <= VW_offset)
      throw new RuntimeException("array offset argument \"VW_offset\" (" + VW_offset + ") equals or exceeds array length (" + VW.length + ")");
    if(RHO != null && RHO.length <= RHO_offset)
      throw new RuntimeException("array offset argument \"RHO_offset\" (" + RHO_offset + ") equals or exceeds array length (" + RHO.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(NW != null && NW.length <= NW_offset)
      throw new RuntimeException("array offset argument \"NW_offset\" (" + NW_offset + ") equals or exceeds array length (" + NW.length + ")");
    if(BUOY != null && BUOY.length <= BUOY_offset)
      throw new RuntimeException("array offset argument \"BUOY_offset\" (" + BUOY_offset + ") equals or exceeds array length (" + BUOY.length + ")");
    if(RICHNUM != null && RICHNUM.length <= RICHNUM_offset)
      throw new RuntimeException("array offset argument \"RICHNUM_offset\" (" + RICHNUM_offset + ") equals or exceeds array length (" + RICHNUM.length + ")");
        richno1(HT, BufferFactory.SIZEOF_FLOAT * HT_offset, HW, BufferFactory.SIZEOF_FLOAT * HW_offset, UW, BufferFactory.SIZEOF_FLOAT * UW_offset, VW, BufferFactory.SIZEOF_FLOAT * VW_offset, RHO, BufferFactory.SIZEOF_FLOAT * RHO_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, NW, BufferFactory.SIZEOF_INT * NW_offset, BUOY, BufferFactory.SIZEOF_FLOAT * BUOY_offset, RICHNUM, BufferFactory.SIZEOF_FLOAT * RICHNUM_offset);

  }

  /** Interface to C language function: <br> <code> void rotvectors(float *  aX, float *  aY, float *  angle, float *  bX, float *  bY, int *  mni, int *  ni, int *  nj); </code>    */
  public static void rotvectors(java.nio.FloatBuffer aX, java.nio.FloatBuffer aY, java.nio.FloatBuffer angle, java.nio.FloatBuffer bX, java.nio.FloatBuffer bY, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(aX);
    if (aY != null && _direct != BufferFactory.isDirect(aY))
      throw new RuntimeException("Argument \"aY\" : Buffers passed to this method must all be either direct or indirect");
    if (angle != null && _direct != BufferFactory.isDirect(angle))
      throw new RuntimeException("Argument \"angle\" : Buffers passed to this method must all be either direct or indirect");
    if (bX != null && _direct != BufferFactory.isDirect(bX))
      throw new RuntimeException("Argument \"bX\" : Buffers passed to this method must all be either direct or indirect");
    if (bY != null && _direct != BufferFactory.isDirect(bY))
      throw new RuntimeException("Argument \"bY\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        rotvectors0(aX, BufferFactory.getDirectBufferByteOffset(aX), aY, BufferFactory.getDirectBufferByteOffset(aY), angle, BufferFactory.getDirectBufferByteOffset(angle), bX, BufferFactory.getDirectBufferByteOffset(bX), bY, BufferFactory.getDirectBufferByteOffset(bY), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      rotvectors1(BufferFactory.getArray(aX), BufferFactory.getIndirectBufferByteOffset(aX), BufferFactory.getArray(aY), BufferFactory.getIndirectBufferByteOffset(aY), BufferFactory.getArray(angle), BufferFactory.getIndirectBufferByteOffset(angle), BufferFactory.getArray(bX), BufferFactory.getIndirectBufferByteOffset(bX), BufferFactory.getArray(bY), BufferFactory.getIndirectBufferByteOffset(bY), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void rotvectors(float *  aX, float *  aY, float *  angle, float *  bX, float *  bY, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void rotvectors0(Object aX, int aX_byte_offset, Object aY, int aY_byte_offset, Object angle, int angle_byte_offset, Object bX, int bX_byte_offset, Object bY, int bY_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void rotvectors(float *  aX, float *  aY, float *  angle, float *  bX, float *  bY, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void rotvectors1(Object aX, int aX_byte_offset, Object aY, int aY_byte_offset, Object angle, int angle_byte_offset, Object bX, int bX_byte_offset, Object bY, int bY_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void rotvectors(float *  aX, float *  aY, float *  angle, float *  bX, float *  bY, int *  mni, int *  ni, int *  nj); </code>    */
  public static void rotvectors(float[] aX, int aX_offset, float[] aY, int aY_offset, float[] angle, int angle_offset, float[] bX, int bX_offset, float[] bY, int bY_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(aX != null && aX.length <= aX_offset)
      throw new RuntimeException("array offset argument \"aX_offset\" (" + aX_offset + ") equals or exceeds array length (" + aX.length + ")");
    if(aY != null && aY.length <= aY_offset)
      throw new RuntimeException("array offset argument \"aY_offset\" (" + aY_offset + ") equals or exceeds array length (" + aY.length + ")");
    if(angle != null && angle.length <= angle_offset)
      throw new RuntimeException("array offset argument \"angle_offset\" (" + angle_offset + ") equals or exceeds array length (" + angle.length + ")");
    if(bX != null && bX.length <= bX_offset)
      throw new RuntimeException("array offset argument \"bX_offset\" (" + bX_offset + ") equals or exceeds array length (" + bX.length + ")");
    if(bY != null && bY.length <= bY_offset)
      throw new RuntimeException("array offset argument \"bY_offset\" (" + bY_offset + ") equals or exceeds array length (" + bY.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        rotvectors1(aX, BufferFactory.SIZEOF_FLOAT * aX_offset, aY, BufferFactory.SIZEOF_FLOAT * aY_offset, angle, BufferFactory.SIZEOF_FLOAT * angle_offset, bX, BufferFactory.SIZEOF_FLOAT * bX_offset, bY, BufferFactory.SIZEOF_FLOAT * bY_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void sampleSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, int hyb, float *  slice); </code>    */
  public static void sampleSlice(java.nio.FloatBuffer[] vc3d, java.nio.FloatBuffer vc2d, java.nio.FloatBuffer[] slice3d, int mnx, int nx, int ny, int nz, int sense, int hyb, java.nio.FloatBuffer slice)
  {
    int[] vc3d_byte_offset_array = new int[vc3d.length];
    if (vc3d != null) {
      for (int _ctr = 0; _ctr < vc3d.length; _ctr++) {
        if (!BufferFactory.isDirect(vc3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"vc3d\" was not a direct buffer");
        }
        vc3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(vc3d[_ctr]);
      }
    }
    boolean _direct = BufferFactory.isDirect(vc2d);
    int[] slice3d_byte_offset_array = new int[slice3d.length];
    if (slice3d != null) {
      for (int _ctr = 0; _ctr < slice3d.length; _ctr++) {
        if (!BufferFactory.isDirect(slice3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"slice3d\" was not a direct buffer");
        }
        slice3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(slice3d[_ctr]);
      }
    }
    if (slice != null && _direct != BufferFactory.isDirect(slice))
      throw new RuntimeException("Argument \"slice\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        sampleSlice0(vc3d, vc3d_byte_offset_array, vc2d, BufferFactory.getDirectBufferByteOffset(vc2d), slice3d, slice3d_byte_offset_array, mnx, nx, ny, nz, sense, hyb, slice, BufferFactory.getDirectBufferByteOffset(slice));
    } else {
      sampleSlice1(vc3d, vc3d_byte_offset_array, BufferFactory.getArray(vc2d), BufferFactory.getIndirectBufferByteOffset(vc2d), slice3d, slice3d_byte_offset_array, mnx, nx, ny, nz, sense, hyb, BufferFactory.getArray(slice), BufferFactory.getIndirectBufferByteOffset(slice));
    }
  }

  /** Entry point to C language function: <br> <code> void sampleSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, int hyb, float *  slice); </code>    */
  private static native void sampleSlice0(Object[] vc3d, int[] vc3d_byte_offset_array, Object vc2d, int vc2d_byte_offset, Object[] slice3d, int[] slice3d_byte_offset_array, int mnx, int nx, int ny, int nz, int sense, int hyb, Object slice, int slice_byte_offset);

  /** Entry point to C language function: <br> <code> void sampleSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, int hyb, float *  slice); </code>    */
  private static native void sampleSlice1(Object[] vc3d, int[] vc3d_byte_offset_array, Object vc2d, int vc2d_byte_offset, Object[] slice3d, int[] slice3d_byte_offset_array, int mnx, int nx, int ny, int nz, int sense, int hyb, Object slice, int slice_byte_offset);

  /** Interface to C language function: <br> <code> void sampleSlice(const float *  *  vc3d, float *  vc2d, const float *  *  slice3d, int mnx, int nx, int ny, int nz, int sense, int hyb, float *  slice); </code>    */
  public static void sampleSlice(java.nio.FloatBuffer[] vc3d, float[] vc2d, int vc2d_offset, java.nio.FloatBuffer[] slice3d, int mnx, int nx, int ny, int nz, int sense, int hyb, float[] slice, int slice_offset)
  {
    int[] vc3d_byte_offset_array = new int[vc3d.length];
    if (vc3d != null) {
      for (int _ctr = 0; _ctr < vc3d.length; _ctr++) {
        if (!BufferFactory.isDirect(vc3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"vc3d\" was not a direct buffer");
        }
        vc3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(vc3d[_ctr]);
      }
    }
    if(vc2d != null && vc2d.length <= vc2d_offset)
      throw new RuntimeException("array offset argument \"vc2d_offset\" (" + vc2d_offset + ") equals or exceeds array length (" + vc2d.length + ")");
    int[] slice3d_byte_offset_array = new int[slice3d.length];
    if (slice3d != null) {
      for (int _ctr = 0; _ctr < slice3d.length; _ctr++) {
        if (!BufferFactory.isDirect(slice3d[_ctr])) {
          throw new RuntimeException("Element " + _ctr + " of argument \"slice3d\" was not a direct buffer");
        }
        slice3d_byte_offset_array[_ctr] = BufferFactory.getDirectBufferByteOffset(slice3d[_ctr]);
      }
    }
    if(slice != null && slice.length <= slice_offset)
      throw new RuntimeException("array offset argument \"slice_offset\" (" + slice_offset + ") equals or exceeds array length (" + slice.length + ")");
        sampleSlice1(vc3d, vc3d_byte_offset_array, vc2d, BufferFactory.SIZEOF_FLOAT * vc2d_offset, slice3d, slice3d_byte_offset_array, mnx, nx, ny, nz, sense, hyb, slice, BufferFactory.SIZEOF_FLOAT * slice_offset);

  }

  /** Interface to C language function: <br> <code> int scaleless_analysis(float *  xind, float *  yind, float *  values, int *  nv, int *  nx, int *  ny, float *  grid); </code>    */
  public static int scaleless_analysis(java.nio.FloatBuffer xind, java.nio.FloatBuffer yind, java.nio.FloatBuffer values, java.nio.IntBuffer nv, java.nio.IntBuffer nx, java.nio.IntBuffer ny, java.nio.FloatBuffer grid)
  {
    boolean _direct = BufferFactory.isDirect(xind);
    if (yind != null && _direct != BufferFactory.isDirect(yind))
      throw new RuntimeException("Argument \"yind\" : Buffers passed to this method must all be either direct or indirect");
    if (values != null && _direct != BufferFactory.isDirect(values))
      throw new RuntimeException("Argument \"values\" : Buffers passed to this method must all be either direct or indirect");
    if (nv != null && _direct != BufferFactory.isDirect(nv))
      throw new RuntimeException("Argument \"nv\" : Buffers passed to this method must all be either direct or indirect");
    if (nx != null && _direct != BufferFactory.isDirect(nx))
      throw new RuntimeException("Argument \"nx\" : Buffers passed to this method must all be either direct or indirect");
    if (ny != null && _direct != BufferFactory.isDirect(ny))
      throw new RuntimeException("Argument \"ny\" : Buffers passed to this method must all be either direct or indirect");
    if (grid != null && _direct != BufferFactory.isDirect(grid))
      throw new RuntimeException("Argument \"grid\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return scaleless_analysis0(xind, BufferFactory.getDirectBufferByteOffset(xind), yind, BufferFactory.getDirectBufferByteOffset(yind), values, BufferFactory.getDirectBufferByteOffset(values), nv, BufferFactory.getDirectBufferByteOffset(nv), nx, BufferFactory.getDirectBufferByteOffset(nx), ny, BufferFactory.getDirectBufferByteOffset(ny), grid, BufferFactory.getDirectBufferByteOffset(grid));
    } else {
      return scaleless_analysis1(BufferFactory.getArray(xind), BufferFactory.getIndirectBufferByteOffset(xind), BufferFactory.getArray(yind), BufferFactory.getIndirectBufferByteOffset(yind), BufferFactory.getArray(values), BufferFactory.getIndirectBufferByteOffset(values), BufferFactory.getArray(nv), BufferFactory.getIndirectBufferByteOffset(nv), BufferFactory.getArray(nx), BufferFactory.getIndirectBufferByteOffset(nx), BufferFactory.getArray(ny), BufferFactory.getIndirectBufferByteOffset(ny), BufferFactory.getArray(grid), BufferFactory.getIndirectBufferByteOffset(grid));
    }
  }

  /** Entry point to C language function: <br> <code> int scaleless_analysis(float *  xind, float *  yind, float *  values, int *  nv, int *  nx, int *  ny, float *  grid); </code>    */
  private static native int scaleless_analysis0(Object xind, int xind_byte_offset, Object yind, int yind_byte_offset, Object values, int values_byte_offset, Object nv, int nv_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object grid, int grid_byte_offset);

  /** Entry point to C language function: <br> <code> int scaleless_analysis(float *  xind, float *  yind, float *  values, int *  nv, int *  nx, int *  ny, float *  grid); </code>    */
  private static native int scaleless_analysis1(Object xind, int xind_byte_offset, Object yind, int yind_byte_offset, Object values, int values_byte_offset, Object nv, int nv_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object grid, int grid_byte_offset);

  /** Interface to C language function: <br> <code> int scaleless_analysis(float *  xind, float *  yind, float *  values, int *  nv, int *  nx, int *  ny, float *  grid); </code>    */
  public static int scaleless_analysis(float[] xind, int xind_offset, float[] yind, int yind_offset, float[] values, int values_offset, int[] nv, int nv_offset, int[] nx, int nx_offset, int[] ny, int ny_offset, float[] grid, int grid_offset)
  {
    if(xind != null && xind.length <= xind_offset)
      throw new RuntimeException("array offset argument \"xind_offset\" (" + xind_offset + ") equals or exceeds array length (" + xind.length + ")");
    if(yind != null && yind.length <= yind_offset)
      throw new RuntimeException("array offset argument \"yind_offset\" (" + yind_offset + ") equals or exceeds array length (" + yind.length + ")");
    if(values != null && values.length <= values_offset)
      throw new RuntimeException("array offset argument \"values_offset\" (" + values_offset + ") equals or exceeds array length (" + values.length + ")");
    if(nv != null && nv.length <= nv_offset)
      throw new RuntimeException("array offset argument \"nv_offset\" (" + nv_offset + ") equals or exceeds array length (" + nv.length + ")");
    if(nx != null && nx.length <= nx_offset)
      throw new RuntimeException("array offset argument \"nx_offset\" (" + nx_offset + ") equals or exceeds array length (" + nx.length + ")");
    if(ny != null && ny.length <= ny_offset)
      throw new RuntimeException("array offset argument \"ny_offset\" (" + ny_offset + ") equals or exceeds array length (" + ny.length + ")");
    if(grid != null && grid.length <= grid_offset)
      throw new RuntimeException("array offset argument \"grid_offset\" (" + grid_offset + ") equals or exceeds array length (" + grid.length + ")");
        return scaleless_analysis1(xind, BufferFactory.SIZEOF_FLOAT * xind_offset, yind, BufferFactory.SIZEOF_FLOAT * yind_offset, values, BufferFactory.SIZEOF_FLOAT * values_offset, nv, BufferFactory.SIZEOF_INT * nv_offset, nx, BufferFactory.SIZEOF_INT * nx_offset, ny, BufferFactory.SIZEOF_INT * ny_offset, grid, BufferFactory.SIZEOF_FLOAT * grid_offset);

  }

  /** Interface to C language function: <br> <code> void setqsmooth(int *  npass, float *  smthwgt); </code>    */
  public static void setqsmooth(java.nio.IntBuffer npass, java.nio.FloatBuffer smthwgt)
  {
    boolean _direct = BufferFactory.isDirect(npass);
    if (smthwgt != null && _direct != BufferFactory.isDirect(smthwgt))
      throw new RuntimeException("Argument \"smthwgt\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        setqsmooth0(npass, BufferFactory.getDirectBufferByteOffset(npass), smthwgt, BufferFactory.getDirectBufferByteOffset(smthwgt));
    } else {
      setqsmooth1(BufferFactory.getArray(npass), BufferFactory.getIndirectBufferByteOffset(npass), BufferFactory.getArray(smthwgt), BufferFactory.getIndirectBufferByteOffset(smthwgt));
    }
  }

  /** Entry point to C language function: <br> <code> void setqsmooth(int *  npass, float *  smthwgt); </code>    */
  private static native void setqsmooth0(Object npass, int npass_byte_offset, Object smthwgt, int smthwgt_byte_offset);

  /** Entry point to C language function: <br> <code> void setqsmooth(int *  npass, float *  smthwgt); </code>    */
  private static native void setqsmooth1(Object npass, int npass_byte_offset, Object smthwgt, int smthwgt_byte_offset);

  /** Interface to C language function: <br> <code> void setqsmooth(int *  npass, float *  smthwgt); </code>    */
  public static void setqsmooth(int[] npass, int npass_offset, float[] smthwgt, int smthwgt_offset)
  {
    if(npass != null && npass.length <= npass_offset)
      throw new RuntimeException("array offset argument \"npass_offset\" (" + npass_offset + ") equals or exceeds array length (" + npass.length + ")");
    if(smthwgt != null && smthwgt.length <= smthwgt_offset)
      throw new RuntimeException("array offset argument \"smthwgt_offset\" (" + smthwgt_offset + ") equals or exceeds array length (" + smthwgt.length + ")");
        setqsmooth1(npass, BufferFactory.SIZEOF_INT * npass_offset, smthwgt, BufferFactory.SIZEOF_FLOAT * smthwgt_offset);

  }

  /** Interface to C language function: <br> <code> void slfront(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  fgen, float *  slqx, float *  slqy, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy); </code>    */
  public static void slfront(java.nio.FloatBuffer z, java.nio.FloatBuffer t, java.nio.FloatBuffer p, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer coriolis, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer fgen, java.nio.FloatBuffer slqx, java.nio.FloatBuffer slqy, java.nio.FloatBuffer w1, java.nio.FloatBuffer w2, java.nio.FloatBuffer w3, java.nio.FloatBuffer dtdx, java.nio.FloatBuffer dtdy)
  {
    boolean _direct = BufferFactory.isDirect(z);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (coriolis != null && _direct != BufferFactory.isDirect(coriolis))
      throw new RuntimeException("Argument \"coriolis\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (fgen != null && _direct != BufferFactory.isDirect(fgen))
      throw new RuntimeException("Argument \"fgen\" : Buffers passed to this method must all be either direct or indirect");
    if (slqx != null && _direct != BufferFactory.isDirect(slqx))
      throw new RuntimeException("Argument \"slqx\" : Buffers passed to this method must all be either direct or indirect");
    if (slqy != null && _direct != BufferFactory.isDirect(slqy))
      throw new RuntimeException("Argument \"slqy\" : Buffers passed to this method must all be either direct or indirect");
    if (w1 != null && _direct != BufferFactory.isDirect(w1))
      throw new RuntimeException("Argument \"w1\" : Buffers passed to this method must all be either direct or indirect");
    if (w2 != null && _direct != BufferFactory.isDirect(w2))
      throw new RuntimeException("Argument \"w2\" : Buffers passed to this method must all be either direct or indirect");
    if (w3 != null && _direct != BufferFactory.isDirect(w3))
      throw new RuntimeException("Argument \"w3\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx != null && _direct != BufferFactory.isDirect(dtdx))
      throw new RuntimeException("Argument \"dtdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy != null && _direct != BufferFactory.isDirect(dtdy))
      throw new RuntimeException("Argument \"dtdy\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        slfront0(z, BufferFactory.getDirectBufferByteOffset(z), t, BufferFactory.getDirectBufferByteOffset(t), p, BufferFactory.getDirectBufferByteOffset(p), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), coriolis, BufferFactory.getDirectBufferByteOffset(coriolis), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), fgen, BufferFactory.getDirectBufferByteOffset(fgen), slqx, BufferFactory.getDirectBufferByteOffset(slqx), slqy, BufferFactory.getDirectBufferByteOffset(slqy), w1, BufferFactory.getDirectBufferByteOffset(w1), w2, BufferFactory.getDirectBufferByteOffset(w2), w3, BufferFactory.getDirectBufferByteOffset(w3), dtdx, BufferFactory.getDirectBufferByteOffset(dtdx), dtdy, BufferFactory.getDirectBufferByteOffset(dtdy));
    } else {
      slfront1(BufferFactory.getArray(z), BufferFactory.getIndirectBufferByteOffset(z), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(coriolis), BufferFactory.getIndirectBufferByteOffset(coriolis), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(fgen), BufferFactory.getIndirectBufferByteOffset(fgen), BufferFactory.getArray(slqx), BufferFactory.getIndirectBufferByteOffset(slqx), BufferFactory.getArray(slqy), BufferFactory.getIndirectBufferByteOffset(slqy), BufferFactory.getArray(w1), BufferFactory.getIndirectBufferByteOffset(w1), BufferFactory.getArray(w2), BufferFactory.getIndirectBufferByteOffset(w2), BufferFactory.getArray(w3), BufferFactory.getIndirectBufferByteOffset(w3), BufferFactory.getArray(dtdx), BufferFactory.getIndirectBufferByteOffset(dtdx), BufferFactory.getArray(dtdy), BufferFactory.getIndirectBufferByteOffset(dtdy));
    }
  }

  /** Entry point to C language function: <br> <code> void slfront(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  fgen, float *  slqx, float *  slqy, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy); </code>    */
  private static native void slfront0(Object z, int z_byte_offset, Object t, int t_byte_offset, Object p, int p_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object fgen, int fgen_byte_offset, Object slqx, int slqx_byte_offset, Object slqy, int slqy_byte_offset, Object w1, int w1_byte_offset, Object w2, int w2_byte_offset, Object w3, int w3_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset);

  /** Entry point to C language function: <br> <code> void slfront(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  fgen, float *  slqx, float *  slqy, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy); </code>    */
  private static native void slfront1(Object z, int z_byte_offset, Object t, int t_byte_offset, Object p, int p_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object fgen, int fgen_byte_offset, Object slqx, int slqx_byte_offset, Object slqy, int slqy_byte_offset, Object w1, int w1_byte_offset, Object w2, int w2_byte_offset, Object w3, int w3_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset);

  /** Interface to C language function: <br> <code> void slfront(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  fgen, float *  slqx, float *  slqy, float *  w1, float *  w2, float *  w3, float *  dtdx, float *  dtdy); </code>    */
  public static void slfront(float[] z, int z_offset, float[] t, int t_offset, float[] p, int p_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] coriolis, int coriolis_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] fgen, int fgen_offset, float[] slqx, int slqx_offset, float[] slqy, int slqy_offset, float[] w1, int w1_offset, float[] w2, int w2_offset, float[] w3, int w3_offset, float[] dtdx, int dtdx_offset, float[] dtdy, int dtdy_offset)
  {
    if(z != null && z.length <= z_offset)
      throw new RuntimeException("array offset argument \"z_offset\" (" + z_offset + ") equals or exceeds array length (" + z.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(coriolis != null && coriolis.length <= coriolis_offset)
      throw new RuntimeException("array offset argument \"coriolis_offset\" (" + coriolis_offset + ") equals or exceeds array length (" + coriolis.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(fgen != null && fgen.length <= fgen_offset)
      throw new RuntimeException("array offset argument \"fgen_offset\" (" + fgen_offset + ") equals or exceeds array length (" + fgen.length + ")");
    if(slqx != null && slqx.length <= slqx_offset)
      throw new RuntimeException("array offset argument \"slqx_offset\" (" + slqx_offset + ") equals or exceeds array length (" + slqx.length + ")");
    if(slqy != null && slqy.length <= slqy_offset)
      throw new RuntimeException("array offset argument \"slqy_offset\" (" + slqy_offset + ") equals or exceeds array length (" + slqy.length + ")");
    if(w1 != null && w1.length <= w1_offset)
      throw new RuntimeException("array offset argument \"w1_offset\" (" + w1_offset + ") equals or exceeds array length (" + w1.length + ")");
    if(w2 != null && w2.length <= w2_offset)
      throw new RuntimeException("array offset argument \"w2_offset\" (" + w2_offset + ") equals or exceeds array length (" + w2.length + ")");
    if(w3 != null && w3.length <= w3_offset)
      throw new RuntimeException("array offset argument \"w3_offset\" (" + w3_offset + ") equals or exceeds array length (" + w3.length + ")");
    if(dtdx != null && dtdx.length <= dtdx_offset)
      throw new RuntimeException("array offset argument \"dtdx_offset\" (" + dtdx_offset + ") equals or exceeds array length (" + dtdx.length + ")");
    if(dtdy != null && dtdy.length <= dtdy_offset)
      throw new RuntimeException("array offset argument \"dtdy_offset\" (" + dtdy_offset + ") equals or exceeds array length (" + dtdy.length + ")");
        slfront1(z, BufferFactory.SIZEOF_FLOAT * z_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, coriolis, BufferFactory.SIZEOF_FLOAT * coriolis_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, fgen, BufferFactory.SIZEOF_FLOAT * fgen_offset, slqx, BufferFactory.SIZEOF_FLOAT * slqx_offset, slqy, BufferFactory.SIZEOF_FLOAT * slqy_offset, w1, BufferFactory.SIZEOF_FLOAT * w1_offset, w2, BufferFactory.SIZEOF_FLOAT * w2_offset, w3, BufferFactory.SIZEOF_FLOAT * w3_offset, dtdx, BufferFactory.SIZEOF_FLOAT * dtdx_offset, dtdy, BufferFactory.SIZEOF_FLOAT * dtdy_offset);

  }

  /** Interface to C language function: <br> <code> void slqvect(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  slqx, float *  slqy, float *  dugdx, float *  dugdy, float *  dvgdx, float *  dvgdy, float *  dtdx, float *  dtdy); </code>    */
  public static void slqvect(java.nio.FloatBuffer z, java.nio.FloatBuffer t, java.nio.FloatBuffer p, java.nio.FloatBuffer dx, java.nio.FloatBuffer dy, java.nio.FloatBuffer coriolis, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer slqx, java.nio.FloatBuffer slqy, java.nio.FloatBuffer dugdx, java.nio.FloatBuffer dugdy, java.nio.FloatBuffer dvgdx, java.nio.FloatBuffer dvgdy, java.nio.FloatBuffer dtdx, java.nio.FloatBuffer dtdy)
  {
    boolean _direct = BufferFactory.isDirect(z);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (dx != null && _direct != BufferFactory.isDirect(dx))
      throw new RuntimeException("Argument \"dx\" : Buffers passed to this method must all be either direct or indirect");
    if (dy != null && _direct != BufferFactory.isDirect(dy))
      throw new RuntimeException("Argument \"dy\" : Buffers passed to this method must all be either direct or indirect");
    if (coriolis != null && _direct != BufferFactory.isDirect(coriolis))
      throw new RuntimeException("Argument \"coriolis\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (slqx != null && _direct != BufferFactory.isDirect(slqx))
      throw new RuntimeException("Argument \"slqx\" : Buffers passed to this method must all be either direct or indirect");
    if (slqy != null && _direct != BufferFactory.isDirect(slqy))
      throw new RuntimeException("Argument \"slqy\" : Buffers passed to this method must all be either direct or indirect");
    if (dugdx != null && _direct != BufferFactory.isDirect(dugdx))
      throw new RuntimeException("Argument \"dugdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dugdy != null && _direct != BufferFactory.isDirect(dugdy))
      throw new RuntimeException("Argument \"dugdy\" : Buffers passed to this method must all be either direct or indirect");
    if (dvgdx != null && _direct != BufferFactory.isDirect(dvgdx))
      throw new RuntimeException("Argument \"dvgdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dvgdy != null && _direct != BufferFactory.isDirect(dvgdy))
      throw new RuntimeException("Argument \"dvgdy\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdx != null && _direct != BufferFactory.isDirect(dtdx))
      throw new RuntimeException("Argument \"dtdx\" : Buffers passed to this method must all be either direct or indirect");
    if (dtdy != null && _direct != BufferFactory.isDirect(dtdy))
      throw new RuntimeException("Argument \"dtdy\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        slqvect0(z, BufferFactory.getDirectBufferByteOffset(z), t, BufferFactory.getDirectBufferByteOffset(t), p, BufferFactory.getDirectBufferByteOffset(p), dx, BufferFactory.getDirectBufferByteOffset(dx), dy, BufferFactory.getDirectBufferByteOffset(dy), coriolis, BufferFactory.getDirectBufferByteOffset(coriolis), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), slqx, BufferFactory.getDirectBufferByteOffset(slqx), slqy, BufferFactory.getDirectBufferByteOffset(slqy), dugdx, BufferFactory.getDirectBufferByteOffset(dugdx), dugdy, BufferFactory.getDirectBufferByteOffset(dugdy), dvgdx, BufferFactory.getDirectBufferByteOffset(dvgdx), dvgdy, BufferFactory.getDirectBufferByteOffset(dvgdy), dtdx, BufferFactory.getDirectBufferByteOffset(dtdx), dtdy, BufferFactory.getDirectBufferByteOffset(dtdy));
    } else {
      slqvect1(BufferFactory.getArray(z), BufferFactory.getIndirectBufferByteOffset(z), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(dx), BufferFactory.getIndirectBufferByteOffset(dx), BufferFactory.getArray(dy), BufferFactory.getIndirectBufferByteOffset(dy), BufferFactory.getArray(coriolis), BufferFactory.getIndirectBufferByteOffset(coriolis), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(slqx), BufferFactory.getIndirectBufferByteOffset(slqx), BufferFactory.getArray(slqy), BufferFactory.getIndirectBufferByteOffset(slqy), BufferFactory.getArray(dugdx), BufferFactory.getIndirectBufferByteOffset(dugdx), BufferFactory.getArray(dugdy), BufferFactory.getIndirectBufferByteOffset(dugdy), BufferFactory.getArray(dvgdx), BufferFactory.getIndirectBufferByteOffset(dvgdx), BufferFactory.getArray(dvgdy), BufferFactory.getIndirectBufferByteOffset(dvgdy), BufferFactory.getArray(dtdx), BufferFactory.getIndirectBufferByteOffset(dtdx), BufferFactory.getArray(dtdy), BufferFactory.getIndirectBufferByteOffset(dtdy));
    }
  }

  /** Entry point to C language function: <br> <code> void slqvect(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  slqx, float *  slqy, float *  dugdx, float *  dugdy, float *  dvgdx, float *  dvgdy, float *  dtdx, float *  dtdy); </code>    */
  private static native void slqvect0(Object z, int z_byte_offset, Object t, int t_byte_offset, Object p, int p_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object slqx, int slqx_byte_offset, Object slqy, int slqy_byte_offset, Object dugdx, int dugdx_byte_offset, Object dugdy, int dugdy_byte_offset, Object dvgdx, int dvgdx_byte_offset, Object dvgdy, int dvgdy_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset);

  /** Entry point to C language function: <br> <code> void slqvect(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  slqx, float *  slqy, float *  dugdx, float *  dugdy, float *  dvgdx, float *  dvgdy, float *  dtdx, float *  dtdy); </code>    */
  private static native void slqvect1(Object z, int z_byte_offset, Object t, int t_byte_offset, Object p, int p_byte_offset, Object dx, int dx_byte_offset, Object dy, int dy_byte_offset, Object coriolis, int coriolis_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object slqx, int slqx_byte_offset, Object slqy, int slqy_byte_offset, Object dugdx, int dugdx_byte_offset, Object dugdy, int dugdy_byte_offset, Object dvgdx, int dvgdx_byte_offset, Object dvgdy, int dvgdy_byte_offset, Object dtdx, int dtdx_byte_offset, Object dtdy, int dtdy_byte_offset);

  /** Interface to C language function: <br> <code> void slqvect(float *  z, float *  t, float *  p, float *  dx, float *  dy, float *  coriolis, int *  mni, int *  ni, int *  nj, float *  slqx, float *  slqy, float *  dugdx, float *  dugdy, float *  dvgdx, float *  dvgdy, float *  dtdx, float *  dtdy); </code>    */
  public static void slqvect(float[] z, int z_offset, float[] t, int t_offset, float[] p, int p_offset, float[] dx, int dx_offset, float[] dy, int dy_offset, float[] coriolis, int coriolis_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] slqx, int slqx_offset, float[] slqy, int slqy_offset, float[] dugdx, int dugdx_offset, float[] dugdy, int dugdy_offset, float[] dvgdx, int dvgdx_offset, float[] dvgdy, int dvgdy_offset, float[] dtdx, int dtdx_offset, float[] dtdy, int dtdy_offset)
  {
    if(z != null && z.length <= z_offset)
      throw new RuntimeException("array offset argument \"z_offset\" (" + z_offset + ") equals or exceeds array length (" + z.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(dx != null && dx.length <= dx_offset)
      throw new RuntimeException("array offset argument \"dx_offset\" (" + dx_offset + ") equals or exceeds array length (" + dx.length + ")");
    if(dy != null && dy.length <= dy_offset)
      throw new RuntimeException("array offset argument \"dy_offset\" (" + dy_offset + ") equals or exceeds array length (" + dy.length + ")");
    if(coriolis != null && coriolis.length <= coriolis_offset)
      throw new RuntimeException("array offset argument \"coriolis_offset\" (" + coriolis_offset + ") equals or exceeds array length (" + coriolis.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(slqx != null && slqx.length <= slqx_offset)
      throw new RuntimeException("array offset argument \"slqx_offset\" (" + slqx_offset + ") equals or exceeds array length (" + slqx.length + ")");
    if(slqy != null && slqy.length <= slqy_offset)
      throw new RuntimeException("array offset argument \"slqy_offset\" (" + slqy_offset + ") equals or exceeds array length (" + slqy.length + ")");
    if(dugdx != null && dugdx.length <= dugdx_offset)
      throw new RuntimeException("array offset argument \"dugdx_offset\" (" + dugdx_offset + ") equals or exceeds array length (" + dugdx.length + ")");
    if(dugdy != null && dugdy.length <= dugdy_offset)
      throw new RuntimeException("array offset argument \"dugdy_offset\" (" + dugdy_offset + ") equals or exceeds array length (" + dugdy.length + ")");
    if(dvgdx != null && dvgdx.length <= dvgdx_offset)
      throw new RuntimeException("array offset argument \"dvgdx_offset\" (" + dvgdx_offset + ") equals or exceeds array length (" + dvgdx.length + ")");
    if(dvgdy != null && dvgdy.length <= dvgdy_offset)
      throw new RuntimeException("array offset argument \"dvgdy_offset\" (" + dvgdy_offset + ") equals or exceeds array length (" + dvgdy.length + ")");
    if(dtdx != null && dtdx.length <= dtdx_offset)
      throw new RuntimeException("array offset argument \"dtdx_offset\" (" + dtdx_offset + ") equals or exceeds array length (" + dtdx.length + ")");
    if(dtdy != null && dtdy.length <= dtdy_offset)
      throw new RuntimeException("array offset argument \"dtdy_offset\" (" + dtdy_offset + ") equals or exceeds array length (" + dtdy.length + ")");
        slqvect1(z, BufferFactory.SIZEOF_FLOAT * z_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset, dx, BufferFactory.SIZEOF_FLOAT * dx_offset, dy, BufferFactory.SIZEOF_FLOAT * dy_offset, coriolis, BufferFactory.SIZEOF_FLOAT * coriolis_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, slqx, BufferFactory.SIZEOF_FLOAT * slqx_offset, slqy, BufferFactory.SIZEOF_FLOAT * slqy_offset, dugdx, BufferFactory.SIZEOF_FLOAT * dugdx_offset, dugdy, BufferFactory.SIZEOF_FLOAT * dugdy_offset, dvgdx, BufferFactory.SIZEOF_FLOAT * dvgdx_offset, dvgdy, BufferFactory.SIZEOF_FLOAT * dvgdy_offset, dtdx, BufferFactory.SIZEOF_FLOAT * dtdx_offset, dtdy, BufferFactory.SIZEOF_FLOAT * dtdy_offset);

  }

  /** Interface to C language function: <br> <code> void solax(int *  JULDAY, int *  MONTH, float *  SLAT, int *  TYMINC, int *  TSTART, int *  TSTOP, float *  TSRAD); </code>    */
  public static void solax(java.nio.IntBuffer JULDAY, java.nio.IntBuffer MONTH, java.nio.FloatBuffer SLAT, java.nio.IntBuffer TYMINC, java.nio.IntBuffer TSTART, java.nio.IntBuffer TSTOP, java.nio.FloatBuffer TSRAD)
  {
    boolean _direct = BufferFactory.isDirect(JULDAY);
    if (MONTH != null && _direct != BufferFactory.isDirect(MONTH))
      throw new RuntimeException("Argument \"MONTH\" : Buffers passed to this method must all be either direct or indirect");
    if (SLAT != null && _direct != BufferFactory.isDirect(SLAT))
      throw new RuntimeException("Argument \"SLAT\" : Buffers passed to this method must all be either direct or indirect");
    if (TYMINC != null && _direct != BufferFactory.isDirect(TYMINC))
      throw new RuntimeException("Argument \"TYMINC\" : Buffers passed to this method must all be either direct or indirect");
    if (TSTART != null && _direct != BufferFactory.isDirect(TSTART))
      throw new RuntimeException("Argument \"TSTART\" : Buffers passed to this method must all be either direct or indirect");
    if (TSTOP != null && _direct != BufferFactory.isDirect(TSTOP))
      throw new RuntimeException("Argument \"TSTOP\" : Buffers passed to this method must all be either direct or indirect");
    if (TSRAD != null && _direct != BufferFactory.isDirect(TSRAD))
      throw new RuntimeException("Argument \"TSRAD\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        solax0(JULDAY, BufferFactory.getDirectBufferByteOffset(JULDAY), MONTH, BufferFactory.getDirectBufferByteOffset(MONTH), SLAT, BufferFactory.getDirectBufferByteOffset(SLAT), TYMINC, BufferFactory.getDirectBufferByteOffset(TYMINC), TSTART, BufferFactory.getDirectBufferByteOffset(TSTART), TSTOP, BufferFactory.getDirectBufferByteOffset(TSTOP), TSRAD, BufferFactory.getDirectBufferByteOffset(TSRAD));
    } else {
      solax1(BufferFactory.getArray(JULDAY), BufferFactory.getIndirectBufferByteOffset(JULDAY), BufferFactory.getArray(MONTH), BufferFactory.getIndirectBufferByteOffset(MONTH), BufferFactory.getArray(SLAT), BufferFactory.getIndirectBufferByteOffset(SLAT), BufferFactory.getArray(TYMINC), BufferFactory.getIndirectBufferByteOffset(TYMINC), BufferFactory.getArray(TSTART), BufferFactory.getIndirectBufferByteOffset(TSTART), BufferFactory.getArray(TSTOP), BufferFactory.getIndirectBufferByteOffset(TSTOP), BufferFactory.getArray(TSRAD), BufferFactory.getIndirectBufferByteOffset(TSRAD));
    }
  }

  /** Entry point to C language function: <br> <code> void solax(int *  JULDAY, int *  MONTH, float *  SLAT, int *  TYMINC, int *  TSTART, int *  TSTOP, float *  TSRAD); </code>    */
  private static native void solax0(Object JULDAY, int JULDAY_byte_offset, Object MONTH, int MONTH_byte_offset, Object SLAT, int SLAT_byte_offset, Object TYMINC, int TYMINC_byte_offset, Object TSTART, int TSTART_byte_offset, Object TSTOP, int TSTOP_byte_offset, Object TSRAD, int TSRAD_byte_offset);

  /** Entry point to C language function: <br> <code> void solax(int *  JULDAY, int *  MONTH, float *  SLAT, int *  TYMINC, int *  TSTART, int *  TSTOP, float *  TSRAD); </code>    */
  private static native void solax1(Object JULDAY, int JULDAY_byte_offset, Object MONTH, int MONTH_byte_offset, Object SLAT, int SLAT_byte_offset, Object TYMINC, int TYMINC_byte_offset, Object TSTART, int TSTART_byte_offset, Object TSTOP, int TSTOP_byte_offset, Object TSRAD, int TSRAD_byte_offset);

  /** Interface to C language function: <br> <code> void solax(int *  JULDAY, int *  MONTH, float *  SLAT, int *  TYMINC, int *  TSTART, int *  TSTOP, float *  TSRAD); </code>    */
  public static void solax(int[] JULDAY, int JULDAY_offset, int[] MONTH, int MONTH_offset, float[] SLAT, int SLAT_offset, int[] TYMINC, int TYMINC_offset, int[] TSTART, int TSTART_offset, int[] TSTOP, int TSTOP_offset, float[] TSRAD, int TSRAD_offset)
  {
    if(JULDAY != null && JULDAY.length <= JULDAY_offset)
      throw new RuntimeException("array offset argument \"JULDAY_offset\" (" + JULDAY_offset + ") equals or exceeds array length (" + JULDAY.length + ")");
    if(MONTH != null && MONTH.length <= MONTH_offset)
      throw new RuntimeException("array offset argument \"MONTH_offset\" (" + MONTH_offset + ") equals or exceeds array length (" + MONTH.length + ")");
    if(SLAT != null && SLAT.length <= SLAT_offset)
      throw new RuntimeException("array offset argument \"SLAT_offset\" (" + SLAT_offset + ") equals or exceeds array length (" + SLAT.length + ")");
    if(TYMINC != null && TYMINC.length <= TYMINC_offset)
      throw new RuntimeException("array offset argument \"TYMINC_offset\" (" + TYMINC_offset + ") equals or exceeds array length (" + TYMINC.length + ")");
    if(TSTART != null && TSTART.length <= TSTART_offset)
      throw new RuntimeException("array offset argument \"TSTART_offset\" (" + TSTART_offset + ") equals or exceeds array length (" + TSTART.length + ")");
    if(TSTOP != null && TSTOP.length <= TSTOP_offset)
      throw new RuntimeException("array offset argument \"TSTOP_offset\" (" + TSTOP_offset + ") equals or exceeds array length (" + TSTOP.length + ")");
    if(TSRAD != null && TSRAD.length <= TSRAD_offset)
      throw new RuntimeException("array offset argument \"TSRAD_offset\" (" + TSRAD_offset + ") equals or exceeds array length (" + TSRAD.length + ")");
        solax1(JULDAY, BufferFactory.SIZEOF_INT * JULDAY_offset, MONTH, BufferFactory.SIZEOF_INT * MONTH_offset, SLAT, BufferFactory.SIZEOF_FLOAT * SLAT_offset, TYMINC, BufferFactory.SIZEOF_INT * TYMINC_offset, TSTART, BufferFactory.SIZEOF_INT * TSTART_offset, TSTOP, BufferFactory.SIZEOF_INT * TSTOP_offset, TSRAD, BufferFactory.SIZEOF_FLOAT * TSRAD_offset);

  }

  /** Interface to C language function: <br> <code> void spechum(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void spechum(java.nio.FloatBuffer p, java.nio.FloatBuffer t, java.nio.FloatBuffer rh, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (rh != null && _direct != BufferFactory.isDirect(rh))
      throw new RuntimeException("Argument \"rh\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        spechum0(p, BufferFactory.getDirectBufferByteOffset(p), t, BufferFactory.getDirectBufferByteOffset(t), rh, BufferFactory.getDirectBufferByteOffset(rh), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      spechum1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(rh), BufferFactory.getIndirectBufferByteOffset(rh), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void spechum(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void spechum0(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void spechum(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void spechum1(Object p, int p_byte_offset, Object t, int t_byte_offset, Object rh, int rh_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void spechum(float *  p, float *  t, float *  rh, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void spechum(float[] p, int p_offset, float[] t, int t_offset, float[] rh, int rh_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(rh != null && rh.length <= rh_offset)
      throw new RuntimeException("array offset argument \"rh_offset\" (" + rh_offset + ") equals or exceeds array length (" + rh.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        spechum1(p, BufferFactory.SIZEOF_FLOAT * p_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, rh, BufferFactory.SIZEOF_FLOAT * rh_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void spechum2(float *  p, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void spechum2(java.nio.FloatBuffer p, java.nio.FloatBuffer td, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        spechum20(p, BufferFactory.getDirectBufferByteOffset(p), td, BufferFactory.getDirectBufferByteOffset(td), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      spechum21(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void spechum2(float *  p, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void spechum20(Object p, int p_byte_offset, Object td, int td_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void spechum2(float *  p, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void spechum21(Object p, int p_byte_offset, Object td, int td_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void spechum2(float *  p, float *  td, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void spechum2(float[] p, int p_offset, float[] td, int td_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        spechum21(p, BufferFactory.SIZEOF_FLOAT * p_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void strmpak(const float *  U, const float *  V, int *  work, const int *  mnx, const int *  nx, const int *  ny, const float *  asize, const float *  xpoints, const float *  ypoints, const int *  npoints, const float *  minspc, const float *  maxspc, const float *  badlo, const float *  badhi); </code>    */
  public static void strmpak(java.nio.FloatBuffer U, java.nio.FloatBuffer V, java.nio.IntBuffer work, java.nio.IntBuffer mnx, java.nio.IntBuffer nx, java.nio.IntBuffer ny, java.nio.FloatBuffer asize, java.nio.FloatBuffer xpoints, java.nio.FloatBuffer ypoints, java.nio.IntBuffer npoints, java.nio.FloatBuffer minspc, java.nio.FloatBuffer maxspc, java.nio.FloatBuffer badlo, java.nio.FloatBuffer badhi)
  {
    boolean _direct = BufferFactory.isDirect(U);
    if (V != null && _direct != BufferFactory.isDirect(V))
      throw new RuntimeException("Argument \"V\" : Buffers passed to this method must all be either direct or indirect");
    if (work != null && _direct != BufferFactory.isDirect(work))
      throw new RuntimeException("Argument \"work\" : Buffers passed to this method must all be either direct or indirect");
    if (mnx != null && _direct != BufferFactory.isDirect(mnx))
      throw new RuntimeException("Argument \"mnx\" : Buffers passed to this method must all be either direct or indirect");
    if (nx != null && _direct != BufferFactory.isDirect(nx))
      throw new RuntimeException("Argument \"nx\" : Buffers passed to this method must all be either direct or indirect");
    if (ny != null && _direct != BufferFactory.isDirect(ny))
      throw new RuntimeException("Argument \"ny\" : Buffers passed to this method must all be either direct or indirect");
    if (asize != null && _direct != BufferFactory.isDirect(asize))
      throw new RuntimeException("Argument \"asize\" : Buffers passed to this method must all be either direct or indirect");
    if (xpoints != null && _direct != BufferFactory.isDirect(xpoints))
      throw new RuntimeException("Argument \"xpoints\" : Buffers passed to this method must all be either direct or indirect");
    if (ypoints != null && _direct != BufferFactory.isDirect(ypoints))
      throw new RuntimeException("Argument \"ypoints\" : Buffers passed to this method must all be either direct or indirect");
    if (npoints != null && _direct != BufferFactory.isDirect(npoints))
      throw new RuntimeException("Argument \"npoints\" : Buffers passed to this method must all be either direct or indirect");
    if (minspc != null && _direct != BufferFactory.isDirect(minspc))
      throw new RuntimeException("Argument \"minspc\" : Buffers passed to this method must all be either direct or indirect");
    if (maxspc != null && _direct != BufferFactory.isDirect(maxspc))
      throw new RuntimeException("Argument \"maxspc\" : Buffers passed to this method must all be either direct or indirect");
    if (badlo != null && _direct != BufferFactory.isDirect(badlo))
      throw new RuntimeException("Argument \"badlo\" : Buffers passed to this method must all be either direct or indirect");
    if (badhi != null && _direct != BufferFactory.isDirect(badhi))
      throw new RuntimeException("Argument \"badhi\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        strmpak0(U, BufferFactory.getDirectBufferByteOffset(U), V, BufferFactory.getDirectBufferByteOffset(V), work, BufferFactory.getDirectBufferByteOffset(work), mnx, BufferFactory.getDirectBufferByteOffset(mnx), nx, BufferFactory.getDirectBufferByteOffset(nx), ny, BufferFactory.getDirectBufferByteOffset(ny), asize, BufferFactory.getDirectBufferByteOffset(asize), xpoints, BufferFactory.getDirectBufferByteOffset(xpoints), ypoints, BufferFactory.getDirectBufferByteOffset(ypoints), npoints, BufferFactory.getDirectBufferByteOffset(npoints), minspc, BufferFactory.getDirectBufferByteOffset(minspc), maxspc, BufferFactory.getDirectBufferByteOffset(maxspc), badlo, BufferFactory.getDirectBufferByteOffset(badlo), badhi, BufferFactory.getDirectBufferByteOffset(badhi));
    } else {
      strmpak1(BufferFactory.getArray(U), BufferFactory.getIndirectBufferByteOffset(U), BufferFactory.getArray(V), BufferFactory.getIndirectBufferByteOffset(V), BufferFactory.getArray(work), BufferFactory.getIndirectBufferByteOffset(work), BufferFactory.getArray(mnx), BufferFactory.getIndirectBufferByteOffset(mnx), BufferFactory.getArray(nx), BufferFactory.getIndirectBufferByteOffset(nx), BufferFactory.getArray(ny), BufferFactory.getIndirectBufferByteOffset(ny), BufferFactory.getArray(asize), BufferFactory.getIndirectBufferByteOffset(asize), BufferFactory.getArray(xpoints), BufferFactory.getIndirectBufferByteOffset(xpoints), BufferFactory.getArray(ypoints), BufferFactory.getIndirectBufferByteOffset(ypoints), BufferFactory.getArray(npoints), BufferFactory.getIndirectBufferByteOffset(npoints), BufferFactory.getArray(minspc), BufferFactory.getIndirectBufferByteOffset(minspc), BufferFactory.getArray(maxspc), BufferFactory.getIndirectBufferByteOffset(maxspc), BufferFactory.getArray(badlo), BufferFactory.getIndirectBufferByteOffset(badlo), BufferFactory.getArray(badhi), BufferFactory.getIndirectBufferByteOffset(badhi));
    }
  }

  /** Entry point to C language function: <br> <code> void strmpak(const float *  U, const float *  V, int *  work, const int *  mnx, const int *  nx, const int *  ny, const float *  asize, const float *  xpoints, const float *  ypoints, const int *  npoints, const float *  minspc, const float *  maxspc, const float *  badlo, const float *  badhi); </code>    */
  private static native void strmpak0(Object U, int U_byte_offset, Object V, int V_byte_offset, Object work, int work_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object asize, int asize_byte_offset, Object xpoints, int xpoints_byte_offset, Object ypoints, int ypoints_byte_offset, Object npoints, int npoints_byte_offset, Object minspc, int minspc_byte_offset, Object maxspc, int maxspc_byte_offset, Object badlo, int badlo_byte_offset, Object badhi, int badhi_byte_offset);

  /** Entry point to C language function: <br> <code> void strmpak(const float *  U, const float *  V, int *  work, const int *  mnx, const int *  nx, const int *  ny, const float *  asize, const float *  xpoints, const float *  ypoints, const int *  npoints, const float *  minspc, const float *  maxspc, const float *  badlo, const float *  badhi); </code>    */
  private static native void strmpak1(Object U, int U_byte_offset, Object V, int V_byte_offset, Object work, int work_byte_offset, Object mnx, int mnx_byte_offset, Object nx, int nx_byte_offset, Object ny, int ny_byte_offset, Object asize, int asize_byte_offset, Object xpoints, int xpoints_byte_offset, Object ypoints, int ypoints_byte_offset, Object npoints, int npoints_byte_offset, Object minspc, int minspc_byte_offset, Object maxspc, int maxspc_byte_offset, Object badlo, int badlo_byte_offset, Object badhi, int badhi_byte_offset);

  /** Interface to C language function: <br> <code> void strmpak(const float *  U, const float *  V, int *  work, const int *  mnx, const int *  nx, const int *  ny, const float *  asize, const float *  xpoints, const float *  ypoints, const int *  npoints, const float *  minspc, const float *  maxspc, const float *  badlo, const float *  badhi); </code>    */
  public static void strmpak(float[] U, int U_offset, float[] V, int V_offset, int[] work, int work_offset, int[] mnx, int mnx_offset, int[] nx, int nx_offset, int[] ny, int ny_offset, float[] asize, int asize_offset, float[] xpoints, int xpoints_offset, float[] ypoints, int ypoints_offset, int[] npoints, int npoints_offset, float[] minspc, int minspc_offset, float[] maxspc, int maxspc_offset, float[] badlo, int badlo_offset, float[] badhi, int badhi_offset)
  {
    if(U != null && U.length <= U_offset)
      throw new RuntimeException("array offset argument \"U_offset\" (" + U_offset + ") equals or exceeds array length (" + U.length + ")");
    if(V != null && V.length <= V_offset)
      throw new RuntimeException("array offset argument \"V_offset\" (" + V_offset + ") equals or exceeds array length (" + V.length + ")");
    if(work != null && work.length <= work_offset)
      throw new RuntimeException("array offset argument \"work_offset\" (" + work_offset + ") equals or exceeds array length (" + work.length + ")");
    if(mnx != null && mnx.length <= mnx_offset)
      throw new RuntimeException("array offset argument \"mnx_offset\" (" + mnx_offset + ") equals or exceeds array length (" + mnx.length + ")");
    if(nx != null && nx.length <= nx_offset)
      throw new RuntimeException("array offset argument \"nx_offset\" (" + nx_offset + ") equals or exceeds array length (" + nx.length + ")");
    if(ny != null && ny.length <= ny_offset)
      throw new RuntimeException("array offset argument \"ny_offset\" (" + ny_offset + ") equals or exceeds array length (" + ny.length + ")");
    if(asize != null && asize.length <= asize_offset)
      throw new RuntimeException("array offset argument \"asize_offset\" (" + asize_offset + ") equals or exceeds array length (" + asize.length + ")");
    if(xpoints != null && xpoints.length <= xpoints_offset)
      throw new RuntimeException("array offset argument \"xpoints_offset\" (" + xpoints_offset + ") equals or exceeds array length (" + xpoints.length + ")");
    if(ypoints != null && ypoints.length <= ypoints_offset)
      throw new RuntimeException("array offset argument \"ypoints_offset\" (" + ypoints_offset + ") equals or exceeds array length (" + ypoints.length + ")");
    if(npoints != null && npoints.length <= npoints_offset)
      throw new RuntimeException("array offset argument \"npoints_offset\" (" + npoints_offset + ") equals or exceeds array length (" + npoints.length + ")");
    if(minspc != null && minspc.length <= minspc_offset)
      throw new RuntimeException("array offset argument \"minspc_offset\" (" + minspc_offset + ") equals or exceeds array length (" + minspc.length + ")");
    if(maxspc != null && maxspc.length <= maxspc_offset)
      throw new RuntimeException("array offset argument \"maxspc_offset\" (" + maxspc_offset + ") equals or exceeds array length (" + maxspc.length + ")");
    if(badlo != null && badlo.length <= badlo_offset)
      throw new RuntimeException("array offset argument \"badlo_offset\" (" + badlo_offset + ") equals or exceeds array length (" + badlo.length + ")");
    if(badhi != null && badhi.length <= badhi_offset)
      throw new RuntimeException("array offset argument \"badhi_offset\" (" + badhi_offset + ") equals or exceeds array length (" + badhi.length + ")");
        strmpak1(U, BufferFactory.SIZEOF_FLOAT * U_offset, V, BufferFactory.SIZEOF_FLOAT * V_offset, work, BufferFactory.SIZEOF_INT * work_offset, mnx, BufferFactory.SIZEOF_INT * mnx_offset, nx, BufferFactory.SIZEOF_INT * nx_offset, ny, BufferFactory.SIZEOF_INT * ny_offset, asize, BufferFactory.SIZEOF_FLOAT * asize_offset, xpoints, BufferFactory.SIZEOF_FLOAT * xpoints_offset, ypoints, BufferFactory.SIZEOF_FLOAT * ypoints_offset, npoints, BufferFactory.SIZEOF_INT * npoints_offset, minspc, BufferFactory.SIZEOF_FLOAT * minspc_offset, maxspc, BufferFactory.SIZEOF_FLOAT * maxspc_offset, badlo, BufferFactory.SIZEOF_FLOAT * badlo_offset, badhi, BufferFactory.SIZEOF_FLOAT * badhi_offset);

  }

  /** Interface to C language function: <br> <code> void strmsmth(float *  smoothness, int *  npass); </code>    */
  public static void strmsmth(java.nio.FloatBuffer smoothness, java.nio.IntBuffer npass)
  {
    boolean _direct = BufferFactory.isDirect(smoothness);
    if (npass != null && _direct != BufferFactory.isDirect(npass))
      throw new RuntimeException("Argument \"npass\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        strmsmth0(smoothness, BufferFactory.getDirectBufferByteOffset(smoothness), npass, BufferFactory.getDirectBufferByteOffset(npass));
    } else {
      strmsmth1(BufferFactory.getArray(smoothness), BufferFactory.getIndirectBufferByteOffset(smoothness), BufferFactory.getArray(npass), BufferFactory.getIndirectBufferByteOffset(npass));
    }
  }

  /** Entry point to C language function: <br> <code> void strmsmth(float *  smoothness, int *  npass); </code>    */
  private static native void strmsmth0(Object smoothness, int smoothness_byte_offset, Object npass, int npass_byte_offset);

  /** Entry point to C language function: <br> <code> void strmsmth(float *  smoothness, int *  npass); </code>    */
  private static native void strmsmth1(Object smoothness, int smoothness_byte_offset, Object npass, int npass_byte_offset);

  /** Interface to C language function: <br> <code> void strmsmth(float *  smoothness, int *  npass); </code>    */
  public static void strmsmth(float[] smoothness, int smoothness_offset, int[] npass, int npass_offset)
  {
    if(smoothness != null && smoothness.length <= smoothness_offset)
      throw new RuntimeException("array offset argument \"smoothness_offset\" (" + smoothness_offset + ") equals or exceeds array length (" + smoothness.length + ")");
    if(npass != null && npass.length <= npass_offset)
      throw new RuntimeException("array offset argument \"npass_offset\" (" + npass_offset + ") equals or exceeds array length (" + npass.length + ")");
        strmsmth1(smoothness, BufferFactory.SIZEOF_FLOAT * smoothness_offset, npass, BufferFactory.SIZEOF_INT * npass_offset);

  }

  /** Interface to C language function: <br> <code> void sub_aray(float *  inp, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void sub_aray(java.nio.FloatBuffer inp, java.nio.FloatBuffer b, java.nio.FloatBuffer result, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(inp);
    if (b != null && _direct != BufferFactory.isDirect(b))
      throw new RuntimeException("Argument \"b\" : Buffers passed to this method must all be either direct or indirect");
    if (result != null && _direct != BufferFactory.isDirect(result))
      throw new RuntimeException("Argument \"result\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        sub_aray0(inp, BufferFactory.getDirectBufferByteOffset(inp), b, BufferFactory.getDirectBufferByteOffset(b), result, BufferFactory.getDirectBufferByteOffset(result), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      sub_aray1(BufferFactory.getArray(inp), BufferFactory.getIndirectBufferByteOffset(inp), BufferFactory.getArray(b), BufferFactory.getIndirectBufferByteOffset(b), BufferFactory.getArray(result), BufferFactory.getIndirectBufferByteOffset(result), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void sub_aray(float *  inp, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void sub_aray0(Object inp, int inp_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void sub_aray(float *  inp, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void sub_aray1(Object inp, int inp_byte_offset, Object b, int b_byte_offset, Object result, int result_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void sub_aray(float *  inp, float *  b, float *  result, int *  mni, int *  ni, int *  nj); </code>    */
  public static void sub_aray(float[] inp, int inp_offset, float[] b, int b_offset, float[] result, int result_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(inp != null && inp.length <= inp_offset)
      throw new RuntimeException("array offset argument \"inp_offset\" (" + inp_offset + ") equals or exceeds array length (" + inp.length + ")");
    if(b != null && b.length <= b_offset)
      throw new RuntimeException("array offset argument \"b_offset\" (" + b_offset + ") equals or exceeds array length (" + b.length + ")");
    if(result != null && result.length <= result_offset)
      throw new RuntimeException("array offset argument \"result_offset\" (" + result_offset + ") equals or exceeds array length (" + result.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        sub_aray1(inp, BufferFactory.SIZEOF_FLOAT * inp_offset, b, BufferFactory.SIZEOF_FLOAT * b_offset, result, BufferFactory.SIZEOF_FLOAT * result_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void sweat(float *  P, float *  T, float *  TD, int *  NLVLS, float *  PW, float *  UW, float *  VW, int *  NW, float *  SWIDX); </code>    */
  public static void sweat(java.nio.FloatBuffer P, java.nio.FloatBuffer T, java.nio.FloatBuffer TD, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer PW, java.nio.FloatBuffer UW, java.nio.FloatBuffer VW, java.nio.IntBuffer NW, java.nio.FloatBuffer SWIDX)
  {
    boolean _direct = BufferFactory.isDirect(P);
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (TD != null && _direct != BufferFactory.isDirect(TD))
      throw new RuntimeException("Argument \"TD\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (PW != null && _direct != BufferFactory.isDirect(PW))
      throw new RuntimeException("Argument \"PW\" : Buffers passed to this method must all be either direct or indirect");
    if (UW != null && _direct != BufferFactory.isDirect(UW))
      throw new RuntimeException("Argument \"UW\" : Buffers passed to this method must all be either direct or indirect");
    if (VW != null && _direct != BufferFactory.isDirect(VW))
      throw new RuntimeException("Argument \"VW\" : Buffers passed to this method must all be either direct or indirect");
    if (NW != null && _direct != BufferFactory.isDirect(NW))
      throw new RuntimeException("Argument \"NW\" : Buffers passed to this method must all be either direct or indirect");
    if (SWIDX != null && _direct != BufferFactory.isDirect(SWIDX))
      throw new RuntimeException("Argument \"SWIDX\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        sweat0(P, BufferFactory.getDirectBufferByteOffset(P), T, BufferFactory.getDirectBufferByteOffset(T), TD, BufferFactory.getDirectBufferByteOffset(TD), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), PW, BufferFactory.getDirectBufferByteOffset(PW), UW, BufferFactory.getDirectBufferByteOffset(UW), VW, BufferFactory.getDirectBufferByteOffset(VW), NW, BufferFactory.getDirectBufferByteOffset(NW), SWIDX, BufferFactory.getDirectBufferByteOffset(SWIDX));
    } else {
      sweat1(BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(TD), BufferFactory.getIndirectBufferByteOffset(TD), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(PW), BufferFactory.getIndirectBufferByteOffset(PW), BufferFactory.getArray(UW), BufferFactory.getIndirectBufferByteOffset(UW), BufferFactory.getArray(VW), BufferFactory.getIndirectBufferByteOffset(VW), BufferFactory.getArray(NW), BufferFactory.getIndirectBufferByteOffset(NW), BufferFactory.getArray(SWIDX), BufferFactory.getIndirectBufferByteOffset(SWIDX));
    }
  }

  /** Entry point to C language function: <br> <code> void sweat(float *  P, float *  T, float *  TD, int *  NLVLS, float *  PW, float *  UW, float *  VW, int *  NW, float *  SWIDX); </code>    */
  private static native void sweat0(Object P, int P_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PW, int PW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object NW, int NW_byte_offset, Object SWIDX, int SWIDX_byte_offset);

  /** Entry point to C language function: <br> <code> void sweat(float *  P, float *  T, float *  TD, int *  NLVLS, float *  PW, float *  UW, float *  VW, int *  NW, float *  SWIDX); </code>    */
  private static native void sweat1(Object P, int P_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PW, int PW_byte_offset, Object UW, int UW_byte_offset, Object VW, int VW_byte_offset, Object NW, int NW_byte_offset, Object SWIDX, int SWIDX_byte_offset);

  /** Interface to C language function: <br> <code> void sweat(float *  P, float *  T, float *  TD, int *  NLVLS, float *  PW, float *  UW, float *  VW, int *  NW, float *  SWIDX); </code>    */
  public static void sweat(float[] P, int P_offset, float[] T, int T_offset, float[] TD, int TD_offset, int[] NLVLS, int NLVLS_offset, float[] PW, int PW_offset, float[] UW, int UW_offset, float[] VW, int VW_offset, int[] NW, int NW_offset, float[] SWIDX, int SWIDX_offset)
  {
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(TD != null && TD.length <= TD_offset)
      throw new RuntimeException("array offset argument \"TD_offset\" (" + TD_offset + ") equals or exceeds array length (" + TD.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(PW != null && PW.length <= PW_offset)
      throw new RuntimeException("array offset argument \"PW_offset\" (" + PW_offset + ") equals or exceeds array length (" + PW.length + ")");
    if(UW != null && UW.length <= UW_offset)
      throw new RuntimeException("array offset argument \"UW_offset\" (" + UW_offset + ") equals or exceeds array length (" + UW.length + ")");
    if(VW != null && VW.length <= VW_offset)
      throw new RuntimeException("array offset argument \"VW_offset\" (" + VW_offset + ") equals or exceeds array length (" + VW.length + ")");
    if(NW != null && NW.length <= NW_offset)
      throw new RuntimeException("array offset argument \"NW_offset\" (" + NW_offset + ") equals or exceeds array length (" + NW.length + ")");
    if(SWIDX != null && SWIDX.length <= SWIDX_offset)
      throw new RuntimeException("array offset argument \"SWIDX_offset\" (" + SWIDX_offset + ") equals or exceeds array length (" + SWIDX.length + ")");
        sweat1(P, BufferFactory.SIZEOF_FLOAT * P_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, TD, BufferFactory.SIZEOF_FLOAT * TD_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, PW, BufferFactory.SIZEOF_FLOAT * PW_offset, UW, BufferFactory.SIZEOF_FLOAT * UW_offset, VW, BufferFactory.SIZEOF_FLOAT * VW_offset, NW, BufferFactory.SIZEOF_INT * NW_offset, SWIDX, BufferFactory.SIZEOF_FLOAT * SWIDX_offset);

  }

  /** Interface to C language function: <br> <code> void sweatidx(float *  tt, float *  td8, float *  u8, float *  v8, float *  u5, float *  v5, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void sweatidx(java.nio.FloatBuffer tt, java.nio.FloatBuffer td8, java.nio.FloatBuffer u8, java.nio.FloatBuffer v8, java.nio.FloatBuffer u5, java.nio.FloatBuffer v5, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer q)
  {
    boolean _direct = BufferFactory.isDirect(tt);
    if (td8 != null && _direct != BufferFactory.isDirect(td8))
      throw new RuntimeException("Argument \"td8\" : Buffers passed to this method must all be either direct or indirect");
    if (u8 != null && _direct != BufferFactory.isDirect(u8))
      throw new RuntimeException("Argument \"u8\" : Buffers passed to this method must all be either direct or indirect");
    if (v8 != null && _direct != BufferFactory.isDirect(v8))
      throw new RuntimeException("Argument \"v8\" : Buffers passed to this method must all be either direct or indirect");
    if (u5 != null && _direct != BufferFactory.isDirect(u5))
      throw new RuntimeException("Argument \"u5\" : Buffers passed to this method must all be either direct or indirect");
    if (v5 != null && _direct != BufferFactory.isDirect(v5))
      throw new RuntimeException("Argument \"v5\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        sweatidx0(tt, BufferFactory.getDirectBufferByteOffset(tt), td8, BufferFactory.getDirectBufferByteOffset(td8), u8, BufferFactory.getDirectBufferByteOffset(u8), v8, BufferFactory.getDirectBufferByteOffset(v8), u5, BufferFactory.getDirectBufferByteOffset(u5), v5, BufferFactory.getDirectBufferByteOffset(v5), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), q, BufferFactory.getDirectBufferByteOffset(q));
    } else {
      sweatidx1(BufferFactory.getArray(tt), BufferFactory.getIndirectBufferByteOffset(tt), BufferFactory.getArray(td8), BufferFactory.getIndirectBufferByteOffset(td8), BufferFactory.getArray(u8), BufferFactory.getIndirectBufferByteOffset(u8), BufferFactory.getArray(v8), BufferFactory.getIndirectBufferByteOffset(v8), BufferFactory.getArray(u5), BufferFactory.getIndirectBufferByteOffset(u5), BufferFactory.getArray(v5), BufferFactory.getIndirectBufferByteOffset(v5), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q));
    }
  }

  /** Entry point to C language function: <br> <code> void sweatidx(float *  tt, float *  td8, float *  u8, float *  v8, float *  u5, float *  v5, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void sweatidx0(Object tt, int tt_byte_offset, Object td8, int td8_byte_offset, Object u8, int u8_byte_offset, Object v8, int v8_byte_offset, Object u5, int u5_byte_offset, Object v5, int v5_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Entry point to C language function: <br> <code> void sweatidx(float *  tt, float *  td8, float *  u8, float *  v8, float *  u5, float *  v5, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  private static native void sweatidx1(Object tt, int tt_byte_offset, Object td8, int td8_byte_offset, Object u8, int u8_byte_offset, Object v8, int v8_byte_offset, Object u5, int u5_byte_offset, Object v5, int v5_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object q, int q_byte_offset);

  /** Interface to C language function: <br> <code> void sweatidx(float *  tt, float *  td8, float *  u8, float *  v8, float *  u5, float *  v5, int *  mni, int *  ni, int *  nj, float *  q); </code>    */
  public static void sweatidx(float[] tt, int tt_offset, float[] td8, int td8_offset, float[] u8, int u8_offset, float[] v8, int v8_offset, float[] u5, int u5_offset, float[] v5, int v5_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] q, int q_offset)
  {
    if(tt != null && tt.length <= tt_offset)
      throw new RuntimeException("array offset argument \"tt_offset\" (" + tt_offset + ") equals or exceeds array length (" + tt.length + ")");
    if(td8 != null && td8.length <= td8_offset)
      throw new RuntimeException("array offset argument \"td8_offset\" (" + td8_offset + ") equals or exceeds array length (" + td8.length + ")");
    if(u8 != null && u8.length <= u8_offset)
      throw new RuntimeException("array offset argument \"u8_offset\" (" + u8_offset + ") equals or exceeds array length (" + u8.length + ")");
    if(v8 != null && v8.length <= v8_offset)
      throw new RuntimeException("array offset argument \"v8_offset\" (" + v8_offset + ") equals or exceeds array length (" + v8.length + ")");
    if(u5 != null && u5.length <= u5_offset)
      throw new RuntimeException("array offset argument \"u5_offset\" (" + u5_offset + ") equals or exceeds array length (" + u5.length + ")");
    if(v5 != null && v5.length <= v5_offset)
      throw new RuntimeException("array offset argument \"v5_offset\" (" + v5_offset + ") equals or exceeds array length (" + v5.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
        sweatidx1(tt, BufferFactory.SIZEOF_FLOAT * tt_offset, td8, BufferFactory.SIZEOF_FLOAT * td8_offset, u8, BufferFactory.SIZEOF_FLOAT * u8_offset, v8, BufferFactory.SIZEOF_FLOAT * v8_offset, u5, BufferFactory.SIZEOF_FLOAT * u5_offset, v5, BufferFactory.SIZEOF_FLOAT * v5_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset);

  }

  /** Interface to C language function: <br> <code> void temp2theta(float *  p, int *  aflgp, float *  t, int *  aflgt, float *  theta, int *  mni, int *  ni, int *  nj); </code>    */
  public static void temp2theta(java.nio.FloatBuffer p, java.nio.IntBuffer aflgp, java.nio.FloatBuffer t, java.nio.IntBuffer aflgt, java.nio.FloatBuffer theta, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (aflgp != null && _direct != BufferFactory.isDirect(aflgp))
      throw new RuntimeException("Argument \"aflgp\" : Buffers passed to this method must all be either direct or indirect");
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (aflgt != null && _direct != BufferFactory.isDirect(aflgt))
      throw new RuntimeException("Argument \"aflgt\" : Buffers passed to this method must all be either direct or indirect");
    if (theta != null && _direct != BufferFactory.isDirect(theta))
      throw new RuntimeException("Argument \"theta\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        temp2theta0(p, BufferFactory.getDirectBufferByteOffset(p), aflgp, BufferFactory.getDirectBufferByteOffset(aflgp), t, BufferFactory.getDirectBufferByteOffset(t), aflgt, BufferFactory.getDirectBufferByteOffset(aflgt), theta, BufferFactory.getDirectBufferByteOffset(theta), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      temp2theta1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(aflgp), BufferFactory.getIndirectBufferByteOffset(aflgp), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(aflgt), BufferFactory.getIndirectBufferByteOffset(aflgt), BufferFactory.getArray(theta), BufferFactory.getIndirectBufferByteOffset(theta), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void temp2theta(float *  p, int *  aflgp, float *  t, int *  aflgt, float *  theta, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void temp2theta0(Object p, int p_byte_offset, Object aflgp, int aflgp_byte_offset, Object t, int t_byte_offset, Object aflgt, int aflgt_byte_offset, Object theta, int theta_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void temp2theta(float *  p, int *  aflgp, float *  t, int *  aflgt, float *  theta, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void temp2theta1(Object p, int p_byte_offset, Object aflgp, int aflgp_byte_offset, Object t, int t_byte_offset, Object aflgt, int aflgt_byte_offset, Object theta, int theta_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void temp2theta(float *  p, int *  aflgp, float *  t, int *  aflgt, float *  theta, int *  mni, int *  ni, int *  nj); </code>    */
  public static void temp2theta(float[] p, int p_offset, int[] aflgp, int aflgp_offset, float[] t, int t_offset, int[] aflgt, int aflgt_offset, float[] theta, int theta_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(aflgp != null && aflgp.length <= aflgp_offset)
      throw new RuntimeException("array offset argument \"aflgp_offset\" (" + aflgp_offset + ") equals or exceeds array length (" + aflgp.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(aflgt != null && aflgt.length <= aflgt_offset)
      throw new RuntimeException("array offset argument \"aflgt_offset\" (" + aflgt_offset + ") equals or exceeds array length (" + aflgt.length + ")");
    if(theta != null && theta.length <= theta_offset)
      throw new RuntimeException("array offset argument \"theta_offset\" (" + theta_offset + ") equals or exceeds array length (" + theta.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        temp2theta1(p, BufferFactory.SIZEOF_FLOAT * p_offset, aflgp, BufferFactory.SIZEOF_INT * aflgp_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, aflgt, BufferFactory.SIZEOF_INT * aflgt_offset, theta, BufferFactory.SIZEOF_FLOAT * theta_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void temp_mixratio(float *  press, float *  mixratio, float *  tempmr); </code>    */
  public static void temp_mixratio(java.nio.FloatBuffer press, java.nio.FloatBuffer mixratio, java.nio.FloatBuffer tempmr)
  {
    boolean _direct = BufferFactory.isDirect(press);
    if (mixratio != null && _direct != BufferFactory.isDirect(mixratio))
      throw new RuntimeException("Argument \"mixratio\" : Buffers passed to this method must all be either direct or indirect");
    if (tempmr != null && _direct != BufferFactory.isDirect(tempmr))
      throw new RuntimeException("Argument \"tempmr\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        temp_mixratio0(press, BufferFactory.getDirectBufferByteOffset(press), mixratio, BufferFactory.getDirectBufferByteOffset(mixratio), tempmr, BufferFactory.getDirectBufferByteOffset(tempmr));
    } else {
      temp_mixratio1(BufferFactory.getArray(press), BufferFactory.getIndirectBufferByteOffset(press), BufferFactory.getArray(mixratio), BufferFactory.getIndirectBufferByteOffset(mixratio), BufferFactory.getArray(tempmr), BufferFactory.getIndirectBufferByteOffset(tempmr));
    }
  }

  /** Entry point to C language function: <br> <code> void temp_mixratio(float *  press, float *  mixratio, float *  tempmr); </code>    */
  private static native void temp_mixratio0(Object press, int press_byte_offset, Object mixratio, int mixratio_byte_offset, Object tempmr, int tempmr_byte_offset);

  /** Entry point to C language function: <br> <code> void temp_mixratio(float *  press, float *  mixratio, float *  tempmr); </code>    */
  private static native void temp_mixratio1(Object press, int press_byte_offset, Object mixratio, int mixratio_byte_offset, Object tempmr, int tempmr_byte_offset);

  /** Interface to C language function: <br> <code> void temp_mixratio(float *  press, float *  mixratio, float *  tempmr); </code>    */
  public static void temp_mixratio(float[] press, int press_offset, float[] mixratio, int mixratio_offset, float[] tempmr, int tempmr_offset)
  {
    if(press != null && press.length <= press_offset)
      throw new RuntimeException("array offset argument \"press_offset\" (" + press_offset + ") equals or exceeds array length (" + press.length + ")");
    if(mixratio != null && mixratio.length <= mixratio_offset)
      throw new RuntimeException("array offset argument \"mixratio_offset\" (" + mixratio_offset + ") equals or exceeds array length (" + mixratio.length + ")");
    if(tempmr != null && tempmr.length <= tempmr_offset)
      throw new RuntimeException("array offset argument \"tempmr_offset\" (" + tempmr_offset + ") equals or exceeds array length (" + tempmr.length + ")");
        temp_mixratio1(press, BufferFactory.SIZEOF_FLOAT * press_offset, mixratio, BufferFactory.SIZEOF_FLOAT * mixratio_offset, tempmr, BufferFactory.SIZEOF_FLOAT * tempmr_offset);

  }

  /** Interface to C language function: <br> <code> float temp_of_te(const float *  te, const float *  press); </code>    */
  public static float temp_of_te(java.nio.FloatBuffer te, java.nio.FloatBuffer press)
  {
    boolean _direct = BufferFactory.isDirect(te);
    if (press != null && _direct != BufferFactory.isDirect(press))
      throw new RuntimeException("Argument \"press\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return temp_of_te0(te, BufferFactory.getDirectBufferByteOffset(te), press, BufferFactory.getDirectBufferByteOffset(press));
    } else {
      return temp_of_te1(BufferFactory.getArray(te), BufferFactory.getIndirectBufferByteOffset(te), BufferFactory.getArray(press), BufferFactory.getIndirectBufferByteOffset(press));
    }
  }

  /** Entry point to C language function: <br> <code> float temp_of_te(const float *  te, const float *  press); </code>    */
  private static native float temp_of_te0(Object te, int te_byte_offset, Object press, int press_byte_offset);

  /** Entry point to C language function: <br> <code> float temp_of_te(const float *  te, const float *  press); </code>    */
  private static native float temp_of_te1(Object te, int te_byte_offset, Object press, int press_byte_offset);

  /** Interface to C language function: <br> <code> float temp_of_te(const float *  te, const float *  press); </code>    */
  public static float temp_of_te(float[] te, int te_offset, float[] press, int press_offset)
  {
    if(te != null && te.length <= te_offset)
      throw new RuntimeException("array offset argument \"te_offset\" (" + te_offset + ") equals or exceeds array length (" + te.length + ")");
    if(press != null && press.length <= press_offset)
      throw new RuntimeException("array offset argument \"press_offset\" (" + press_offset + ") equals or exceeds array length (" + press.length + ")");
        return temp_of_te1(te, BufferFactory.SIZEOF_FLOAT * te_offset, press, BufferFactory.SIZEOF_FLOAT * press_offset);

  }

  /** Interface to C language function: <br> <code> void theta2temp(float *  p, int *  aflgp, float *  theta, int *  aflgth, float *  t, int *  mni, int *  ni, int *  nj); </code>    */
  public static void theta2temp(java.nio.FloatBuffer p, java.nio.IntBuffer aflgp, java.nio.FloatBuffer theta, java.nio.IntBuffer aflgth, java.nio.FloatBuffer t, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(p);
    if (aflgp != null && _direct != BufferFactory.isDirect(aflgp))
      throw new RuntimeException("Argument \"aflgp\" : Buffers passed to this method must all be either direct or indirect");
    if (theta != null && _direct != BufferFactory.isDirect(theta))
      throw new RuntimeException("Argument \"theta\" : Buffers passed to this method must all be either direct or indirect");
    if (aflgth != null && _direct != BufferFactory.isDirect(aflgth))
      throw new RuntimeException("Argument \"aflgth\" : Buffers passed to this method must all be either direct or indirect");
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        theta2temp0(p, BufferFactory.getDirectBufferByteOffset(p), aflgp, BufferFactory.getDirectBufferByteOffset(aflgp), theta, BufferFactory.getDirectBufferByteOffset(theta), aflgth, BufferFactory.getDirectBufferByteOffset(aflgth), t, BufferFactory.getDirectBufferByteOffset(t), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      theta2temp1(BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(aflgp), BufferFactory.getIndirectBufferByteOffset(aflgp), BufferFactory.getArray(theta), BufferFactory.getIndirectBufferByteOffset(theta), BufferFactory.getArray(aflgth), BufferFactory.getIndirectBufferByteOffset(aflgth), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void theta2temp(float *  p, int *  aflgp, float *  theta, int *  aflgth, float *  t, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void theta2temp0(Object p, int p_byte_offset, Object aflgp, int aflgp_byte_offset, Object theta, int theta_byte_offset, Object aflgth, int aflgth_byte_offset, Object t, int t_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void theta2temp(float *  p, int *  aflgp, float *  theta, int *  aflgth, float *  t, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void theta2temp1(Object p, int p_byte_offset, Object aflgp, int aflgp_byte_offset, Object theta, int theta_byte_offset, Object aflgth, int aflgth_byte_offset, Object t, int t_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void theta2temp(float *  p, int *  aflgp, float *  theta, int *  aflgth, float *  t, int *  mni, int *  ni, int *  nj); </code>    */
  public static void theta2temp(float[] p, int p_offset, int[] aflgp, int aflgp_offset, float[] theta, int theta_offset, int[] aflgth, int aflgth_offset, float[] t, int t_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(aflgp != null && aflgp.length <= aflgp_offset)
      throw new RuntimeException("array offset argument \"aflgp_offset\" (" + aflgp_offset + ") equals or exceeds array length (" + aflgp.length + ")");
    if(theta != null && theta.length <= theta_offset)
      throw new RuntimeException("array offset argument \"theta_offset\" (" + theta_offset + ") equals or exceeds array length (" + theta.length + ")");
    if(aflgth != null && aflgth.length <= aflgth_offset)
      throw new RuntimeException("array offset argument \"aflgth_offset\" (" + aflgth_offset + ") equals or exceeds array length (" + aflgth.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        theta2temp1(p, BufferFactory.SIZEOF_FLOAT * p_offset, aflgp, BufferFactory.SIZEOF_INT * aflgp_offset, theta, BufferFactory.SIZEOF_FLOAT * theta_offset, aflgth, BufferFactory.SIZEOF_INT * aflgth_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> float thetawa(float *  temp, float *  dwpt, float *  pres, int *  iw, int *  ier); </code>    */
  public static float thetawa(java.nio.FloatBuffer temp, java.nio.FloatBuffer dwpt, java.nio.FloatBuffer pres, java.nio.IntBuffer iw, java.nio.IntBuffer ier)
  {
    boolean _direct = BufferFactory.isDirect(temp);
    if (dwpt != null && _direct != BufferFactory.isDirect(dwpt))
      throw new RuntimeException("Argument \"dwpt\" : Buffers passed to this method must all be either direct or indirect");
    if (pres != null && _direct != BufferFactory.isDirect(pres))
      throw new RuntimeException("Argument \"pres\" : Buffers passed to this method must all be either direct or indirect");
    if (iw != null && _direct != BufferFactory.isDirect(iw))
      throw new RuntimeException("Argument \"iw\" : Buffers passed to this method must all be either direct or indirect");
    if (ier != null && _direct != BufferFactory.isDirect(ier))
      throw new RuntimeException("Argument \"ier\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return thetawa0(temp, BufferFactory.getDirectBufferByteOffset(temp), dwpt, BufferFactory.getDirectBufferByteOffset(dwpt), pres, BufferFactory.getDirectBufferByteOffset(pres), iw, BufferFactory.getDirectBufferByteOffset(iw), ier, BufferFactory.getDirectBufferByteOffset(ier));
    } else {
      return thetawa1(BufferFactory.getArray(temp), BufferFactory.getIndirectBufferByteOffset(temp), BufferFactory.getArray(dwpt), BufferFactory.getIndirectBufferByteOffset(dwpt), BufferFactory.getArray(pres), BufferFactory.getIndirectBufferByteOffset(pres), BufferFactory.getArray(iw), BufferFactory.getIndirectBufferByteOffset(iw), BufferFactory.getArray(ier), BufferFactory.getIndirectBufferByteOffset(ier));
    }
  }

  /** Entry point to C language function: <br> <code> float thetawa(float *  temp, float *  dwpt, float *  pres, int *  iw, int *  ier); </code>    */
  private static native float thetawa0(Object temp, int temp_byte_offset, Object dwpt, int dwpt_byte_offset, Object pres, int pres_byte_offset, Object iw, int iw_byte_offset, Object ier, int ier_byte_offset);

  /** Entry point to C language function: <br> <code> float thetawa(float *  temp, float *  dwpt, float *  pres, int *  iw, int *  ier); </code>    */
  private static native float thetawa1(Object temp, int temp_byte_offset, Object dwpt, int dwpt_byte_offset, Object pres, int pres_byte_offset, Object iw, int iw_byte_offset, Object ier, int ier_byte_offset);

  /** Interface to C language function: <br> <code> float thetawa(float *  temp, float *  dwpt, float *  pres, int *  iw, int *  ier); </code>    */
  public static float thetawa(float[] temp, int temp_offset, float[] dwpt, int dwpt_offset, float[] pres, int pres_offset, int[] iw, int iw_offset, int[] ier, int ier_offset)
  {
    if(temp != null && temp.length <= temp_offset)
      throw new RuntimeException("array offset argument \"temp_offset\" (" + temp_offset + ") equals or exceeds array length (" + temp.length + ")");
    if(dwpt != null && dwpt.length <= dwpt_offset)
      throw new RuntimeException("array offset argument \"dwpt_offset\" (" + dwpt_offset + ") equals or exceeds array length (" + dwpt.length + ")");
    if(pres != null && pres.length <= pres_offset)
      throw new RuntimeException("array offset argument \"pres_offset\" (" + pres_offset + ") equals or exceeds array length (" + pres.length + ")");
    if(iw != null && iw.length <= iw_offset)
      throw new RuntimeException("array offset argument \"iw_offset\" (" + iw_offset + ") equals or exceeds array length (" + iw.length + ")");
    if(ier != null && ier.length <= ier_offset)
      throw new RuntimeException("array offset argument \"ier_offset\" (" + ier_offset + ") equals or exceeds array length (" + ier.length + ")");
        return thetawa1(temp, BufferFactory.SIZEOF_FLOAT * temp_offset, dwpt, BufferFactory.SIZEOF_FLOAT * dwpt_offset, pres, BufferFactory.SIZEOF_FLOAT * pres_offset, iw, BufferFactory.SIZEOF_INT * iw_offset, ier, BufferFactory.SIZEOF_INT * ier_offset);

  }

  /** Interface to C language function: <br> <code> void totals(float *  P, float *  T, float *  TD, int *  NLVLS, float *  TOTIDX, float *  CRSTOT, float *  VERTOT); </code>    */
  public static void totals(java.nio.FloatBuffer P, java.nio.FloatBuffer T, java.nio.FloatBuffer TD, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer TOTIDX, java.nio.FloatBuffer CRSTOT, java.nio.FloatBuffer VERTOT)
  {
    boolean _direct = BufferFactory.isDirect(P);
    if (T != null && _direct != BufferFactory.isDirect(T))
      throw new RuntimeException("Argument \"T\" : Buffers passed to this method must all be either direct or indirect");
    if (TD != null && _direct != BufferFactory.isDirect(TD))
      throw new RuntimeException("Argument \"TD\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (TOTIDX != null && _direct != BufferFactory.isDirect(TOTIDX))
      throw new RuntimeException("Argument \"TOTIDX\" : Buffers passed to this method must all be either direct or indirect");
    if (CRSTOT != null && _direct != BufferFactory.isDirect(CRSTOT))
      throw new RuntimeException("Argument \"CRSTOT\" : Buffers passed to this method must all be either direct or indirect");
    if (VERTOT != null && _direct != BufferFactory.isDirect(VERTOT))
      throw new RuntimeException("Argument \"VERTOT\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        totals0(P, BufferFactory.getDirectBufferByteOffset(P), T, BufferFactory.getDirectBufferByteOffset(T), TD, BufferFactory.getDirectBufferByteOffset(TD), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), TOTIDX, BufferFactory.getDirectBufferByteOffset(TOTIDX), CRSTOT, BufferFactory.getDirectBufferByteOffset(CRSTOT), VERTOT, BufferFactory.getDirectBufferByteOffset(VERTOT));
    } else {
      totals1(BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(TD), BufferFactory.getIndirectBufferByteOffset(TD), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(TOTIDX), BufferFactory.getIndirectBufferByteOffset(TOTIDX), BufferFactory.getArray(CRSTOT), BufferFactory.getIndirectBufferByteOffset(CRSTOT), BufferFactory.getArray(VERTOT), BufferFactory.getIndirectBufferByteOffset(VERTOT));
    }
  }

  /** Entry point to C language function: <br> <code> void totals(float *  P, float *  T, float *  TD, int *  NLVLS, float *  TOTIDX, float *  CRSTOT, float *  VERTOT); </code>    */
  private static native void totals0(Object P, int P_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object TOTIDX, int TOTIDX_byte_offset, Object CRSTOT, int CRSTOT_byte_offset, Object VERTOT, int VERTOT_byte_offset);

  /** Entry point to C language function: <br> <code> void totals(float *  P, float *  T, float *  TD, int *  NLVLS, float *  TOTIDX, float *  CRSTOT, float *  VERTOT); </code>    */
  private static native void totals1(Object P, int P_byte_offset, Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object TOTIDX, int TOTIDX_byte_offset, Object CRSTOT, int CRSTOT_byte_offset, Object VERTOT, int VERTOT_byte_offset);

  /** Interface to C language function: <br> <code> void totals(float *  P, float *  T, float *  TD, int *  NLVLS, float *  TOTIDX, float *  CRSTOT, float *  VERTOT); </code>    */
  public static void totals(float[] P, int P_offset, float[] T, int T_offset, float[] TD, int TD_offset, int[] NLVLS, int NLVLS_offset, float[] TOTIDX, int TOTIDX_offset, float[] CRSTOT, int CRSTOT_offset, float[] VERTOT, int VERTOT_offset)
  {
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(TD != null && TD.length <= TD_offset)
      throw new RuntimeException("array offset argument \"TD_offset\" (" + TD_offset + ") equals or exceeds array length (" + TD.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(TOTIDX != null && TOTIDX.length <= TOTIDX_offset)
      throw new RuntimeException("array offset argument \"TOTIDX_offset\" (" + TOTIDX_offset + ") equals or exceeds array length (" + TOTIDX.length + ")");
    if(CRSTOT != null && CRSTOT.length <= CRSTOT_offset)
      throw new RuntimeException("array offset argument \"CRSTOT_offset\" (" + CRSTOT_offset + ") equals or exceeds array length (" + CRSTOT.length + ")");
    if(VERTOT != null && VERTOT.length <= VERTOT_offset)
      throw new RuntimeException("array offset argument \"VERTOT_offset\" (" + VERTOT_offset + ") equals or exceeds array length (" + VERTOT.length + ")");
        totals1(P, BufferFactory.SIZEOF_FLOAT * P_offset, T, BufferFactory.SIZEOF_FLOAT * T_offset, TD, BufferFactory.SIZEOF_FLOAT * TD_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, TOTIDX, BufferFactory.SIZEOF_FLOAT * TOTIDX_offset, CRSTOT, BufferFactory.SIZEOF_FLOAT * CRSTOT_offset, VERTOT, BufferFactory.SIZEOF_FLOAT * VERTOT_offset);

  }

  /** Interface to C language function: <br> <code> void tplcl(float *  tk, float *  td, float *  pinit, float *  tl, float *  pl, int *  ier); </code>    */
  public static void tplcl(java.nio.FloatBuffer tk, java.nio.FloatBuffer td, java.nio.FloatBuffer pinit, java.nio.FloatBuffer tl, java.nio.FloatBuffer pl, java.nio.IntBuffer ier)
  {
    boolean _direct = BufferFactory.isDirect(tk);
    if (td != null && _direct != BufferFactory.isDirect(td))
      throw new RuntimeException("Argument \"td\" : Buffers passed to this method must all be either direct or indirect");
    if (pinit != null && _direct != BufferFactory.isDirect(pinit))
      throw new RuntimeException("Argument \"pinit\" : Buffers passed to this method must all be either direct or indirect");
    if (tl != null && _direct != BufferFactory.isDirect(tl))
      throw new RuntimeException("Argument \"tl\" : Buffers passed to this method must all be either direct or indirect");
    if (pl != null && _direct != BufferFactory.isDirect(pl))
      throw new RuntimeException("Argument \"pl\" : Buffers passed to this method must all be either direct or indirect");
    if (ier != null && _direct != BufferFactory.isDirect(ier))
      throw new RuntimeException("Argument \"ier\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        tplcl0(tk, BufferFactory.getDirectBufferByteOffset(tk), td, BufferFactory.getDirectBufferByteOffset(td), pinit, BufferFactory.getDirectBufferByteOffset(pinit), tl, BufferFactory.getDirectBufferByteOffset(tl), pl, BufferFactory.getDirectBufferByteOffset(pl), ier, BufferFactory.getDirectBufferByteOffset(ier));
    } else {
      tplcl1(BufferFactory.getArray(tk), BufferFactory.getIndirectBufferByteOffset(tk), BufferFactory.getArray(td), BufferFactory.getIndirectBufferByteOffset(td), BufferFactory.getArray(pinit), BufferFactory.getIndirectBufferByteOffset(pinit), BufferFactory.getArray(tl), BufferFactory.getIndirectBufferByteOffset(tl), BufferFactory.getArray(pl), BufferFactory.getIndirectBufferByteOffset(pl), BufferFactory.getArray(ier), BufferFactory.getIndirectBufferByteOffset(ier));
    }
  }

  /** Entry point to C language function: <br> <code> void tplcl(float *  tk, float *  td, float *  pinit, float *  tl, float *  pl, int *  ier); </code>    */
  private static native void tplcl0(Object tk, int tk_byte_offset, Object td, int td_byte_offset, Object pinit, int pinit_byte_offset, Object tl, int tl_byte_offset, Object pl, int pl_byte_offset, Object ier, int ier_byte_offset);

  /** Entry point to C language function: <br> <code> void tplcl(float *  tk, float *  td, float *  pinit, float *  tl, float *  pl, int *  ier); </code>    */
  private static native void tplcl1(Object tk, int tk_byte_offset, Object td, int td_byte_offset, Object pinit, int pinit_byte_offset, Object tl, int tl_byte_offset, Object pl, int pl_byte_offset, Object ier, int ier_byte_offset);

  /** Interface to C language function: <br> <code> void tplcl(float *  tk, float *  td, float *  pinit, float *  tl, float *  pl, int *  ier); </code>    */
  public static void tplcl(float[] tk, int tk_offset, float[] td, int td_offset, float[] pinit, int pinit_offset, float[] tl, int tl_offset, float[] pl, int pl_offset, int[] ier, int ier_offset)
  {
    if(tk != null && tk.length <= tk_offset)
      throw new RuntimeException("array offset argument \"tk_offset\" (" + tk_offset + ") equals or exceeds array length (" + tk.length + ")");
    if(td != null && td.length <= td_offset)
      throw new RuntimeException("array offset argument \"td_offset\" (" + td_offset + ") equals or exceeds array length (" + td.length + ")");
    if(pinit != null && pinit.length <= pinit_offset)
      throw new RuntimeException("array offset argument \"pinit_offset\" (" + pinit_offset + ") equals or exceeds array length (" + pinit.length + ")");
    if(tl != null && tl.length <= tl_offset)
      throw new RuntimeException("array offset argument \"tl_offset\" (" + tl_offset + ") equals or exceeds array length (" + tl.length + ")");
    if(pl != null && pl.length <= pl_offset)
      throw new RuntimeException("array offset argument \"pl_offset\" (" + pl_offset + ") equals or exceeds array length (" + pl.length + ")");
    if(ier != null && ier.length <= ier_offset)
      throw new RuntimeException("array offset argument \"ier_offset\" (" + ier_offset + ") equals or exceeds array length (" + ier.length + ")");
        tplcl1(tk, BufferFactory.SIZEOF_FLOAT * tk_offset, td, BufferFactory.SIZEOF_FLOAT * td_offset, pinit, BufferFactory.SIZEOF_FLOAT * pinit_offset, tl, BufferFactory.SIZEOF_FLOAT * tl_offset, pl, BufferFactory.SIZEOF_FLOAT * pl_offset, ier, BufferFactory.SIZEOF_INT * ier_offset);

  }

  /** Interface to C language function: <br> <code> void tpzlcl(float *  tk, float *  tdk, float *  pinit, int *  iw, float *  tl, float *  pl, float *  zl, int *  ier); </code>    */
  public static void tpzlcl(java.nio.FloatBuffer tk, java.nio.FloatBuffer tdk, java.nio.FloatBuffer pinit, java.nio.IntBuffer iw, java.nio.FloatBuffer tl, java.nio.FloatBuffer pl, java.nio.FloatBuffer zl, java.nio.IntBuffer ier)
  {
    boolean _direct = BufferFactory.isDirect(tk);
    if (tdk != null && _direct != BufferFactory.isDirect(tdk))
      throw new RuntimeException("Argument \"tdk\" : Buffers passed to this method must all be either direct or indirect");
    if (pinit != null && _direct != BufferFactory.isDirect(pinit))
      throw new RuntimeException("Argument \"pinit\" : Buffers passed to this method must all be either direct or indirect");
    if (iw != null && _direct != BufferFactory.isDirect(iw))
      throw new RuntimeException("Argument \"iw\" : Buffers passed to this method must all be either direct or indirect");
    if (tl != null && _direct != BufferFactory.isDirect(tl))
      throw new RuntimeException("Argument \"tl\" : Buffers passed to this method must all be either direct or indirect");
    if (pl != null && _direct != BufferFactory.isDirect(pl))
      throw new RuntimeException("Argument \"pl\" : Buffers passed to this method must all be either direct or indirect");
    if (zl != null && _direct != BufferFactory.isDirect(zl))
      throw new RuntimeException("Argument \"zl\" : Buffers passed to this method must all be either direct or indirect");
    if (ier != null && _direct != BufferFactory.isDirect(ier))
      throw new RuntimeException("Argument \"ier\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        tpzlcl0(tk, BufferFactory.getDirectBufferByteOffset(tk), tdk, BufferFactory.getDirectBufferByteOffset(tdk), pinit, BufferFactory.getDirectBufferByteOffset(pinit), iw, BufferFactory.getDirectBufferByteOffset(iw), tl, BufferFactory.getDirectBufferByteOffset(tl), pl, BufferFactory.getDirectBufferByteOffset(pl), zl, BufferFactory.getDirectBufferByteOffset(zl), ier, BufferFactory.getDirectBufferByteOffset(ier));
    } else {
      tpzlcl1(BufferFactory.getArray(tk), BufferFactory.getIndirectBufferByteOffset(tk), BufferFactory.getArray(tdk), BufferFactory.getIndirectBufferByteOffset(tdk), BufferFactory.getArray(pinit), BufferFactory.getIndirectBufferByteOffset(pinit), BufferFactory.getArray(iw), BufferFactory.getIndirectBufferByteOffset(iw), BufferFactory.getArray(tl), BufferFactory.getIndirectBufferByteOffset(tl), BufferFactory.getArray(pl), BufferFactory.getIndirectBufferByteOffset(pl), BufferFactory.getArray(zl), BufferFactory.getIndirectBufferByteOffset(zl), BufferFactory.getArray(ier), BufferFactory.getIndirectBufferByteOffset(ier));
    }
  }

  /** Entry point to C language function: <br> <code> void tpzlcl(float *  tk, float *  tdk, float *  pinit, int *  iw, float *  tl, float *  pl, float *  zl, int *  ier); </code>    */
  private static native void tpzlcl0(Object tk, int tk_byte_offset, Object tdk, int tdk_byte_offset, Object pinit, int pinit_byte_offset, Object iw, int iw_byte_offset, Object tl, int tl_byte_offset, Object pl, int pl_byte_offset, Object zl, int zl_byte_offset, Object ier, int ier_byte_offset);

  /** Entry point to C language function: <br> <code> void tpzlcl(float *  tk, float *  tdk, float *  pinit, int *  iw, float *  tl, float *  pl, float *  zl, int *  ier); </code>    */
  private static native void tpzlcl1(Object tk, int tk_byte_offset, Object tdk, int tdk_byte_offset, Object pinit, int pinit_byte_offset, Object iw, int iw_byte_offset, Object tl, int tl_byte_offset, Object pl, int pl_byte_offset, Object zl, int zl_byte_offset, Object ier, int ier_byte_offset);

  /** Interface to C language function: <br> <code> void tpzlcl(float *  tk, float *  tdk, float *  pinit, int *  iw, float *  tl, float *  pl, float *  zl, int *  ier); </code>    */
  public static void tpzlcl(float[] tk, int tk_offset, float[] tdk, int tdk_offset, float[] pinit, int pinit_offset, int[] iw, int iw_offset, float[] tl, int tl_offset, float[] pl, int pl_offset, float[] zl, int zl_offset, int[] ier, int ier_offset)
  {
    if(tk != null && tk.length <= tk_offset)
      throw new RuntimeException("array offset argument \"tk_offset\" (" + tk_offset + ") equals or exceeds array length (" + tk.length + ")");
    if(tdk != null && tdk.length <= tdk_offset)
      throw new RuntimeException("array offset argument \"tdk_offset\" (" + tdk_offset + ") equals or exceeds array length (" + tdk.length + ")");
    if(pinit != null && pinit.length <= pinit_offset)
      throw new RuntimeException("array offset argument \"pinit_offset\" (" + pinit_offset + ") equals or exceeds array length (" + pinit.length + ")");
    if(iw != null && iw.length <= iw_offset)
      throw new RuntimeException("array offset argument \"iw_offset\" (" + iw_offset + ") equals or exceeds array length (" + iw.length + ")");
    if(tl != null && tl.length <= tl_offset)
      throw new RuntimeException("array offset argument \"tl_offset\" (" + tl_offset + ") equals or exceeds array length (" + tl.length + ")");
    if(pl != null && pl.length <= pl_offset)
      throw new RuntimeException("array offset argument \"pl_offset\" (" + pl_offset + ") equals or exceeds array length (" + pl.length + ")");
    if(zl != null && zl.length <= zl_offset)
      throw new RuntimeException("array offset argument \"zl_offset\" (" + zl_offset + ") equals or exceeds array length (" + zl.length + ")");
    if(ier != null && ier.length <= ier_offset)
      throw new RuntimeException("array offset argument \"ier_offset\" (" + ier_offset + ") equals or exceeds array length (" + ier.length + ")");
        tpzlcl1(tk, BufferFactory.SIZEOF_FLOAT * tk_offset, tdk, BufferFactory.SIZEOF_FLOAT * tdk_offset, pinit, BufferFactory.SIZEOF_FLOAT * pinit_offset, iw, BufferFactory.SIZEOF_INT * iw_offset, tl, BufferFactory.SIZEOF_FLOAT * tl_offset, pl, BufferFactory.SIZEOF_FLOAT * pl_offset, zl, BufferFactory.SIZEOF_FLOAT * zl_offset, ier, BufferFactory.SIZEOF_INT * ier_offset);

  }

  /** Interface to C language function: <br> <code> float tsa(float *  os, float *  pres); </code>    */
  public static float tsa(java.nio.FloatBuffer os, java.nio.FloatBuffer pres)
  {
    boolean _direct = BufferFactory.isDirect(os);
    if (pres != null && _direct != BufferFactory.isDirect(pres))
      throw new RuntimeException("Argument \"pres\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return tsa0(os, BufferFactory.getDirectBufferByteOffset(os), pres, BufferFactory.getDirectBufferByteOffset(pres));
    } else {
      return tsa1(BufferFactory.getArray(os), BufferFactory.getIndirectBufferByteOffset(os), BufferFactory.getArray(pres), BufferFactory.getIndirectBufferByteOffset(pres));
    }
  }

  /** Entry point to C language function: <br> <code> float tsa(float *  os, float *  pres); </code>    */
  private static native float tsa0(Object os, int os_byte_offset, Object pres, int pres_byte_offset);

  /** Entry point to C language function: <br> <code> float tsa(float *  os, float *  pres); </code>    */
  private static native float tsa1(Object os, int os_byte_offset, Object pres, int pres_byte_offset);

  /** Interface to C language function: <br> <code> float tsa(float *  os, float *  pres); </code>    */
  public static float tsa(float[] os, int os_offset, float[] pres, int pres_offset)
  {
    if(os != null && os.length <= os_offset)
      throw new RuntimeException("array offset argument \"os_offset\" (" + os_offset + ") equals or exceeds array length (" + os.length + ")");
    if(pres != null && pres.length <= pres_offset)
      throw new RuntimeException("array offset argument \"pres_offset\" (" + pres_offset + ") equals or exceeds array length (" + pres.length + ")");
        return tsa1(os, BufferFactory.SIZEOF_FLOAT * os_offset, pres, BufferFactory.SIZEOF_FLOAT * pres_offset);

  }

  /** Interface to C language function: <br> <code> void tsoar(float *  elev, float *  p, float *  z, float *  t, float *  theta, int *  nl, float *  Tpmax, float *  PTLXEC, float *  zlnec, float *  tlnec, float *  zlxec, float *  tlxec, float *  soarindx, float *  Trigtemp); </code>    */
  public static void tsoar(java.nio.FloatBuffer elev, java.nio.FloatBuffer p, java.nio.FloatBuffer z, java.nio.FloatBuffer t, java.nio.FloatBuffer theta, java.nio.IntBuffer nl, java.nio.FloatBuffer Tpmax, java.nio.FloatBuffer PTLXEC, java.nio.FloatBuffer zlnec, java.nio.FloatBuffer tlnec, java.nio.FloatBuffer zlxec, java.nio.FloatBuffer tlxec, java.nio.FloatBuffer soarindx, java.nio.FloatBuffer Trigtemp)
  {
    boolean _direct = BufferFactory.isDirect(elev);
    if (p != null && _direct != BufferFactory.isDirect(p))
      throw new RuntimeException("Argument \"p\" : Buffers passed to this method must all be either direct or indirect");
    if (z != null && _direct != BufferFactory.isDirect(z))
      throw new RuntimeException("Argument \"z\" : Buffers passed to this method must all be either direct or indirect");
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (theta != null && _direct != BufferFactory.isDirect(theta))
      throw new RuntimeException("Argument \"theta\" : Buffers passed to this method must all be either direct or indirect");
    if (nl != null && _direct != BufferFactory.isDirect(nl))
      throw new RuntimeException("Argument \"nl\" : Buffers passed to this method must all be either direct or indirect");
    if (Tpmax != null && _direct != BufferFactory.isDirect(Tpmax))
      throw new RuntimeException("Argument \"Tpmax\" : Buffers passed to this method must all be either direct or indirect");
    if (PTLXEC != null && _direct != BufferFactory.isDirect(PTLXEC))
      throw new RuntimeException("Argument \"PTLXEC\" : Buffers passed to this method must all be either direct or indirect");
    if (zlnec != null && _direct != BufferFactory.isDirect(zlnec))
      throw new RuntimeException("Argument \"zlnec\" : Buffers passed to this method must all be either direct or indirect");
    if (tlnec != null && _direct != BufferFactory.isDirect(tlnec))
      throw new RuntimeException("Argument \"tlnec\" : Buffers passed to this method must all be either direct or indirect");
    if (zlxec != null && _direct != BufferFactory.isDirect(zlxec))
      throw new RuntimeException("Argument \"zlxec\" : Buffers passed to this method must all be either direct or indirect");
    if (tlxec != null && _direct != BufferFactory.isDirect(tlxec))
      throw new RuntimeException("Argument \"tlxec\" : Buffers passed to this method must all be either direct or indirect");
    if (soarindx != null && _direct != BufferFactory.isDirect(soarindx))
      throw new RuntimeException("Argument \"soarindx\" : Buffers passed to this method must all be either direct or indirect");
    if (Trigtemp != null && _direct != BufferFactory.isDirect(Trigtemp))
      throw new RuntimeException("Argument \"Trigtemp\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        tsoar0(elev, BufferFactory.getDirectBufferByteOffset(elev), p, BufferFactory.getDirectBufferByteOffset(p), z, BufferFactory.getDirectBufferByteOffset(z), t, BufferFactory.getDirectBufferByteOffset(t), theta, BufferFactory.getDirectBufferByteOffset(theta), nl, BufferFactory.getDirectBufferByteOffset(nl), Tpmax, BufferFactory.getDirectBufferByteOffset(Tpmax), PTLXEC, BufferFactory.getDirectBufferByteOffset(PTLXEC), zlnec, BufferFactory.getDirectBufferByteOffset(zlnec), tlnec, BufferFactory.getDirectBufferByteOffset(tlnec), zlxec, BufferFactory.getDirectBufferByteOffset(zlxec), tlxec, BufferFactory.getDirectBufferByteOffset(tlxec), soarindx, BufferFactory.getDirectBufferByteOffset(soarindx), Trigtemp, BufferFactory.getDirectBufferByteOffset(Trigtemp));
    } else {
      tsoar1(BufferFactory.getArray(elev), BufferFactory.getIndirectBufferByteOffset(elev), BufferFactory.getArray(p), BufferFactory.getIndirectBufferByteOffset(p), BufferFactory.getArray(z), BufferFactory.getIndirectBufferByteOffset(z), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t), BufferFactory.getArray(theta), BufferFactory.getIndirectBufferByteOffset(theta), BufferFactory.getArray(nl), BufferFactory.getIndirectBufferByteOffset(nl), BufferFactory.getArray(Tpmax), BufferFactory.getIndirectBufferByteOffset(Tpmax), BufferFactory.getArray(PTLXEC), BufferFactory.getIndirectBufferByteOffset(PTLXEC), BufferFactory.getArray(zlnec), BufferFactory.getIndirectBufferByteOffset(zlnec), BufferFactory.getArray(tlnec), BufferFactory.getIndirectBufferByteOffset(tlnec), BufferFactory.getArray(zlxec), BufferFactory.getIndirectBufferByteOffset(zlxec), BufferFactory.getArray(tlxec), BufferFactory.getIndirectBufferByteOffset(tlxec), BufferFactory.getArray(soarindx), BufferFactory.getIndirectBufferByteOffset(soarindx), BufferFactory.getArray(Trigtemp), BufferFactory.getIndirectBufferByteOffset(Trigtemp));
    }
  }

  /** Entry point to C language function: <br> <code> void tsoar(float *  elev, float *  p, float *  z, float *  t, float *  theta, int *  nl, float *  Tpmax, float *  PTLXEC, float *  zlnec, float *  tlnec, float *  zlxec, float *  tlxec, float *  soarindx, float *  Trigtemp); </code>    */
  private static native void tsoar0(Object elev, int elev_byte_offset, Object p, int p_byte_offset, Object z, int z_byte_offset, Object t, int t_byte_offset, Object theta, int theta_byte_offset, Object nl, int nl_byte_offset, Object Tpmax, int Tpmax_byte_offset, Object PTLXEC, int PTLXEC_byte_offset, Object zlnec, int zlnec_byte_offset, Object tlnec, int tlnec_byte_offset, Object zlxec, int zlxec_byte_offset, Object tlxec, int tlxec_byte_offset, Object soarindx, int soarindx_byte_offset, Object Trigtemp, int Trigtemp_byte_offset);

  /** Entry point to C language function: <br> <code> void tsoar(float *  elev, float *  p, float *  z, float *  t, float *  theta, int *  nl, float *  Tpmax, float *  PTLXEC, float *  zlnec, float *  tlnec, float *  zlxec, float *  tlxec, float *  soarindx, float *  Trigtemp); </code>    */
  private static native void tsoar1(Object elev, int elev_byte_offset, Object p, int p_byte_offset, Object z, int z_byte_offset, Object t, int t_byte_offset, Object theta, int theta_byte_offset, Object nl, int nl_byte_offset, Object Tpmax, int Tpmax_byte_offset, Object PTLXEC, int PTLXEC_byte_offset, Object zlnec, int zlnec_byte_offset, Object tlnec, int tlnec_byte_offset, Object zlxec, int zlxec_byte_offset, Object tlxec, int tlxec_byte_offset, Object soarindx, int soarindx_byte_offset, Object Trigtemp, int Trigtemp_byte_offset);

  /** Interface to C language function: <br> <code> void tsoar(float *  elev, float *  p, float *  z, float *  t, float *  theta, int *  nl, float *  Tpmax, float *  PTLXEC, float *  zlnec, float *  tlnec, float *  zlxec, float *  tlxec, float *  soarindx, float *  Trigtemp); </code>    */
  public static void tsoar(float[] elev, int elev_offset, float[] p, int p_offset, float[] z, int z_offset, float[] t, int t_offset, float[] theta, int theta_offset, int[] nl, int nl_offset, float[] Tpmax, int Tpmax_offset, float[] PTLXEC, int PTLXEC_offset, float[] zlnec, int zlnec_offset, float[] tlnec, int tlnec_offset, float[] zlxec, int zlxec_offset, float[] tlxec, int tlxec_offset, float[] soarindx, int soarindx_offset, float[] Trigtemp, int Trigtemp_offset)
  {
    if(elev != null && elev.length <= elev_offset)
      throw new RuntimeException("array offset argument \"elev_offset\" (" + elev_offset + ") equals or exceeds array length (" + elev.length + ")");
    if(p != null && p.length <= p_offset)
      throw new RuntimeException("array offset argument \"p_offset\" (" + p_offset + ") equals or exceeds array length (" + p.length + ")");
    if(z != null && z.length <= z_offset)
      throw new RuntimeException("array offset argument \"z_offset\" (" + z_offset + ") equals or exceeds array length (" + z.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
    if(theta != null && theta.length <= theta_offset)
      throw new RuntimeException("array offset argument \"theta_offset\" (" + theta_offset + ") equals or exceeds array length (" + theta.length + ")");
    if(nl != null && nl.length <= nl_offset)
      throw new RuntimeException("array offset argument \"nl_offset\" (" + nl_offset + ") equals or exceeds array length (" + nl.length + ")");
    if(Tpmax != null && Tpmax.length <= Tpmax_offset)
      throw new RuntimeException("array offset argument \"Tpmax_offset\" (" + Tpmax_offset + ") equals or exceeds array length (" + Tpmax.length + ")");
    if(PTLXEC != null && PTLXEC.length <= PTLXEC_offset)
      throw new RuntimeException("array offset argument \"PTLXEC_offset\" (" + PTLXEC_offset + ") equals or exceeds array length (" + PTLXEC.length + ")");
    if(zlnec != null && zlnec.length <= zlnec_offset)
      throw new RuntimeException("array offset argument \"zlnec_offset\" (" + zlnec_offset + ") equals or exceeds array length (" + zlnec.length + ")");
    if(tlnec != null && tlnec.length <= tlnec_offset)
      throw new RuntimeException("array offset argument \"tlnec_offset\" (" + tlnec_offset + ") equals or exceeds array length (" + tlnec.length + ")");
    if(zlxec != null && zlxec.length <= zlxec_offset)
      throw new RuntimeException("array offset argument \"zlxec_offset\" (" + zlxec_offset + ") equals or exceeds array length (" + zlxec.length + ")");
    if(tlxec != null && tlxec.length <= tlxec_offset)
      throw new RuntimeException("array offset argument \"tlxec_offset\" (" + tlxec_offset + ") equals or exceeds array length (" + tlxec.length + ")");
    if(soarindx != null && soarindx.length <= soarindx_offset)
      throw new RuntimeException("array offset argument \"soarindx_offset\" (" + soarindx_offset + ") equals or exceeds array length (" + soarindx.length + ")");
    if(Trigtemp != null && Trigtemp.length <= Trigtemp_offset)
      throw new RuntimeException("array offset argument \"Trigtemp_offset\" (" + Trigtemp_offset + ") equals or exceeds array length (" + Trigtemp.length + ")");
        tsoar1(elev, BufferFactory.SIZEOF_FLOAT * elev_offset, p, BufferFactory.SIZEOF_FLOAT * p_offset, z, BufferFactory.SIZEOF_FLOAT * z_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset, theta, BufferFactory.SIZEOF_FLOAT * theta_offset, nl, BufferFactory.SIZEOF_INT * nl_offset, Tpmax, BufferFactory.SIZEOF_FLOAT * Tpmax_offset, PTLXEC, BufferFactory.SIZEOF_FLOAT * PTLXEC_offset, zlnec, BufferFactory.SIZEOF_FLOAT * zlnec_offset, tlnec, BufferFactory.SIZEOF_FLOAT * tlnec_offset, zlxec, BufferFactory.SIZEOF_FLOAT * zlxec_offset, tlxec, BufferFactory.SIZEOF_FLOAT * tlxec_offset, soarindx, BufferFactory.SIZEOF_FLOAT * soarindx_offset, Trigtemp, BufferFactory.SIZEOF_FLOAT * Trigtemp_offset);

  }

  /** Interface to C language function: <br> <code> void tv2temp(float *  tv, float *  q, int *  mni, int *  ni, int *  nj, float *  t); </code>    */
  public static void tv2temp(java.nio.FloatBuffer tv, java.nio.FloatBuffer q, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj, java.nio.FloatBuffer t)
  {
    boolean _direct = BufferFactory.isDirect(tv);
    if (q != null && _direct != BufferFactory.isDirect(q))
      throw new RuntimeException("Argument \"q\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (t != null && _direct != BufferFactory.isDirect(t))
      throw new RuntimeException("Argument \"t\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        tv2temp0(tv, BufferFactory.getDirectBufferByteOffset(tv), q, BufferFactory.getDirectBufferByteOffset(q), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj), t, BufferFactory.getDirectBufferByteOffset(t));
    } else {
      tv2temp1(BufferFactory.getArray(tv), BufferFactory.getIndirectBufferByteOffset(tv), BufferFactory.getArray(q), BufferFactory.getIndirectBufferByteOffset(q), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj), BufferFactory.getArray(t), BufferFactory.getIndirectBufferByteOffset(t));
    }
  }

  /** Entry point to C language function: <br> <code> void tv2temp(float *  tv, float *  q, int *  mni, int *  ni, int *  nj, float *  t); </code>    */
  private static native void tv2temp0(Object tv, int tv_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object t, int t_byte_offset);

  /** Entry point to C language function: <br> <code> void tv2temp(float *  tv, float *  q, int *  mni, int *  ni, int *  nj, float *  t); </code>    */
  private static native void tv2temp1(Object tv, int tv_byte_offset, Object q, int q_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset, Object t, int t_byte_offset);

  /** Interface to C language function: <br> <code> void tv2temp(float *  tv, float *  q, int *  mni, int *  ni, int *  nj, float *  t); </code>    */
  public static void tv2temp(float[] tv, int tv_offset, float[] q, int q_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset, float[] t, int t_offset)
  {
    if(tv != null && tv.length <= tv_offset)
      throw new RuntimeException("array offset argument \"tv_offset\" (" + tv_offset + ") equals or exceeds array length (" + tv.length + ")");
    if(q != null && q.length <= q_offset)
      throw new RuntimeException("array offset argument \"q_offset\" (" + q_offset + ") equals or exceeds array length (" + q.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
    if(t != null && t.length <= t_offset)
      throw new RuntimeException("array offset argument \"t_offset\" (" + t_offset + ") equals or exceeds array length (" + t.length + ")");
        tv2temp1(tv, BufferFactory.SIZEOF_FLOAT * tv_offset, q, BufferFactory.SIZEOF_FLOAT * q_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset, t, BufferFactory.SIZEOF_FLOAT * t_offset);

  }

  /** Interface to C language function: <br> <code> void uvcomp(float *  DIR, float *  SPD, float *  U, float *  V, int *  NLVLS); </code>    */
  public static void uvcomp(java.nio.FloatBuffer DIR, java.nio.FloatBuffer SPD, java.nio.FloatBuffer U, java.nio.FloatBuffer V, java.nio.IntBuffer NLVLS)
  {
    boolean _direct = BufferFactory.isDirect(DIR);
    if (SPD != null && _direct != BufferFactory.isDirect(SPD))
      throw new RuntimeException("Argument \"SPD\" : Buffers passed to this method must all be either direct or indirect");
    if (U != null && _direct != BufferFactory.isDirect(U))
      throw new RuntimeException("Argument \"U\" : Buffers passed to this method must all be either direct or indirect");
    if (V != null && _direct != BufferFactory.isDirect(V))
      throw new RuntimeException("Argument \"V\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        uvcomp0(DIR, BufferFactory.getDirectBufferByteOffset(DIR), SPD, BufferFactory.getDirectBufferByteOffset(SPD), U, BufferFactory.getDirectBufferByteOffset(U), V, BufferFactory.getDirectBufferByteOffset(V), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS));
    } else {
      uvcomp1(BufferFactory.getArray(DIR), BufferFactory.getIndirectBufferByteOffset(DIR), BufferFactory.getArray(SPD), BufferFactory.getIndirectBufferByteOffset(SPD), BufferFactory.getArray(U), BufferFactory.getIndirectBufferByteOffset(U), BufferFactory.getArray(V), BufferFactory.getIndirectBufferByteOffset(V), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS));
    }
  }

  /** Entry point to C language function: <br> <code> void uvcomp(float *  DIR, float *  SPD, float *  U, float *  V, int *  NLVLS); </code>    */
  private static native void uvcomp0(Object DIR, int DIR_byte_offset, Object SPD, int SPD_byte_offset, Object U, int U_byte_offset, Object V, int V_byte_offset, Object NLVLS, int NLVLS_byte_offset);

  /** Entry point to C language function: <br> <code> void uvcomp(float *  DIR, float *  SPD, float *  U, float *  V, int *  NLVLS); </code>    */
  private static native void uvcomp1(Object DIR, int DIR_byte_offset, Object SPD, int SPD_byte_offset, Object U, int U_byte_offset, Object V, int V_byte_offset, Object NLVLS, int NLVLS_byte_offset);

  /** Interface to C language function: <br> <code> void uvcomp(float *  DIR, float *  SPD, float *  U, float *  V, int *  NLVLS); </code>    */
  public static void uvcomp(float[] DIR, int DIR_offset, float[] SPD, int SPD_offset, float[] U, int U_offset, float[] V, int V_offset, int[] NLVLS, int NLVLS_offset)
  {
    if(DIR != null && DIR.length <= DIR_offset)
      throw new RuntimeException("array offset argument \"DIR_offset\" (" + DIR_offset + ") equals or exceeds array length (" + DIR.length + ")");
    if(SPD != null && SPD.length <= SPD_offset)
      throw new RuntimeException("array offset argument \"SPD_offset\" (" + SPD_offset + ") equals or exceeds array length (" + SPD.length + ")");
    if(U != null && U.length <= U_offset)
      throw new RuntimeException("array offset argument \"U_offset\" (" + U_offset + ") equals or exceeds array length (" + U.length + ")");
    if(V != null && V.length <= V_offset)
      throw new RuntimeException("array offset argument \"V_offset\" (" + V_offset + ") equals or exceeds array length (" + V.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
        uvcomp1(DIR, BufferFactory.SIZEOF_FLOAT * DIR_offset, SPD, BufferFactory.SIZEOF_FLOAT * SPD_offset, U, BufferFactory.SIZEOF_FLOAT * U_offset, V, BufferFactory.SIZEOF_FLOAT * V_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset);

  }

  /** Interface to C language function: <br> <code> void ver_pts(float *  a, float *  count, int *  init, int *  mni, int *  ni, int *  nj); </code>    */
  public static void ver_pts(java.nio.FloatBuffer a, java.nio.FloatBuffer count, java.nio.IntBuffer init, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(a);
    if (count != null && _direct != BufferFactory.isDirect(count))
      throw new RuntimeException("Argument \"count\" : Buffers passed to this method must all be either direct or indirect");
    if (init != null && _direct != BufferFactory.isDirect(init))
      throw new RuntimeException("Argument \"init\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        ver_pts0(a, BufferFactory.getDirectBufferByteOffset(a), count, BufferFactory.getDirectBufferByteOffset(count), init, BufferFactory.getDirectBufferByteOffset(init), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      ver_pts1(BufferFactory.getArray(a), BufferFactory.getIndirectBufferByteOffset(a), BufferFactory.getArray(count), BufferFactory.getIndirectBufferByteOffset(count), BufferFactory.getArray(init), BufferFactory.getIndirectBufferByteOffset(init), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void ver_pts(float *  a, float *  count, int *  init, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void ver_pts0(Object a, int a_byte_offset, Object count, int count_byte_offset, Object init, int init_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void ver_pts(float *  a, float *  count, int *  init, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void ver_pts1(Object a, int a_byte_offset, Object count, int count_byte_offset, Object init, int init_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void ver_pts(float *  a, float *  count, int *  init, int *  mni, int *  ni, int *  nj); </code>    */
  public static void ver_pts(float[] a, int a_offset, float[] count, int count_offset, int[] init, int init_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(a != null && a.length <= a_offset)
      throw new RuntimeException("array offset argument \"a_offset\" (" + a_offset + ") equals or exceeds array length (" + a.length + ")");
    if(count != null && count.length <= count_offset)
      throw new RuntimeException("array offset argument \"count_offset\" (" + count_offset + ") equals or exceeds array length (" + count.length + ")");
    if(init != null && init.length <= init_offset)
      throw new RuntimeException("array offset argument \"init_offset\" (" + init_offset + ") equals or exceeds array length (" + init.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        ver_pts1(a, BufferFactory.SIZEOF_FLOAT * a_offset, count, BufferFactory.SIZEOF_FLOAT * count_offset, init, BufferFactory.SIZEOF_INT * init_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> float virttemp(float *  T, float *  Td, float *  P); </code>    */
  public static float virttemp(java.nio.FloatBuffer T, java.nio.FloatBuffer Td, java.nio.FloatBuffer P)
  {
    boolean _direct = BufferFactory.isDirect(T);
    if (Td != null && _direct != BufferFactory.isDirect(Td))
      throw new RuntimeException("Argument \"Td\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return virttemp0(T, BufferFactory.getDirectBufferByteOffset(T), Td, BufferFactory.getDirectBufferByteOffset(Td), P, BufferFactory.getDirectBufferByteOffset(P));
    } else {
      return virttemp1(BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(Td), BufferFactory.getIndirectBufferByteOffset(Td), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P));
    }
  }

  /** Entry point to C language function: <br> <code> float virttemp(float *  T, float *  Td, float *  P); </code>    */
  private static native float virttemp0(Object T, int T_byte_offset, Object Td, int Td_byte_offset, Object P, int P_byte_offset);

  /** Entry point to C language function: <br> <code> float virttemp(float *  T, float *  Td, float *  P); </code>    */
  private static native float virttemp1(Object T, int T_byte_offset, Object Td, int Td_byte_offset, Object P, int P_byte_offset);

  /** Interface to C language function: <br> <code> float virttemp(float *  T, float *  Td, float *  P); </code>    */
  public static float virttemp(float[] T, int T_offset, float[] Td, int Td_offset, float[] P, int P_offset)
  {
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(Td != null && Td.length <= Td_offset)
      throw new RuntimeException("array offset argument \"Td_offset\" (" + Td_offset + ") equals or exceeds array length (" + Td.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
        return virttemp1(T, BufferFactory.SIZEOF_FLOAT * T_offset, Td, BufferFactory.SIZEOF_FLOAT * Td_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset);

  }

  /** Interface to C language function: <br> <code> void virtualt(float *  T, float *  TD, float *  P, int *  NLVLS, float *  TVIR); </code>    */
  public static void virtualt(java.nio.FloatBuffer T, java.nio.FloatBuffer TD, java.nio.FloatBuffer P, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer TVIR)
  {
    boolean _direct = BufferFactory.isDirect(T);
    if (TD != null && _direct != BufferFactory.isDirect(TD))
      throw new RuntimeException("Argument \"TD\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (TVIR != null && _direct != BufferFactory.isDirect(TVIR))
      throw new RuntimeException("Argument \"TVIR\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        virtualt0(T, BufferFactory.getDirectBufferByteOffset(T), TD, BufferFactory.getDirectBufferByteOffset(TD), P, BufferFactory.getDirectBufferByteOffset(P), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), TVIR, BufferFactory.getDirectBufferByteOffset(TVIR));
    } else {
      virtualt1(BufferFactory.getArray(T), BufferFactory.getIndirectBufferByteOffset(T), BufferFactory.getArray(TD), BufferFactory.getIndirectBufferByteOffset(TD), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(TVIR), BufferFactory.getIndirectBufferByteOffset(TVIR));
    }
  }

  /** Entry point to C language function: <br> <code> void virtualt(float *  T, float *  TD, float *  P, int *  NLVLS, float *  TVIR); </code>    */
  private static native void virtualt0(Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object P, int P_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object TVIR, int TVIR_byte_offset);

  /** Entry point to C language function: <br> <code> void virtualt(float *  T, float *  TD, float *  P, int *  NLVLS, float *  TVIR); </code>    */
  private static native void virtualt1(Object T, int T_byte_offset, Object TD, int TD_byte_offset, Object P, int P_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object TVIR, int TVIR_byte_offset);

  /** Interface to C language function: <br> <code> void virtualt(float *  T, float *  TD, float *  P, int *  NLVLS, float *  TVIR); </code>    */
  public static void virtualt(float[] T, int T_offset, float[] TD, int TD_offset, float[] P, int P_offset, int[] NLVLS, int NLVLS_offset, float[] TVIR, int TVIR_offset)
  {
    if(T != null && T.length <= T_offset)
      throw new RuntimeException("array offset argument \"T_offset\" (" + T_offset + ") equals or exceeds array length (" + T.length + ")");
    if(TD != null && TD.length <= TD_offset)
      throw new RuntimeException("array offset argument \"TD_offset\" (" + TD_offset + ") equals or exceeds array length (" + TD.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(TVIR != null && TVIR.length <= TVIR_offset)
      throw new RuntimeException("array offset argument \"TVIR_offset\" (" + TVIR_offset + ") equals or exceeds array length (" + TVIR.length + ")");
        virtualt1(T, BufferFactory.SIZEOF_FLOAT * T_offset, TD, BufferFactory.SIZEOF_FLOAT * TD_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, TVIR, BufferFactory.SIZEOF_FLOAT * TVIR_offset);

  }

  /** Interface to C language function: <br> <code> float vp(float *  tk, int *  iw); </code>    */
  public static float vp(java.nio.FloatBuffer tk, java.nio.IntBuffer iw)
  {
    boolean _direct = BufferFactory.isDirect(tk);
    if (iw != null && _direct != BufferFactory.isDirect(iw))
      throw new RuntimeException("Argument \"iw\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        return vp0(tk, BufferFactory.getDirectBufferByteOffset(tk), iw, BufferFactory.getDirectBufferByteOffset(iw));
    } else {
      return vp1(BufferFactory.getArray(tk), BufferFactory.getIndirectBufferByteOffset(tk), BufferFactory.getArray(iw), BufferFactory.getIndirectBufferByteOffset(iw));
    }
  }

  /** Entry point to C language function: <br> <code> float vp(float *  tk, int *  iw); </code>    */
  private static native float vp0(Object tk, int tk_byte_offset, Object iw, int iw_byte_offset);

  /** Entry point to C language function: <br> <code> float vp(float *  tk, int *  iw); </code>    */
  private static native float vp1(Object tk, int tk_byte_offset, Object iw, int iw_byte_offset);

  /** Interface to C language function: <br> <code> float vp(float *  tk, int *  iw); </code>    */
  public static float vp(float[] tk, int tk_offset, int[] iw, int iw_offset)
  {
    if(tk != null && tk.length <= tk_offset)
      throw new RuntimeException("array offset argument \"tk_offset\" (" + tk_offset + ") equals or exceeds array length (" + tk.length + ")");
    if(iw != null && iw.length <= iw_offset)
      throw new RuntimeException("array offset argument \"iw_offset\" (" + iw_offset + ") equals or exceeds array length (" + iw.length + ")");
        return vp1(tk, BufferFactory.SIZEOF_FLOAT * tk_offset, iw, BufferFactory.SIZEOF_INT * iw_offset);

  }

  /** Interface to C language function: <br> <code> void vvel(float *  pcb, float *  PEQLEV, float *  P, float *  HT, float *  TP, float *  TVE, float *  TVP, float *  WLCL, int *  NPAR, float *  VV, float *  VVMAX); </code>    */
  public static void vvel(java.nio.FloatBuffer pcb, java.nio.FloatBuffer PEQLEV, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer TP, java.nio.FloatBuffer TVE, java.nio.FloatBuffer TVP, java.nio.FloatBuffer WLCL, java.nio.IntBuffer NPAR, java.nio.FloatBuffer VV, java.nio.FloatBuffer VVMAX)
  {
    boolean _direct = BufferFactory.isDirect(pcb);
    if (PEQLEV != null && _direct != BufferFactory.isDirect(PEQLEV))
      throw new RuntimeException("Argument \"PEQLEV\" : Buffers passed to this method must all be either direct or indirect");
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (TP != null && _direct != BufferFactory.isDirect(TP))
      throw new RuntimeException("Argument \"TP\" : Buffers passed to this method must all be either direct or indirect");
    if (TVE != null && _direct != BufferFactory.isDirect(TVE))
      throw new RuntimeException("Argument \"TVE\" : Buffers passed to this method must all be either direct or indirect");
    if (TVP != null && _direct != BufferFactory.isDirect(TVP))
      throw new RuntimeException("Argument \"TVP\" : Buffers passed to this method must all be either direct or indirect");
    if (WLCL != null && _direct != BufferFactory.isDirect(WLCL))
      throw new RuntimeException("Argument \"WLCL\" : Buffers passed to this method must all be either direct or indirect");
    if (NPAR != null && _direct != BufferFactory.isDirect(NPAR))
      throw new RuntimeException("Argument \"NPAR\" : Buffers passed to this method must all be either direct or indirect");
    if (VV != null && _direct != BufferFactory.isDirect(VV))
      throw new RuntimeException("Argument \"VV\" : Buffers passed to this method must all be either direct or indirect");
    if (VVMAX != null && _direct != BufferFactory.isDirect(VVMAX))
      throw new RuntimeException("Argument \"VVMAX\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        vvel0(pcb, BufferFactory.getDirectBufferByteOffset(pcb), PEQLEV, BufferFactory.getDirectBufferByteOffset(PEQLEV), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), TP, BufferFactory.getDirectBufferByteOffset(TP), TVE, BufferFactory.getDirectBufferByteOffset(TVE), TVP, BufferFactory.getDirectBufferByteOffset(TVP), WLCL, BufferFactory.getDirectBufferByteOffset(WLCL), NPAR, BufferFactory.getDirectBufferByteOffset(NPAR), VV, BufferFactory.getDirectBufferByteOffset(VV), VVMAX, BufferFactory.getDirectBufferByteOffset(VVMAX));
    } else {
      vvel1(BufferFactory.getArray(pcb), BufferFactory.getIndirectBufferByteOffset(pcb), BufferFactory.getArray(PEQLEV), BufferFactory.getIndirectBufferByteOffset(PEQLEV), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(TP), BufferFactory.getIndirectBufferByteOffset(TP), BufferFactory.getArray(TVE), BufferFactory.getIndirectBufferByteOffset(TVE), BufferFactory.getArray(TVP), BufferFactory.getIndirectBufferByteOffset(TVP), BufferFactory.getArray(WLCL), BufferFactory.getIndirectBufferByteOffset(WLCL), BufferFactory.getArray(NPAR), BufferFactory.getIndirectBufferByteOffset(NPAR), BufferFactory.getArray(VV), BufferFactory.getIndirectBufferByteOffset(VV), BufferFactory.getArray(VVMAX), BufferFactory.getIndirectBufferByteOffset(VVMAX));
    }
  }

  /** Entry point to C language function: <br> <code> void vvel(float *  pcb, float *  PEQLEV, float *  P, float *  HT, float *  TP, float *  TVE, float *  TVP, float *  WLCL, int *  NPAR, float *  VV, float *  VVMAX); </code>    */
  private static native void vvel0(Object pcb, int pcb_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TP, int TP_byte_offset, Object TVE, int TVE_byte_offset, Object TVP, int TVP_byte_offset, Object WLCL, int WLCL_byte_offset, Object NPAR, int NPAR_byte_offset, Object VV, int VV_byte_offset, Object VVMAX, int VVMAX_byte_offset);

  /** Entry point to C language function: <br> <code> void vvel(float *  pcb, float *  PEQLEV, float *  P, float *  HT, float *  TP, float *  TVE, float *  TVP, float *  WLCL, int *  NPAR, float *  VV, float *  VVMAX); </code>    */
  private static native void vvel1(Object pcb, int pcb_byte_offset, Object PEQLEV, int PEQLEV_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object TP, int TP_byte_offset, Object TVE, int TVE_byte_offset, Object TVP, int TVP_byte_offset, Object WLCL, int WLCL_byte_offset, Object NPAR, int NPAR_byte_offset, Object VV, int VV_byte_offset, Object VVMAX, int VVMAX_byte_offset);

  /** Interface to C language function: <br> <code> void vvel(float *  pcb, float *  PEQLEV, float *  P, float *  HT, float *  TP, float *  TVE, float *  TVP, float *  WLCL, int *  NPAR, float *  VV, float *  VVMAX); </code>    */
  public static void vvel(float[] pcb, int pcb_offset, float[] PEQLEV, int PEQLEV_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] TP, int TP_offset, float[] TVE, int TVE_offset, float[] TVP, int TVP_offset, float[] WLCL, int WLCL_offset, int[] NPAR, int NPAR_offset, float[] VV, int VV_offset, float[] VVMAX, int VVMAX_offset)
  {
    if(pcb != null && pcb.length <= pcb_offset)
      throw new RuntimeException("array offset argument \"pcb_offset\" (" + pcb_offset + ") equals or exceeds array length (" + pcb.length + ")");
    if(PEQLEV != null && PEQLEV.length <= PEQLEV_offset)
      throw new RuntimeException("array offset argument \"PEQLEV_offset\" (" + PEQLEV_offset + ") equals or exceeds array length (" + PEQLEV.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(TP != null && TP.length <= TP_offset)
      throw new RuntimeException("array offset argument \"TP_offset\" (" + TP_offset + ") equals or exceeds array length (" + TP.length + ")");
    if(TVE != null && TVE.length <= TVE_offset)
      throw new RuntimeException("array offset argument \"TVE_offset\" (" + TVE_offset + ") equals or exceeds array length (" + TVE.length + ")");
    if(TVP != null && TVP.length <= TVP_offset)
      throw new RuntimeException("array offset argument \"TVP_offset\" (" + TVP_offset + ") equals or exceeds array length (" + TVP.length + ")");
    if(WLCL != null && WLCL.length <= WLCL_offset)
      throw new RuntimeException("array offset argument \"WLCL_offset\" (" + WLCL_offset + ") equals or exceeds array length (" + WLCL.length + ")");
    if(NPAR != null && NPAR.length <= NPAR_offset)
      throw new RuntimeException("array offset argument \"NPAR_offset\" (" + NPAR_offset + ") equals or exceeds array length (" + NPAR.length + ")");
    if(VV != null && VV.length <= VV_offset)
      throw new RuntimeException("array offset argument \"VV_offset\" (" + VV_offset + ") equals or exceeds array length (" + VV.length + ")");
    if(VVMAX != null && VVMAX.length <= VVMAX_offset)
      throw new RuntimeException("array offset argument \"VVMAX_offset\" (" + VVMAX_offset + ") equals or exceeds array length (" + VVMAX.length + ")");
        vvel1(pcb, BufferFactory.SIZEOF_FLOAT * pcb_offset, PEQLEV, BufferFactory.SIZEOF_FLOAT * PEQLEV_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, TP, BufferFactory.SIZEOF_FLOAT * TP_offset, TVE, BufferFactory.SIZEOF_FLOAT * TVE_offset, TVP, BufferFactory.SIZEOF_FLOAT * TVP_offset, WLCL, BufferFactory.SIZEOF_FLOAT * WLCL_offset, NPAR, BufferFactory.SIZEOF_INT * NPAR_offset, VV, BufferFactory.SIZEOF_FLOAT * VV_offset, VVMAX, BufferFactory.SIZEOF_FLOAT * VVMAX_offset);

  }

  /** Interface to C language function: <br> <code> void wbzero(float *  ELEV, float *  P, float *  HT, float *  Tt, float *  TD, int *  NLVLS, float *  PWBZ, float *  HWBZ, float *  TWBZ); </code>    */
  public static void wbzero(java.nio.FloatBuffer ELEV, java.nio.FloatBuffer P, java.nio.FloatBuffer HT, java.nio.FloatBuffer Tt, java.nio.FloatBuffer TD, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer PWBZ, java.nio.FloatBuffer HWBZ, java.nio.FloatBuffer TWBZ)
  {
    boolean _direct = BufferFactory.isDirect(ELEV);
    if (P != null && _direct != BufferFactory.isDirect(P))
      throw new RuntimeException("Argument \"P\" : Buffers passed to this method must all be either direct or indirect");
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (Tt != null && _direct != BufferFactory.isDirect(Tt))
      throw new RuntimeException("Argument \"Tt\" : Buffers passed to this method must all be either direct or indirect");
    if (TD != null && _direct != BufferFactory.isDirect(TD))
      throw new RuntimeException("Argument \"TD\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (PWBZ != null && _direct != BufferFactory.isDirect(PWBZ))
      throw new RuntimeException("Argument \"PWBZ\" : Buffers passed to this method must all be either direct or indirect");
    if (HWBZ != null && _direct != BufferFactory.isDirect(HWBZ))
      throw new RuntimeException("Argument \"HWBZ\" : Buffers passed to this method must all be either direct or indirect");
    if (TWBZ != null && _direct != BufferFactory.isDirect(TWBZ))
      throw new RuntimeException("Argument \"TWBZ\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        wbzero0(ELEV, BufferFactory.getDirectBufferByteOffset(ELEV), P, BufferFactory.getDirectBufferByteOffset(P), HT, BufferFactory.getDirectBufferByteOffset(HT), Tt, BufferFactory.getDirectBufferByteOffset(Tt), TD, BufferFactory.getDirectBufferByteOffset(TD), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), PWBZ, BufferFactory.getDirectBufferByteOffset(PWBZ), HWBZ, BufferFactory.getDirectBufferByteOffset(HWBZ), TWBZ, BufferFactory.getDirectBufferByteOffset(TWBZ));
    } else {
      wbzero1(BufferFactory.getArray(ELEV), BufferFactory.getIndirectBufferByteOffset(ELEV), BufferFactory.getArray(P), BufferFactory.getIndirectBufferByteOffset(P), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(Tt), BufferFactory.getIndirectBufferByteOffset(Tt), BufferFactory.getArray(TD), BufferFactory.getIndirectBufferByteOffset(TD), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(PWBZ), BufferFactory.getIndirectBufferByteOffset(PWBZ), BufferFactory.getArray(HWBZ), BufferFactory.getIndirectBufferByteOffset(HWBZ), BufferFactory.getArray(TWBZ), BufferFactory.getIndirectBufferByteOffset(TWBZ));
    }
  }

  /** Entry point to C language function: <br> <code> void wbzero(float *  ELEV, float *  P, float *  HT, float *  Tt, float *  TD, int *  NLVLS, float *  PWBZ, float *  HWBZ, float *  TWBZ); </code>    */
  private static native void wbzero0(Object ELEV, int ELEV_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object Tt, int Tt_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PWBZ, int PWBZ_byte_offset, Object HWBZ, int HWBZ_byte_offset, Object TWBZ, int TWBZ_byte_offset);

  /** Entry point to C language function: <br> <code> void wbzero(float *  ELEV, float *  P, float *  HT, float *  Tt, float *  TD, int *  NLVLS, float *  PWBZ, float *  HWBZ, float *  TWBZ); </code>    */
  private static native void wbzero1(Object ELEV, int ELEV_byte_offset, Object P, int P_byte_offset, Object HT, int HT_byte_offset, Object Tt, int Tt_byte_offset, Object TD, int TD_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object PWBZ, int PWBZ_byte_offset, Object HWBZ, int HWBZ_byte_offset, Object TWBZ, int TWBZ_byte_offset);

  /** Interface to C language function: <br> <code> void wbzero(float *  ELEV, float *  P, float *  HT, float *  Tt, float *  TD, int *  NLVLS, float *  PWBZ, float *  HWBZ, float *  TWBZ); </code>    */
  public static void wbzero(float[] ELEV, int ELEV_offset, float[] P, int P_offset, float[] HT, int HT_offset, float[] Tt, int Tt_offset, float[] TD, int TD_offset, int[] NLVLS, int NLVLS_offset, float[] PWBZ, int PWBZ_offset, float[] HWBZ, int HWBZ_offset, float[] TWBZ, int TWBZ_offset)
  {
    if(ELEV != null && ELEV.length <= ELEV_offset)
      throw new RuntimeException("array offset argument \"ELEV_offset\" (" + ELEV_offset + ") equals or exceeds array length (" + ELEV.length + ")");
    if(P != null && P.length <= P_offset)
      throw new RuntimeException("array offset argument \"P_offset\" (" + P_offset + ") equals or exceeds array length (" + P.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(Tt != null && Tt.length <= Tt_offset)
      throw new RuntimeException("array offset argument \"Tt_offset\" (" + Tt_offset + ") equals or exceeds array length (" + Tt.length + ")");
    if(TD != null && TD.length <= TD_offset)
      throw new RuntimeException("array offset argument \"TD_offset\" (" + TD_offset + ") equals or exceeds array length (" + TD.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(PWBZ != null && PWBZ.length <= PWBZ_offset)
      throw new RuntimeException("array offset argument \"PWBZ_offset\" (" + PWBZ_offset + ") equals or exceeds array length (" + PWBZ.length + ")");
    if(HWBZ != null && HWBZ.length <= HWBZ_offset)
      throw new RuntimeException("array offset argument \"HWBZ_offset\" (" + HWBZ_offset + ") equals or exceeds array length (" + HWBZ.length + ")");
    if(TWBZ != null && TWBZ.length <= TWBZ_offset)
      throw new RuntimeException("array offset argument \"TWBZ_offset\" (" + TWBZ_offset + ") equals or exceeds array length (" + TWBZ.length + ")");
        wbzero1(ELEV, BufferFactory.SIZEOF_FLOAT * ELEV_offset, P, BufferFactory.SIZEOF_FLOAT * P_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, Tt, BufferFactory.SIZEOF_FLOAT * Tt_offset, TD, BufferFactory.SIZEOF_FLOAT * TD_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, PWBZ, BufferFactory.SIZEOF_FLOAT * PWBZ_offset, HWBZ, BufferFactory.SIZEOF_FLOAT * HWBZ_offset, TWBZ, BufferFactory.SIZEOF_FLOAT * TWBZ_offset);

  }

  /** Interface to C language function: <br> <code> void winddir(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  public static void winddir(java.nio.FloatBuffer u, java.nio.FloatBuffer v, java.nio.FloatBuffer ff, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(u);
    if (v != null && _direct != BufferFactory.isDirect(v))
      throw new RuntimeException("Argument \"v\" : Buffers passed to this method must all be either direct or indirect");
    if (ff != null && _direct != BufferFactory.isDirect(ff))
      throw new RuntimeException("Argument \"ff\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        winddir0(u, BufferFactory.getDirectBufferByteOffset(u), v, BufferFactory.getDirectBufferByteOffset(v), ff, BufferFactory.getDirectBufferByteOffset(ff), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      winddir1(BufferFactory.getArray(u), BufferFactory.getIndirectBufferByteOffset(u), BufferFactory.getArray(v), BufferFactory.getIndirectBufferByteOffset(v), BufferFactory.getArray(ff), BufferFactory.getIndirectBufferByteOffset(ff), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void winddir(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void winddir0(Object u, int u_byte_offset, Object v, int v_byte_offset, Object ff, int ff_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void winddir(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void winddir1(Object u, int u_byte_offset, Object v, int v_byte_offset, Object ff, int ff_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void winddir(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  public static void winddir(float[] u, int u_offset, float[] v, int v_offset, float[] ff, int ff_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(u != null && u.length <= u_offset)
      throw new RuntimeException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    if(ff != null && ff.length <= ff_offset)
      throw new RuntimeException("array offset argument \"ff_offset\" (" + ff_offset + ") equals or exceeds array length (" + ff.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        winddir1(u, BufferFactory.SIZEOF_FLOAT * u_offset, v, BufferFactory.SIZEOF_FLOAT * v_offset, ff, BufferFactory.SIZEOF_FLOAT * ff_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void windspeed(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  public static void windspeed(java.nio.FloatBuffer u, java.nio.FloatBuffer v, java.nio.FloatBuffer ff, java.nio.IntBuffer mni, java.nio.IntBuffer ni, java.nio.IntBuffer nj)
  {
    boolean _direct = BufferFactory.isDirect(u);
    if (v != null && _direct != BufferFactory.isDirect(v))
      throw new RuntimeException("Argument \"v\" : Buffers passed to this method must all be either direct or indirect");
    if (ff != null && _direct != BufferFactory.isDirect(ff))
      throw new RuntimeException("Argument \"ff\" : Buffers passed to this method must all be either direct or indirect");
    if (mni != null && _direct != BufferFactory.isDirect(mni))
      throw new RuntimeException("Argument \"mni\" : Buffers passed to this method must all be either direct or indirect");
    if (ni != null && _direct != BufferFactory.isDirect(ni))
      throw new RuntimeException("Argument \"ni\" : Buffers passed to this method must all be either direct or indirect");
    if (nj != null && _direct != BufferFactory.isDirect(nj))
      throw new RuntimeException("Argument \"nj\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        windspeed0(u, BufferFactory.getDirectBufferByteOffset(u), v, BufferFactory.getDirectBufferByteOffset(v), ff, BufferFactory.getDirectBufferByteOffset(ff), mni, BufferFactory.getDirectBufferByteOffset(mni), ni, BufferFactory.getDirectBufferByteOffset(ni), nj, BufferFactory.getDirectBufferByteOffset(nj));
    } else {
      windspeed1(BufferFactory.getArray(u), BufferFactory.getIndirectBufferByteOffset(u), BufferFactory.getArray(v), BufferFactory.getIndirectBufferByteOffset(v), BufferFactory.getArray(ff), BufferFactory.getIndirectBufferByteOffset(ff), BufferFactory.getArray(mni), BufferFactory.getIndirectBufferByteOffset(mni), BufferFactory.getArray(ni), BufferFactory.getIndirectBufferByteOffset(ni), BufferFactory.getArray(nj), BufferFactory.getIndirectBufferByteOffset(nj));
    }
  }

  /** Entry point to C language function: <br> <code> void windspeed(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void windspeed0(Object u, int u_byte_offset, Object v, int v_byte_offset, Object ff, int ff_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Entry point to C language function: <br> <code> void windspeed(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  private static native void windspeed1(Object u, int u_byte_offset, Object v, int v_byte_offset, Object ff, int ff_byte_offset, Object mni, int mni_byte_offset, Object ni, int ni_byte_offset, Object nj, int nj_byte_offset);

  /** Interface to C language function: <br> <code> void windspeed(float *  u, float *  v, float *  ff, int *  mni, int *  ni, int *  nj); </code>    */
  public static void windspeed(float[] u, int u_offset, float[] v, int v_offset, float[] ff, int ff_offset, int[] mni, int mni_offset, int[] ni, int ni_offset, int[] nj, int nj_offset)
  {
    if(u != null && u.length <= u_offset)
      throw new RuntimeException("array offset argument \"u_offset\" (" + u_offset + ") equals or exceeds array length (" + u.length + ")");
    if(v != null && v.length <= v_offset)
      throw new RuntimeException("array offset argument \"v_offset\" (" + v_offset + ") equals or exceeds array length (" + v.length + ")");
    if(ff != null && ff.length <= ff_offset)
      throw new RuntimeException("array offset argument \"ff_offset\" (" + ff_offset + ") equals or exceeds array length (" + ff.length + ")");
    if(mni != null && mni.length <= mni_offset)
      throw new RuntimeException("array offset argument \"mni_offset\" (" + mni_offset + ") equals or exceeds array length (" + mni.length + ")");
    if(ni != null && ni.length <= ni_offset)
      throw new RuntimeException("array offset argument \"ni_offset\" (" + ni_offset + ") equals or exceeds array length (" + ni.length + ")");
    if(nj != null && nj.length <= nj_offset)
      throw new RuntimeException("array offset argument \"nj_offset\" (" + nj_offset + ") equals or exceeds array length (" + nj.length + ")");
        windspeed1(u, BufferFactory.SIZEOF_FLOAT * u_offset, v, BufferFactory.SIZEOF_FLOAT * v_offset, ff, BufferFactory.SIZEOF_FLOAT * ff_offset, mni, BufferFactory.SIZEOF_INT * mni_offset, ni, BufferFactory.SIZEOF_INT * ni_offset, nj, BufferFactory.SIZEOF_INT * nj_offset);

  }

  /** Interface to C language function: <br> <code> void wndrho(float *  RHO, float *  HT, int *  NLVLS, float *  HW, int *  NW, float *  RHOW); </code>    */
  public static void wndrho(java.nio.FloatBuffer RHO, java.nio.FloatBuffer HT, java.nio.IntBuffer NLVLS, java.nio.FloatBuffer HW, java.nio.IntBuffer NW, java.nio.FloatBuffer RHOW)
  {
    boolean _direct = BufferFactory.isDirect(RHO);
    if (HT != null && _direct != BufferFactory.isDirect(HT))
      throw new RuntimeException("Argument \"HT\" : Buffers passed to this method must all be either direct or indirect");
    if (NLVLS != null && _direct != BufferFactory.isDirect(NLVLS))
      throw new RuntimeException("Argument \"NLVLS\" : Buffers passed to this method must all be either direct or indirect");
    if (HW != null && _direct != BufferFactory.isDirect(HW))
      throw new RuntimeException("Argument \"HW\" : Buffers passed to this method must all be either direct or indirect");
    if (NW != null && _direct != BufferFactory.isDirect(NW))
      throw new RuntimeException("Argument \"NW\" : Buffers passed to this method must all be either direct or indirect");
    if (RHOW != null && _direct != BufferFactory.isDirect(RHOW))
      throw new RuntimeException("Argument \"RHOW\" : Buffers passed to this method must all be either direct or indirect");
    if (_direct) {
        wndrho0(RHO, BufferFactory.getDirectBufferByteOffset(RHO), HT, BufferFactory.getDirectBufferByteOffset(HT), NLVLS, BufferFactory.getDirectBufferByteOffset(NLVLS), HW, BufferFactory.getDirectBufferByteOffset(HW), NW, BufferFactory.getDirectBufferByteOffset(NW), RHOW, BufferFactory.getDirectBufferByteOffset(RHOW));
    } else {
      wndrho1(BufferFactory.getArray(RHO), BufferFactory.getIndirectBufferByteOffset(RHO), BufferFactory.getArray(HT), BufferFactory.getIndirectBufferByteOffset(HT), BufferFactory.getArray(NLVLS), BufferFactory.getIndirectBufferByteOffset(NLVLS), BufferFactory.getArray(HW), BufferFactory.getIndirectBufferByteOffset(HW), BufferFactory.getArray(NW), BufferFactory.getIndirectBufferByteOffset(NW), BufferFactory.getArray(RHOW), BufferFactory.getIndirectBufferByteOffset(RHOW));
    }
  }

  /** Entry point to C language function: <br> <code> void wndrho(float *  RHO, float *  HT, int *  NLVLS, float *  HW, int *  NW, float *  RHOW); </code>    */
  private static native void wndrho0(Object RHO, int RHO_byte_offset, Object HT, int HT_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object HW, int HW_byte_offset, Object NW, int NW_byte_offset, Object RHOW, int RHOW_byte_offset);

  /** Entry point to C language function: <br> <code> void wndrho(float *  RHO, float *  HT, int *  NLVLS, float *  HW, int *  NW, float *  RHOW); </code>    */
  private static native void wndrho1(Object RHO, int RHO_byte_offset, Object HT, int HT_byte_offset, Object NLVLS, int NLVLS_byte_offset, Object HW, int HW_byte_offset, Object NW, int NW_byte_offset, Object RHOW, int RHOW_byte_offset);

  /** Interface to C language function: <br> <code> void wndrho(float *  RHO, float *  HT, int *  NLVLS, float *  HW, int *  NW, float *  RHOW); </code>    */
  public static void wndrho(float[] RHO, int RHO_offset, float[] HT, int HT_offset, int[] NLVLS, int NLVLS_offset, float[] HW, int HW_offset, int[] NW, int NW_offset, float[] RHOW, int RHOW_offset)
  {
    if(RHO != null && RHO.length <= RHO_offset)
      throw new RuntimeException("array offset argument \"RHO_offset\" (" + RHO_offset + ") equals or exceeds array length (" + RHO.length + ")");
    if(HT != null && HT.length <= HT_offset)
      throw new RuntimeException("array offset argument \"HT_offset\" (" + HT_offset + ") equals or exceeds array length (" + HT.length + ")");
    if(NLVLS != null && NLVLS.length <= NLVLS_offset)
      throw new RuntimeException("array offset argument \"NLVLS_offset\" (" + NLVLS_offset + ") equals or exceeds array length (" + NLVLS.length + ")");
    if(HW != null && HW.length <= HW_offset)
      throw new RuntimeException("array offset argument \"HW_offset\" (" + HW_offset + ") equals or exceeds array length (" + HW.length + ")");
    if(NW != null && NW.length <= NW_offset)
      throw new RuntimeException("array offset argument \"NW_offset\" (" + NW_offset + ") equals or exceeds array length (" + NW.length + ")");
    if(RHOW != null && RHOW.length <= RHOW_offset)
      throw new RuntimeException("array offset argument \"RHOW_offset\" (" + RHOW_offset + ") equals or exceeds array length (" + RHOW.length + ")");
        wndrho1(RHO, BufferFactory.SIZEOF_FLOAT * RHO_offset, HT, BufferFactory.SIZEOF_FLOAT * HT_offset, NLVLS, BufferFactory.SIZEOF_INT * NLVLS_offset, HW, BufferFactory.SIZEOF_FLOAT * HW_offset, NW, BufferFactory.SIZEOF_INT * NW_offset, RHOW, BufferFactory.SIZEOF_FLOAT * RHOW_offset);

  }

  /** Interface to C language function: <br> <code> float ztopsa(float * ); </code>    */
  public static float ztopsa(java.nio.FloatBuffer arg0)
  {
    boolean _direct = BufferFactory.isDirect(arg0);
    if (_direct) {
        return ztopsa0(arg0, BufferFactory.getDirectBufferByteOffset(arg0));
    } else {
      return ztopsa1(BufferFactory.getArray(arg0), BufferFactory.getIndirectBufferByteOffset(arg0));
    }
  }

  /** Entry point to C language function: <br> <code> float ztopsa(float * ); </code>    */
  private static native float ztopsa0(Object arg0, int arg0_byte_offset);

  /** Entry point to C language function: <br> <code> float ztopsa(float * ); </code>    */
  private static native float ztopsa1(Object arg0, int arg0_byte_offset);

  /** Interface to C language function: <br> <code> float ztopsa(float * ); </code>    */
  public static float ztopsa(float[] arg0, int arg0_offset)
  {
    if(arg0 != null && arg0.length <= arg0_offset)
      throw new RuntimeException("array offset argument \"arg0_offset\" (" + arg0_offset + ") equals or exceeds array length (" + arg0.length + ")");
        return ztopsa1(arg0, BufferFactory.SIZEOF_FLOAT * arg0_offset);

  }


} // end of class Meteolibrary
