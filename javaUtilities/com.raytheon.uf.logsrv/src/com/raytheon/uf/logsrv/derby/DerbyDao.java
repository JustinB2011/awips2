/**
 * This software was developed and / or modified by Raytheon Company,
 * pursuant to Contract DG133W-05-CQ-1067 with the US Government.
 * 
 * U.S. EXPORT CONTROLLED TECHNICAL DATA
 * This software product contains export-restricted data whose
 * export/transfer/disclosure is restricted by U.S. law. Dissemination
 * to non-U.S. persons whether in the United States or abroad requires
 * an export license or other authorization.
 * 
 * Contractor Name:        Raytheon Company
 * Contractor Address:     6825 Pine Street, Suite 340
 *                         Mail Stop B8
 *                         Omaha, NE 68106
 *                         402.291.0100
 * 
 * See the AWIPS II Master Rights File ("Master Rights File.pdf") for
 * further licensing information.
 **/
package com.raytheon.uf.logsrv.derby;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;

import com.raytheon.uf.logsrv.LogService;
import com.raytheon.uf.logsrv.LogServiceException;
import com.raytheon.uf.logsrv.StoredMsg;
import com.raytheon.uf.logsrv.config.LogSrvConfig;
import com.raytheon.uf.logsrv.report.data.LogReportContainer;
import com.raytheon.uf.logsrv.report.data.LogReportEvent;

/**
 * DAO for interacting with the derby database to add rows or create report
 * objects.
 * 
 * <pre>
 * 
 * SOFTWARE HISTORY
 * 
 * Date         Ticket#    Engineer    Description
 * ------------ ---------- ----------- --------------------------
 * Aug 27, 2013            njensen     Initial creation
 * 
 * </pre>
 * 
 * @author njensen
 * @version 1.0
 */

public class DerbyDao {

    private static final String DRIVER = "org.apache.derby.jdbc.EmbeddedDriver";

    private static final String TABLE = "log";

    private static final int MAX_STR_LEN = 32672;

    private static final String DB_CREATE = "CREATE TABLE " + TABLE
            + "(pk INT NOT NULL GENERATED BY DEFAULT AS IDENTITY, "
            + "eventTime TIMESTAMP, " + "message VARCHAR(" + MAX_STR_LEN
            + "), " + "javaClass VARCHAR(128), " + "lineNumber INT, "
            + "stacktrace VARCHAR(" + MAX_STR_LEN + "), "
            + "threadName VARCHAR(128), " + "machineName VARCHAR(128), "
            + "level VARCHAR(32))";

    private static final String INSERT_PREPARED_STATEMENT = "INSERT INTO "
            + TABLE
            + "(eventTime, message, javaClass, lineNumber, stacktrace, threadName, machineName, level) "
            + "values (?, ?, ?, ?, ?, ?, ?, ?)";

    private static final String PURGE_STATEMENT = "DELETE from " + TABLE;

    private static final String TIME_STATEMENT = "select min(eventTime), max(eventTime) FROM "
            + TABLE;

    private static final String COUNT_STATEMENT = "select count(*) from "
            + TABLE;

    private PreparedStatement saveStatement;

    private PreparedStatement purgeStatement;

    private PreparedStatement timeStatement;

    private PreparedStatement countStatement;

    private Connection connection;

    private static DerbyDao instance = new DerbyDao();

    private LogSrvConfig config;

    private DerbyDao() {

    }

    public static DerbyDao getInstance() {
        return instance;
    }

    public void setConfig(LogSrvConfig cfg) {
        config = cfg;
    }

    public LogSrvConfig getConfig() {
        return config;
    }

    /**
     * Creates a connection to derby
     * 
     * @return
     * @throws LogServiceException
     */
    private Connection createConnection() throws LogServiceException {
        Statement statement = null;
        boolean errorOccurred = false;
        Connection connection = null;
        try {
            Class.forName(DRIVER).newInstance();
            connection = DriverManager.getConnection("jdbc:derby:directory:"
                    + config.getDatabaseDir() + ";create=true");
            DatabaseMetaData dmd = connection.getMetaData();
            ResultSet tables = dmd.getTables(null, null, null,
                    new String[] { "TABLE" });
            boolean needCreation = true;

            while (tables.next()) {
                String tableName = tables.getString("TABLE_NAME");
                if (tableName.equalsIgnoreCase(TABLE)) {
                    needCreation = false;
                    break;
                }
            }

            if (needCreation) {
                statement = connection.createStatement();
                statement.execute(DB_CREATE);
            }
            connection.commit();
        } catch (Exception e) {
            errorOccurred = true;
            throw new LogServiceException("Error setting up database", e);
        } finally {
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection(connection);
            }
        }

        return connection;
    }

    /**
     * Inserts a StoredMsg as a row in the database table
     * 
     * @param event
     * @throws LogServiceException
     */
    public synchronized void insert(StoredMsg event) throws LogServiceException {
        boolean errorOccurred = false;
        Connection conn = null;

        try {
            conn = getConnection();
            if (saveStatement == null) {
                saveStatement = conn
                        .prepareStatement(INSERT_PREPARED_STATEMENT);
            }

            saveStatement.setTimestamp(1, new Timestamp(event.getEventTime()
                    .getTime()));
            if (event.getMessage() == null
                    || event.getMessage().length() < MAX_STR_LEN) {
                saveStatement.setString(2, event.getMessage());
            } else {
                saveStatement.setString(2,
                        event.getMessage().substring(0, MAX_STR_LEN - 1));
            }
            saveStatement.setString(3, event.getJavaClass());
            saveStatement.setInt(4, event.getLineNumber());
            if (event.getStacktrace() == null
                    || event.getStacktrace().length() < MAX_STR_LEN) {
                saveStatement.setString(5, event.getStacktrace());
            } else {
                saveStatement.setString(5,
                        event.getStacktrace().substring(0, MAX_STR_LEN - 1));
            }
            saveStatement.setString(6, event.getThreadName());
            saveStatement.setString(7, event.getMachineName());
            saveStatement.setString(8, event.getLevel());
            int result = saveStatement.executeUpdate();
            if (result < 1) {
                errorOccurred = true;
                LogService.getLogger().error("Insert of logging event failed");
            } else {
                conn.commit();
            }
        } catch (Exception e) {
            errorOccurred = true;
            throw new LogServiceException(
                    "Error inserting event into log database", e);
        } finally {
            if (errorOccurred) {
                closeStatement(saveStatement);
                saveStatement = null;
                closeConnection(conn);
            }
        }
    }

    /**
     * Gets the cached connection to the database
     * 
     * @return
     * @throws LogServiceException
     */
    private synchronized Connection getConnection() throws LogServiceException {
        if (connection != null) {
            try {
                if (connection.isClosed()) {
                    closeConnection(connection);
                }
            } catch (SQLException e) {
                throw new LogServiceException("Error closing connection", e);
            }
        }
        if (connection == null) {
            try {
                connection = createConnection();
            } catch (Exception e) {
                throw new LogServiceException("Error creating connection", e);
            }
        }

        return connection;
    }

    /**
     * Closes a statement
     * 
     * @param statement
     */
    private void closeStatement(Statement statement) {
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    /**
     * Closes the connection to the database
     * 
     * @param connection
     */
    private void closeConnection(Connection connection) {
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                // ignore
            }
            connection = null;
        }

        try {
            DriverManager.getConnection("jdbc:derby:directory:"
                    + config.getDatabaseDir() + ";shutdown=true");
        } catch (SQLException e) {
            // ignore as stop database will always throw an exception
        }
    }

    /**
     * Closes a result set
     * 
     * @param rs
     */
    private void closeResultSet(ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {
                // ignore
            }
        }
    }

    /**
     * Queries for rows that include stacktraces and correlates them into a
     * LogReportContainer
     * 
     * @return
     * @throws LogServiceException
     */
    private LogReportContainer queryEventsWithStacks()
            throws LogServiceException {
        Connection conn = null;
        boolean errorOccurred = false;
        Statement statement = null;
        ResultSet rs = null;
        LogReportContainer container = new LogReportContainer();
        try {
            conn = getConnection();
            statement = conn.createStatement();
            // line number of 0 indicates that there was no stacktrace with
            // the error, those will be handled separately
            rs = statement
                    .executeQuery("select javaClass, lineNumber, machineName, count(*) "
                            + "from log where lineNumber != 0 "
                            + "group by javaClass, lineNumber, machineName");
            conn.commit();
            while (rs.next()) {
                String javaClass = rs.getString(1);
                int lineNumber = rs.getInt(2);
                String machineName = rs.getString(3);
                int count = rs.getInt(4);
                LogReportEvent occ = new LogReportEvent();
                // errors sent in without a stacktrace will not have a line
                // number of java class
                occ.setJavaClass(javaClass);
                occ.setLineNumber(lineNumber);
                container.addError(occ, machineName, count);
            }
            return container;
        } catch (SQLException e) {
            errorOccurred = true;
            throw new LogServiceException("Error executing query", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection(conn);
            }
        }
    }

    /**
     * Loops through the LogReportContainer's events and queries for sample
     * stacktraces and messages for them.
     * 
     * @param container
     * @throws LogServiceException
     */
    private void addSamples(LogReportContainer container)
            throws LogServiceException {
        for (LogReportEvent event : container.getEvents()) {
            addSamples(event);
        }
    }

    /**
     * Fills in a LogReportEvent with a sample stacktrace and message
     * 
     * @param event
     * @throws LogServiceException
     */
    private void addSamples(LogReportEvent event) throws LogServiceException {
        Connection conn = null;
        boolean errorOccurred = false;
        Statement statement = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            statement = conn.createStatement();
            statement.setFetchSize(1);
            statement.setMaxRows(1);
            rs = statement.executeQuery("select message, stacktrace, level "
                    + "from log where javaClass ='" + event.getJavaClass()
                    + "' and lineNumber = " + event.getLineNumber());
            conn.commit();
            while (rs.next()) {
                String message = rs.getString(1);
                String stacktrace = rs.getString(2);
                String level = rs.getString(3);
                event.setSampleMessage(message);
                event.setSampleStacktrace(stacktrace);
                event.setLevel(level);
            }
        } catch (SQLException e) {
            errorOccurred = true;
            throw new LogServiceException("Error executing query", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection(conn);
            }
        }
    }

    /**
     * Queries for rows that don't have stacktraces and adds them to the
     * LogReportContainer
     * 
     * @param container
     * @throws LogServiceException
     */
    private void addNoStacktraceMessages(LogReportContainer container)
            throws LogServiceException {
        Connection conn = null;
        boolean errorOccurred = false;
        Statement statement = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            statement = conn.createStatement();
            rs = statement
                    .executeQuery("select message, machineName, level, threadName, count(*) from log "
                            + "where lineNumber = 0 group by message, machineName, level, threadName");
            conn.commit();
            while (rs.next()) {
                String message = rs.getString(1);
                String machineName = rs.getString(2);
                String level = rs.getString(3);
                String thread = rs.getString(4);
                int count = rs.getInt(5);
                LogReportEvent event = new LogReportEvent();
                event.setSampleMessage(message);
                event.setLevel(level);
                event.setThreadName(thread);
                container.addError(event, machineName, count);
            }
        } catch (SQLException e) {
            errorOccurred = true;
            throw new LogServiceException("Error executing query", e);
        } finally {
            closeResultSet(rs);
            closeStatement(statement);
            if (errorOccurred) {
                closeConnection(conn);
            }
        }
    }

    /**
     * Queries for the earliest and latest time in the database and sets them on
     * the LogReportContainer
     * 
     * @param container
     * @throws LogServiceException
     */
    private void addTimes(LogReportContainer container)
            throws LogServiceException {
        boolean errorOccurred = false;
        Connection conn = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            if (timeStatement == null) {
                timeStatement = conn.prepareStatement(TIME_STATEMENT);
            }
            rs = timeStatement.executeQuery();
            conn.commit();
            rs.next();
            container.setEarliestTime(rs.getTimestamp(1));
            container.setLatestTime(rs.getTimestamp(2));
        } catch (Exception e) {
            errorOccurred = true;
            throw new LogServiceException(
                    "Error determining min and max times", e);
        } finally {
            closeResultSet(rs);
            if (errorOccurred) {
                closeStatement(timeStatement);
                timeStatement = null;
                closeConnection(conn);
            }
        }
    }

    /**
     * Builds a LogReportContainer that correlates different rows as the same
     * event, fills in sample stacktraces and messages, and includes the
     * earliest and latest times of the events.
     * 
     * @return
     * @throws LogServiceException
     */
    public LogReportContainer buildReport() throws LogServiceException {
        LogReportContainer container = queryEventsWithStacks();
        addSamples(container);
        addNoStacktraceMessages(container);
        addTimes(container);
        return container;
    }

    /**
     * Clears all rows from the database
     * 
     * @throws LogServiceException
     */
    public void clearEntries() throws LogServiceException {
        boolean errorOccurred = false;
        Connection conn = null;

        try {
            conn = getConnection();
            if (purgeStatement == null) {
                purgeStatement = conn.prepareStatement(PURGE_STATEMENT);
            }
            purgeStatement.executeUpdate();
            conn.commit();
        } catch (Exception e) {
            errorOccurred = true;
            throw new LogServiceException("Error purging message database", e);
        } finally {
            if (errorOccurred) {
                closeStatement(purgeStatement);
                purgeStatement = null;
                closeConnection(conn);
            }
        }
    }

    /**
     * Queries the database to determine the number of rows
     * 
     * @return
     * @throws LogServiceException
     */
    public int getCurrentRowCount() throws LogServiceException {
        boolean errorOccurred = false;
        Connection conn = null;
        try {
            conn = getConnection();
            if (countStatement == null) {
                countStatement = conn.prepareStatement(COUNT_STATEMENT);
            }
            ResultSet rs = countStatement.executeQuery();
            conn.commit();
            rs.next();
            return rs.getInt(1);
        } catch (Exception e) {
            errorOccurred = true;
            throw new LogServiceException("Error determining row count", e);
        } finally {
            if (errorOccurred) {
                closeStatement(countStatement);
                countStatement = null;
                closeConnection(conn);
            }
        }
    }

}
